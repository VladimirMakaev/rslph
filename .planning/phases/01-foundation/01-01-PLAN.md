# Plan 01-01: Config System

## Frontmatter

```yaml
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/main.rs
  - src/lib.rs
  - src/config.rs
  - src/error.rs
autonomous: true
estimated_tasks: 3
```

## Context

This plan establishes the configuration system for rslph. It creates the foundational project structure (Cargo.toml, src/) and implements TOML-based configuration with sensible defaults. The config system uses figment for layered merging (defaults < file < env) and directories for XDG-compliant paths.

**Requirements covered:** CFG-01, CFG-03, CFG-04, CFG-05, CFG-06, CFG-07, CFG-08

**Key insight from research:** Use `#[serde(default)]` on Config struct to allow partial config files. Use `#[serde(deny_unknown_fields)]` to catch typos. Handle missing config file gracefully (first-run scenario).

## Tasks

<task id="1">
<title>Create project skeleton with dependencies</title>
<what>
Initialize Rust project with required dependencies for Phase 1.
</what>
<how>
1. Create `Cargo.toml` with:
   - Package metadata (name = "rslph", version = "0.1.0", edition = "2021")
   - Dependencies:
     - clap = { version = "4.5", features = ["derive", "env"] }
     - figment = { version = "0.10", features = ["toml", "env"] }
     - serde = { version = "1.0", features = ["derive"] }
     - directories = "6.0"
     - pulldown-cmark = "0.13"
     - atomicwrites = "0.4"
     - color-eyre = "0.6"
     - thiserror = "2.0"

2. Create `src/main.rs` with minimal stub:
   ```rust
   mod config;
   mod error;

   fn main() -> color_eyre::Result<()> {
       color_eyre::install()?;
       println!("rslph - Ralph Wiggum Loop");
       Ok(())
   }
   ```

3. Create `src/lib.rs` that re-exports public modules:
   ```rust
   pub mod config;
   pub mod error;
   ```

4. Run `cargo build` to verify dependencies resolve.
</how>
<done>
- `cargo build` succeeds with no errors
- All dependencies from research are in Cargo.toml
- src/main.rs, src/lib.rs exist and compile
</done>
</task>

<task id="2">
<title>Implement Config struct with defaults</title>
<what>
Create the Config struct with all configuration fields and sensible defaults per requirements CFG-03 through CFG-08.
</what>
<how>
1. Create `src/config.rs` with Config struct:
   ```rust
   use serde::{Deserialize, Serialize};
   use std::path::PathBuf;

   #[derive(Debug, Clone, Deserialize, Serialize)]
   #[serde(default, deny_unknown_fields)]
   pub struct Config {
       /// Path to claude CLI executable (CFG-03)
       pub claude_path: String,

       /// Maximum iterations before stopping (CFG-06)
       pub max_iterations: u32,

       /// Number of recent threads to display (CFG-07)
       pub recent_threads: u32,

       /// Notification interval - every N iterations (CFG-08)
       pub notify_interval: u32,

       /// Path to plan prompt file override (CFG-04)
       pub plan_prompt: Option<PathBuf>,

       /// Path to build prompt file override (CFG-04)
       pub build_prompt: Option<PathBuf>,

       /// Shell for notify script execution (CFG-05)
       pub notify_shell: String,
   }

   impl Default for Config {
       fn default() -> Self {
           Self {
               claude_path: "claude".to_string(),
               max_iterations: 20,
               recent_threads: 5,
               notify_interval: 10,
               plan_prompt: None,
               build_prompt: None,
               notify_shell: "/bin/sh".to_string(),
           }
       }
   }
   ```

2. Add unit test in same file:
   ```rust
   #[cfg(test)]
   mod tests {
       use super::*;

       #[test]
       fn test_default_config() {
           let config = Config::default();
           assert_eq!(config.claude_path, "claude");
           assert_eq!(config.max_iterations, 20);
           assert_eq!(config.recent_threads, 5);
           assert_eq!(config.notify_interval, 10);
           assert!(config.plan_prompt.is_none());
           assert!(config.build_prompt.is_none());
           assert_eq!(config.notify_shell, "/bin/sh");
       }
   }
   ```

3. Run `cargo test` to verify.
</how>
<done>
- Config struct exists with all 7 fields from requirements
- Default trait implemented with sensible values
- `#[serde(default, deny_unknown_fields)]` applied
- `cargo test` passes for default config test
</done>
</task>

<task id="3">
<title>Implement config loading with layered precedence</title>
<what>
Create config loading function that merges: defaults < config file < environment variables. The CLI layer will be added by Plan 01-02.
</what>
<how>
1. Add to `src/config.rs`:
   ```rust
   use figment::{Figment, providers::{Serialized, Toml, Env}};
   use directories::ProjectDirs;
   use std::path::Path;

   impl Config {
       /// Get the default config file path (XDG-compliant)
       pub fn default_path() -> Option<PathBuf> {
           ProjectDirs::from("", "", "rslph")
               .map(|dirs| dirs.config_dir().join("config.toml"))
       }

       /// Load config from file and environment (CFG-01)
       /// Precedence: defaults < config file < environment
       /// CLI args are merged by the caller (Plan 01-02)
       pub fn load(config_path: Option<&Path>) -> color_eyre::Result<Self> {
           let path = config_path
               .map(PathBuf::from)
               .or_else(Self::default_path);

           let mut figment = Figment::new()
               .merge(Serialized::defaults(Config::default()));

           // Only merge file if it exists (handle first-run gracefully)
           if let Some(ref p) = path {
               if p.exists() {
                   figment = figment.merge(Toml::file(p));
               }
           }

           // Environment variables with RSLPH_ prefix
           figment = figment.merge(Env::prefixed("RSLPH_").split("_"));

           let config: Config = figment.extract()?;
           Ok(config)
       }

       /// Load config with explicit CLI overrides merged last
       /// This is the main entry point used by the CLI
       pub fn load_with_overrides(
           config_path: Option<&Path>,
           overrides: PartialConfig,
       ) -> color_eyre::Result<Self> {
           let path = config_path
               .map(PathBuf::from)
               .or_else(Self::default_path);

           let mut figment = Figment::new()
               .merge(Serialized::defaults(Config::default()));

           if let Some(ref p) = path {
               if p.exists() {
                   figment = figment.merge(Toml::file(p));
               }
           }

           figment = figment.merge(Env::prefixed("RSLPH_").split("_"));

           // CLI overrides are highest precedence
           figment = figment.merge(Serialized::defaults(overrides));

           let config: Config = figment.extract()?;
           Ok(config)
       }
   }

   /// Partial config for CLI overrides (only set fields are merged)
   #[derive(Debug, Default, Serialize)]
   pub struct PartialConfig {
       #[serde(skip_serializing_if = "Option::is_none")]
       pub claude_path: Option<String>,
       #[serde(skip_serializing_if = "Option::is_none")]
       pub max_iterations: Option<u32>,
       #[serde(skip_serializing_if = "Option::is_none")]
       pub recent_threads: Option<u32>,
       #[serde(skip_serializing_if = "Option::is_none")]
       pub notify_interval: Option<u32>,
       #[serde(skip_serializing_if = "Option::is_none")]
       pub plan_prompt: Option<PathBuf>,
       #[serde(skip_serializing_if = "Option::is_none")]
       pub build_prompt: Option<PathBuf>,
       #[serde(skip_serializing_if = "Option::is_none")]
       pub notify_shell: Option<String>,
   }
   ```

2. Create `src/error.rs` with custom error types:
   ```rust
   use thiserror::Error;

   #[derive(Error, Debug)]
   pub enum RslphError {
       #[error("Configuration error: {0}")]
       Config(#[from] figment::Error),

       #[error("IO error: {0}")]
       Io(#[from] std::io::Error),
   }
   ```

3. Add integration test for config loading:
   ```rust
   #[cfg(test)]
   mod tests {
       // ... existing tests ...

       #[test]
       fn test_load_missing_file_uses_defaults() {
           let config = Config::load(Some(Path::new("/nonexistent/config.toml")))
               .expect("Should use defaults when file missing");
           assert_eq!(config.max_iterations, 20);
       }

       #[test]
       fn test_env_override() {
           std::env::set_var("RSLPH_MAX_ITERATIONS", "50");
           let config = Config::load(None).expect("Should load");
           assert_eq!(config.max_iterations, 50);
           std::env::remove_var("RSLPH_MAX_ITERATIONS");
       }

       #[test]
       fn test_cli_overrides_highest() {
           std::env::set_var("RSLPH_MAX_ITERATIONS", "50");
           let overrides = PartialConfig {
               max_iterations: Some(100),
               ..Default::default()
           };
           let config = Config::load_with_overrides(None, overrides)
               .expect("Should load");
           assert_eq!(config.max_iterations, 100); // CLI wins over env
           std::env::remove_var("RSLPH_MAX_ITERATIONS");
       }
   }
   ```

4. Run `cargo test` to verify all tests pass.
</how>
<done>
- `Config::default_path()` returns XDG-compliant path
- `Config::load()` works with missing file (uses defaults)
- `Config::load_with_overrides()` correctly applies precedence
- Environment variables RSLPH_* override file values
- CLI overrides (via PartialConfig) have highest precedence
- All tests pass with `cargo test`
</done>
</task>

## Verification

- [ ] `cargo build` completes successfully
- [ ] `cargo test` passes all tests (minimum 4 tests)
- [ ] Config loads from default path (`~/.config/rslph/config.toml` on Linux)
- [ ] Missing config file handled gracefully (no error, uses defaults)
- [ ] Environment variable `RSLPH_MAX_ITERATIONS=50` overrides default
- [ ] PartialConfig overrides are applied with highest precedence

## must_haves

Critical requirements that MUST be true for this plan to be considered complete:

- [ ] **CFG-01**: Config file loads from `~/.config/rslph/config.toml` (or XDG equivalent)
- [ ] **CFG-03**: `claude_path` field exists and defaults to "claude"
- [ ] **CFG-04**: `plan_prompt` and `build_prompt` fields exist (Option<PathBuf>)
- [ ] **CFG-05**: `notify_shell` field exists and defaults to "/bin/sh"
- [ ] **CFG-06**: `max_iterations` field exists and defaults to 20
- [ ] **CFG-07**: `recent_threads` field exists and defaults to 5
- [ ] **CFG-08**: `notify_interval` field exists and defaults to 10
- [ ] Layered precedence: defaults < file < env < CLI overrides
- [ ] Missing config file does not cause error
- [ ] Unknown fields in config file are rejected (deny_unknown_fields)
