# Plan 01-02: CLI Parser

## Frontmatter

```yaml
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/cli.rs
  - src/main.rs
  - src/lib.rs
autonomous: true
estimated_tasks: 3
```

## Context

This plan creates the CLI parsing layer using clap with derive macros. It implements the `plan` and `build` subcommands (CMD-01, CMD-02) and integrates with the config system from Plan 01-01 to achieve correct argument precedence (CFG-02).

**Requirements covered:** CMD-01, CMD-02, CFG-02

**Key insight from research:** Use clap's `value_source()` API to distinguish between default values and explicitly provided values. This enables correct precedence where explicit CLI args override everything, but CLI defaults don't override config file values.

**Dependency on 01-01:** Uses `Config`, `PartialConfig`, and `Config::load_with_overrides()` from the config module.

## Tasks

<task id="1">
<title>Create CLI struct with subcommands</title>
<what>
Define the CLI structure with global flags and plan/build subcommands using clap derive macros.
</what>
<how>
1. Create `src/cli.rs`:
   ```rust
   use clap::{Parser, Subcommand};
   use std::path::PathBuf;

   #[derive(Parser, Debug)]
   #[command(name = "rslph")]
   #[command(about = "Ralph Wiggum Loop - autonomous AI coding agent")]
   #[command(version)]
   pub struct Cli {
       /// Override config file path
       #[arg(short, long, global = true)]
       pub config: Option<PathBuf>,

       /// Override claude command path
       #[arg(long, global = true)]
       pub claude_path: Option<String>,

       /// Maximum iterations (overrides config)
       #[arg(long, global = true)]
       pub max_iterations: Option<u32>,

       #[command(subcommand)]
       pub command: Commands,
   }

   #[derive(Subcommand, Debug)]
   pub enum Commands {
       /// Transform idea/plan into structured progress file (CMD-01)
       Plan {
           /// Path to the plan/idea file or inline text
           plan: String,

           /// Use adaptive mode with clarifying questions
           #[arg(long)]
           adaptive: bool,
       },

       /// Execute tasks iteratively with fresh context (CMD-02)
       Build {
           /// Path to the progress file
           plan: PathBuf,

           /// Run single iteration only
           #[arg(long)]
           once: bool,

           /// Preview without executing
           #[arg(long)]
           dry_run: bool,
       },
   }
   ```

2. Update `src/lib.rs` to include cli module:
   ```rust
   pub mod cli;
   pub mod config;
   pub mod error;
   ```

3. Run `cargo build` to verify CLI struct compiles.
</how>
<done>
- `src/cli.rs` exists with Cli and Commands structs
- Global flags: --config, --claude-path, --max-iterations
- Plan subcommand with plan arg and --adaptive flag
- Build subcommand with plan arg, --once, --dry-run flags
- `cargo build` succeeds
</done>
</task>

<task id="2">
<title>Implement CLI-Config integration with precedence</title>
<what>
Create the integration layer that extracts explicit CLI values (not defaults) and passes them to config loading with correct precedence (CFG-02).
</what>
<how>
1. Add to `src/cli.rs`:
   ```rust
   use clap::parser::ValueSource;
   use crate::config::{Config, PartialConfig};

   impl Cli {
       /// Build PartialConfig from explicitly provided CLI arguments only.
       /// Values that are CLI defaults are NOT included, allowing config file
       /// values to take precedence over CLI defaults.
       pub fn to_overrides(&self, matches: &clap::ArgMatches) -> PartialConfig {
           PartialConfig {
               claude_path: self.extract_if_explicit(matches, "claude_path", &self.claude_path),
               max_iterations: self.extract_if_explicit(matches, "max_iterations", &self.max_iterations),
               ..Default::default()
           }
       }

       fn extract_if_explicit<T: Clone>(&self, matches: &clap::ArgMatches, name: &str, value: &Option<T>) -> Option<T> {
           // Only include if value was explicitly provided by user
           if matches.value_source(name) == Some(ValueSource::CommandLine) {
               value.clone()
           } else {
               None
           }
       }

       /// Load config with CLI overrides applied (main entry point)
       pub fn load_config(&self) -> color_eyre::Result<Config> {
           let matches = Cli::command().get_matches_from(std::env::args_os());
           let overrides = self.to_overrides(&matches);
           Config::load_with_overrides(self.config.as_deref(), overrides)
       }
   }
   ```

2. Add tests in `src/cli.rs`:
   ```rust
   #[cfg(test)]
   mod tests {
       use super::*;

       #[test]
       fn test_parse_plan_command() {
           let cli = Cli::try_parse_from(["rslph", "plan", "my-idea.txt"])
               .expect("Should parse");
           match cli.command {
               Commands::Plan { plan, adaptive } => {
                   assert_eq!(plan, "my-idea.txt");
                   assert!(!adaptive);
               }
               _ => panic!("Expected Plan command"),
           }
       }

       #[test]
       fn test_parse_build_command() {
           let cli = Cli::try_parse_from(["rslph", "build", "progress.md", "--once"])
               .expect("Should parse");
           match cli.command {
               Commands::Build { plan, once, dry_run } => {
                   assert_eq!(plan, PathBuf::from("progress.md"));
                   assert!(once);
                   assert!(!dry_run);
               }
               _ => panic!("Expected Build command"),
           }
       }

       #[test]
       fn test_global_flags() {
           let cli = Cli::try_parse_from([
               "rslph",
               "--max-iterations", "50",
               "--claude-path", "/usr/bin/claude",
               "plan", "idea.txt"
           ]).expect("Should parse");

           assert_eq!(cli.max_iterations, Some(50));
           assert_eq!(cli.claude_path, Some("/usr/bin/claude".to_string()));
       }
   }
   ```

3. Run `cargo test` to verify.
</how>
<done>
- `Cli::to_overrides()` extracts only explicit CLI values
- `Cli::load_config()` combines CLI parsing with config loading
- Precedence correct: explicit CLI > env > file > defaults
- Tests pass for plan and build command parsing
- Tests pass for global flag parsing
</done>
</task>

<task id="3">
<title>Wire CLI to main and add help text</title>
<what>
Update main.rs to use the CLI parser and display help/version. Verify `--help` shows plan/build subcommands (Success Criterion 1).
</what>
<how>
1. Update `src/main.rs`:
   ```rust
   mod cli;
   mod config;
   mod error;

   use clap::Parser;
   use cli::{Cli, Commands};

   fn main() -> color_eyre::Result<()> {
       color_eyre::install()?;

       let cli = Cli::parse();
       let config = cli.load_config()?;

       match cli.command {
           Commands::Plan { plan, adaptive } => {
               println!("Planning: {}", plan);
               println!("Adaptive mode: {}", adaptive);
               println!("Using config: {:?}", config);
               // Actual implementation in Phase 3
               println!("Plan command not yet implemented (Phase 3)");
           }
           Commands::Build { plan, once, dry_run } => {
               println!("Building: {}", plan.display());
               println!("Once mode: {}", once);
               println!("Dry run: {}", dry_run);
               println!("Using config: {:?}", config);
               // Actual implementation in Phase 4
               println!("Build command not yet implemented (Phase 4)");
           }
       }

       Ok(())
   }
   ```

2. Verify help output:
   ```bash
   cargo run -- --help
   # Should show:
   # rslph - Ralph Wiggum Loop - autonomous AI coding agent
   # Usage: rslph [OPTIONS] <COMMAND>
   # Commands:
   #   plan   Transform idea/plan into structured progress file
   #   build  Execute tasks iteratively with fresh context
   # Options:
   #   -c, --config <CONFIG>  Override config file path
   #   ...

   cargo run -- plan --help
   # Should show plan subcommand help

   cargo run -- build --help
   # Should show build subcommand help

   cargo run -- --version
   # Should show version
   ```

3. Test CLI with config integration:
   ```bash
   # Without config file (uses defaults)
   cargo run -- plan "test idea"

   # With explicit override
   cargo run -- --max-iterations 50 plan "test idea"

   # With env var
   RSLPH_MAX_ITERATIONS=30 cargo run -- plan "test idea"
   ```
</how>
<done>
- `rslph --help` shows plan and build subcommands
- `rslph plan --help` shows plan-specific options
- `rslph build --help` shows build-specific options
- `rslph --version` shows version
- Commands print stub messages and config values
- Config is loaded and displayed (proves integration works)
</done>
</task>

## Verification

- [ ] `cargo run -- --help` shows "plan" and "build" subcommands
- [ ] `cargo run -- plan "test"` runs without error and shows config
- [ ] `cargo run -- build progress.md --once` parses correctly
- [ ] `cargo run -- --max-iterations 50 plan "test"` applies override
- [ ] `RSLPH_MAX_ITERATIONS=30 cargo run -- plan "test"` uses env value
- [ ] `cargo run -- --max-iterations 50 plan "test"` with env var shows 50 (CLI wins)
- [ ] All tests pass with `cargo test`

## must_haves

Critical requirements that MUST be true for this plan to be considered complete:

- [ ] **CMD-01**: `rslph plan <plan>` command exists and parses
- [ ] **CMD-02**: `rslph build <plan>` command exists and parses
- [ ] **CFG-02**: CLI arguments override config file values (precedence)
- [ ] `--help` shows both plan and build subcommands (Success Criterion 1)
- [ ] `--version` shows version number
- [ ] Global flags (--config, --claude-path, --max-iterations) work with both subcommands
- [ ] Plan subcommand has --adaptive flag
- [ ] Build subcommand has --once and --dry-run flags
- [ ] CLI integrates with Config loading from 01-01
