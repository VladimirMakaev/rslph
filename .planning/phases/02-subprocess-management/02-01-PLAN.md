---
phase: 02-subprocess-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/subprocess/mod.rs
  - src/subprocess/runner.rs
  - src/subprocess/output.rs
  - src/error.rs
autonomous: true

must_haves:
  truths:
    - "Claude CLI can be spawned as a subprocess with piped I/O"
    - "Output streams line-by-line without buffer deadlock"
    - "Both stdout and stderr are captured concurrently"
  artifacts:
    - path: "src/subprocess/mod.rs"
      provides: "Module exports for subprocess management"
    - path: "src/subprocess/runner.rs"
      provides: "ClaudeRunner struct with spawn and streaming"
      exports: ["ClaudeRunner"]
    - path: "src/subprocess/output.rs"
      provides: "OutputLine enum for stdout/stderr discrimination"
      exports: ["OutputLine"]
  key_links:
    - from: "src/subprocess/runner.rs"
      to: "tokio::process::Command"
      via: "async spawn with piped I/O"
      pattern: "Command::new.*\\.spawn"
    - from: "src/subprocess/runner.rs"
      to: "tokio::select!"
      via: "concurrent stdout/stderr reading"
      pattern: "tokio::select!"
---

<objective>
Implement async subprocess spawning and real-time output streaming for Claude CLI.

Purpose: Core infrastructure for running Claude CLI with captured output, avoiding buffer deadlocks through concurrent stream reading.

Output: `ClaudeRunner` struct that spawns Claude CLI and provides line-by-line output via async iterator pattern.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-subprocess-management/02-RESEARCH.md
@src/config.rs
@src/error.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create subprocess module structure</name>
  <files>
    - Cargo.toml
    - src/lib.rs
    - src/subprocess/mod.rs
    - src/subprocess/runner.rs
    - src/subprocess/output.rs
    - src/error.rs
  </files>
  <action>
1. Add dependencies to Cargo.toml:
   ```toml
   tokio = { version = "1.49", features = ["full"] }
   tokio-util = { version = "0.7", features = ["sync"] }
   nix = { version = "0.29", features = ["signal"] }
   ```
   Note: `tokio --features full` includes rt-multi-thread, io-util, process, sync, signal, time, macros

2. Create `src/subprocess/mod.rs`:
   ```rust
   mod output;
   mod runner;

   pub use output::OutputLine;
   pub use runner::ClaudeRunner;
   ```

3. Create `src/subprocess/output.rs` with OutputLine enum:
   ```rust
   #[derive(Debug, Clone, PartialEq)]
   pub enum OutputLine {
       Stdout(String),
       Stderr(String),
   }
   ```

4. Create `src/subprocess/runner.rs` with struct stub:
   ```rust
   use std::path::Path;
   use tokio::io::{AsyncBufReadExt, BufReader, Lines};
   use tokio::process::{Child, ChildStderr, ChildStdout, Command};
   use std::process::Stdio;

   use super::OutputLine;

   pub struct ClaudeRunner {
       child: Child,
       stdout: Lines<BufReader<ChildStdout>>,
       stderr: Lines<BufReader<ChildStderr>>,
   }
   ```

5. Add `pub mod subprocess;` to src/lib.rs

6. Add subprocess error variants to src/error.rs:
   ```rust
   #[error("Subprocess error: {0}")]
   Subprocess(String),

   #[error("Process timeout after {0} seconds")]
   Timeout(u64),

   #[error("Process cancelled by user")]
   Cancelled,
   ```
  </action>
  <verify>
    - `cargo check` passes with new dependencies
    - `cargo doc --no-deps` shows subprocess module in docs
  </verify>
  <done>
    - Module structure exists at src/subprocess/
    - OutputLine and ClaudeRunner types are exported
    - Error types for subprocess failure modes exist
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ClaudeRunner spawn and streaming</name>
  <files>
    - src/subprocess/runner.rs
  </files>
  <action>
Implement the ClaudeRunner with these methods:

1. `spawn(claude_path: &str, args: &[String], working_dir: &Path) -> io::Result<Self>`:
   - Use `tokio::process::Command::new(claude_path)`
   - Set `.args(args)` for all arguments
   - Set `.current_dir(working_dir)`
   - Set `.stdout(Stdio::piped())` and `.stderr(Stdio::piped())`
   - Set `.stdin(Stdio::null())` - Claude CLI doesn't need stdin
   - CRITICAL: Set `.process_group(0)` to isolate from terminal signals (prevents Ctrl+C killing Claude directly)
   - Set `.kill_on_drop(true)` as safety net
   - Take stdout and stderr handles, wrap in `BufReader::new().lines()`
   - Store child, stdout lines, stderr lines in struct

2. `next_output(&mut self) -> Option<OutputLine>`:
   - Use `tokio::select!` to read from both streams concurrently
   - Check stdout.next_line() and stderr.next_line() simultaneously
   - Return `Some(OutputLine::Stdout(line))` or `Some(OutputLine::Stderr(line))`
   - Return `None` when both streams are exhausted (EOF on both)
   - Note: `Lines::next_line()` IS cancellation-safe (unlike read_line)

3. `id(&self) -> Option<u32>`:
   - Return `self.child.id()` for external process monitoring

4. `wait(&mut self) -> io::Result<ExitStatus>`:
   - Call `self.child.wait().await`

Key patterns from research:
- Use `.lines()` not manual `read_line()` for cancellation safety
- Use `tokio::select!` without `biased` for fair stream handling
- Check for EOF by `Ok(None)` from next_line()

Example select! usage:
```rust
pub async fn next_output(&mut self) -> Option<OutputLine> {
    tokio::select! {
        result = self.stdout.next_line() => {
            match result {
                Ok(Some(line)) => Some(OutputLine::Stdout(line)),
                _ => self.try_stderr().await, // Try other stream
            }
        }
        result = self.stderr.next_line() => {
            match result {
                Ok(Some(line)) => Some(OutputLine::Stderr(line)),
                _ => self.try_stdout().await, // Try other stream
            }
        }
    }
}
```

Handle the case where one stream ends before the other by continuing to read the remaining stream.
  </action>
  <verify>
    - `cargo check` passes
    - `cargo test` passes (existing tests still work)
    - Manual verification: `cargo run -- plan "test"` still works
  </verify>
  <done>
    - ClaudeRunner::spawn() creates subprocess with piped I/O
    - ClaudeRunner::next_output() returns lines from either stream
    - Process is isolated in its own process group
    - kill_on_drop ensures cleanup on panic
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for spawning and streaming</name>
  <files>
    - src/subprocess/runner.rs
  </files>
  <action>
Add tests at the bottom of runner.rs in a `#[cfg(test)]` module:

1. `test_spawn_echo_command`:
   - Spawn `/bin/echo` with args `["hello", "world"]`
   - Collect all output lines
   - Assert we got `OutputLine::Stdout("hello world")`
   - Assert wait() returns success exit status

2. `test_spawn_stderr_output`:
   - Spawn `/bin/sh` with args `["-c", "echo error >&2"]`
   - Collect output
   - Assert we got `OutputLine::Stderr("error")`

3. `test_concurrent_stdout_stderr`:
   - Spawn `/bin/sh` with args `["-c", "echo out; echo err >&2; echo out2"]`
   - Collect all output
   - Assert we received all 3 lines (order may vary due to concurrency)
   - Assert both Stdout and Stderr variants present

4. `test_process_id_available`:
   - Spawn a long-running command like `sleep 1`
   - Assert `runner.id()` returns Some(pid)
   - Wait for completion

5. `test_nonexistent_command_fails`:
   - Try to spawn `/nonexistent/command`
   - Assert spawn() returns Err

All tests need `#[tokio::test]` attribute. Example:
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[tokio::test]
    async fn test_spawn_echo_command() {
        let mut runner = ClaudeRunner::spawn(
            "/bin/echo",
            &["hello".to_string(), "world".to_string()],
            &PathBuf::from("/tmp"),
        ).await.expect("spawn should succeed");

        let mut output = Vec::new();
        while let Some(line) = runner.next_output().await {
            output.push(line);
        }

        assert_eq!(output.len(), 1);
        assert_eq!(output[0], OutputLine::Stdout("hello world".to_string()));

        let status = runner.wait().await.expect("wait should succeed");
        assert!(status.success());
    }
}
```
  </action>
  <verify>
    - `cargo test subprocess` passes all 5 tests
    - `cargo test` passes all tests (including existing)
  </verify>
  <done>
    - spawn() correctly creates subprocess with piped I/O
    - next_output() streams lines from both stdout and stderr
    - Concurrent stream handling works without deadlock
    - Error handling for spawn failures works
  </done>
</task>

</tasks>

<verification>
All phase criteria addressed by this plan:
1. [x] Claude CLI runs as subprocess with piped stdout/stderr - ClaudeRunner::spawn()
2. [x] Output streams line-by-line in real-time - ClaudeRunner::next_output()
3. [ ] Ctrl+C gracefully terminates Claude - Plan 02-02
4. [ ] Stuck Claude invocations timeout - Plan 02-02
5. [x] Process isolation via process_group(0) prevents signal inheritance

Run verification:
```bash
cargo test subprocess
cargo check
```
</verification>

<success_criteria>
- ClaudeRunner struct exists with spawn(), next_output(), id(), wait() methods
- Spawning /bin/echo captures stdout correctly
- Spawning commands with stderr captures stderr correctly
- Concurrent stdout/stderr test passes without deadlock
- All existing tests still pass
- process_group(0) is set on spawned processes
</success_criteria>

<output>
After completion, create `.planning/phases/02-subprocess-management/02-01-SUMMARY.md`
</output>
