---
phase: 02-subprocess-management
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/subprocess/mod.rs
  - src/subprocess/runner.rs
  - src/subprocess/signals.rs
autonomous: true

must_haves:
  truths:
    - "Ctrl+C triggers graceful shutdown with state preservation opportunity"
    - "Stuck Claude invocations timeout after configurable duration"
    - "Terminated processes do not become zombies"
    - "SIGTERM is sent before SIGKILL for graceful termination"
  artifacts:
    - path: "src/subprocess/signals.rs"
      provides: "Signal handling and shutdown coordination"
      exports: ["setup_ctrl_c_handler"]
    - path: "src/subprocess/runner.rs"
      provides: "Termination and timeout methods"
      exports: ["terminate_gracefully", "run_with_timeout"]
  key_links:
    - from: "src/subprocess/signals.rs"
      to: "tokio_util::sync::CancellationToken"
      via: "cancel on Ctrl+C"
      pattern: "CancellationToken.*cancel"
    - from: "src/subprocess/runner.rs"
      to: "tokio::time::timeout"
      via: "wrap execution in timeout"
      pattern: "timeout.*Duration"
    - from: "src/subprocess/runner.rs"
      to: "nix::sys::signal::kill"
      via: "SIGTERM to process group"
      pattern: "kill.*SIGTERM"
---

<objective>
Implement signal handling for graceful Ctrl+C shutdown and timeout management for stuck Claude invocations.

Purpose: Ensure clean process lifecycle management - users can interrupt with Ctrl+C and save state, stuck processes don't hang forever, and no zombie processes accumulate.

Output: Signal handler setup function and ClaudeRunner methods for graceful termination and timeout-wrapped execution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-subprocess-management/02-RESEARCH.md
@.planning/phases/02-subprocess-management/02-01-SUMMARY.md
@src/subprocess/runner.rs
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement signal handling with CancellationToken</name>
  <files>
    - src/subprocess/signals.rs
    - src/subprocess/mod.rs
  </files>
  <action>
1. Create `src/subprocess/signals.rs`:

```rust
use tokio::signal;
use tokio_util::sync::CancellationToken;

/// Set up Ctrl+C handler that cancels the token when signal received.
/// Returns the token for use in execution loops.
///
/// The handler spawns a background task that waits for Ctrl+C.
/// When received, it cancels the token, allowing graceful shutdown.
pub fn setup_ctrl_c_handler() -> CancellationToken {
    let token = CancellationToken::new();
    let token_clone = token.clone();

    tokio::spawn(async move {
        if let Err(e) = signal::ctrl_c().await {
            eprintln!("Failed to listen for Ctrl+C: {}", e);
            return;
        }
        // Signal received - cancel the token
        token_clone.cancel();
    });

    token
}

/// Check if cancellation was requested.
/// Use this for quick checks in loops.
pub fn is_cancelled(token: &CancellationToken) -> bool {
    token.is_cancelled()
}
```

2. Update `src/subprocess/mod.rs` to export signals:
```rust
mod output;
mod runner;
mod signals;

pub use output::OutputLine;
pub use runner::ClaudeRunner;
pub use signals::{setup_ctrl_c_handler, is_cancelled};
```
  </action>
  <verify>
    - `cargo check` passes
    - `cargo doc --no-deps` shows signal functions in docs
  </verify>
  <done>
    - setup_ctrl_c_handler() returns CancellationToken
    - Background task listens for Ctrl+C and cancels token
    - is_cancelled() utility for quick checks
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement graceful termination and timeout handling</name>
  <files>
    - src/subprocess/runner.rs
  </files>
  <action>
Add termination and timeout methods to ClaudeRunner:

1. Add imports at top:
```rust
use std::time::Duration;
use tokio::time::{sleep, timeout};
use tokio_util::sync::CancellationToken;
use crate::error::RslphError;
```

2. Add `terminate_gracefully(&mut self, grace_period: Duration) -> io::Result<()>`:
   - Get child PID via `self.child.id()`
   - If PID exists (process still running):
     - Use `nix::sys::signal::kill()` to send SIGTERM to process GROUP (negative PID)
     - Wait for graceful exit OR grace_period timeout using `tokio::select!`
     - If process exits within grace period, return Ok
   - If still running after grace period, call `self.child.kill().await`
   - Always call wait() to reap the child (prevent zombie)

```rust
pub async fn terminate_gracefully(&mut self, grace_period: Duration) -> std::io::Result<()> {
    #[cfg(unix)]
    if let Some(id) = self.child.id() {
        use nix::sys::signal::{kill, Signal};
        use nix::unistd::Pid;

        // Send SIGTERM to process group (negative PID)
        let _ = kill(Pid::from_raw(-(id as i32)), Signal::SIGTERM);

        // Wait for graceful exit or timeout
        tokio::select! {
            result = self.child.wait() => {
                return result.map(|_| ());
            }
            _ = sleep(grace_period) => {
                // Grace period expired, force kill
            }
        }
    }

    // Force kill if still running
    self.child.kill().await?;
    // Reap to prevent zombie
    let _ = self.child.wait().await;
    Ok(())
}
```

3. Add `kill(&mut self) -> io::Result<()>`:
   - Direct kill without grace period
   - Call `self.child.kill().await`
   - Call wait() to reap

4. Add `run_to_completion(&mut self, cancel_token: CancellationToken) -> Result<Vec<OutputLine>, RslphError>`:
   - Loop calling next_output()
   - Check cancel_token in select! with `biased` (check cancel first)
   - On cancellation, call terminate_gracefully() and return Err(Cancelled)
   - On EOF, return collected output

```rust
pub async fn run_to_completion(
    &mut self,
    cancel_token: CancellationToken,
) -> Result<Vec<OutputLine>, RslphError> {
    let mut output = Vec::new();

    loop {
        tokio::select! {
            biased;

            _ = cancel_token.cancelled() => {
                // User requested cancellation (Ctrl+C)
                self.terminate_gracefully(Duration::from_secs(5)).await
                    .map_err(|e| RslphError::Subprocess(e.to_string()))?;
                return Err(RslphError::Cancelled);
            }

            line = self.next_output() => {
                match line {
                    Some(l) => output.push(l),
                    None => break, // Process finished
                }
            }
        }
    }

    // Reap child to prevent zombie
    let _ = self.child.wait().await;
    Ok(output)
}
```

5. Add `run_with_timeout(&mut self, max_duration: Duration, cancel_token: CancellationToken) -> Result<Vec<OutputLine>, RslphError>`:
   - Wrap run_to_completion in `tokio::time::timeout()`
   - On timeout elapsed, call terminate_gracefully() and return Err(Timeout)

```rust
pub async fn run_with_timeout(
    &mut self,
    max_duration: Duration,
    cancel_token: CancellationToken,
) -> Result<Vec<OutputLine>, RslphError> {
    match timeout(max_duration, self.run_to_completion(cancel_token)).await {
        Ok(result) => result,
        Err(_elapsed) => {
            // Timeout - terminate the process
            self.terminate_gracefully(Duration::from_secs(5)).await
                .map_err(|e| RslphError::Subprocess(e.to_string()))?;
            Err(RslphError::Timeout(max_duration.as_secs()))
        }
    }
}
```

Key implementation notes:
- ALWAYS call wait() after kill to reap child (prevents zombie)
- Use process group (negative PID) for SIGTERM to catch any children Claude may spawn
- Default 5 second grace period for terminate_gracefully
- `biased` in select! ensures cancellation is checked first
  </action>
  <verify>
    - `cargo check` passes
    - `cargo test` passes existing tests
  </verify>
  <done>
    - terminate_gracefully() sends SIGTERM, waits, then SIGKILL
    - kill() immediately terminates and reaps
    - run_to_completion() respects CancellationToken
    - run_with_timeout() wraps execution with configurable timeout
    - All methods reap child process to prevent zombies
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for signal and timeout handling</name>
  <files>
    - src/subprocess/runner.rs
    - src/subprocess/signals.rs
  </files>
  <action>
Add tests to verify signal and timeout behavior:

In `src/subprocess/runner.rs` tests module, add:

1. `test_terminate_gracefully_on_sleeping_process`:
   - Spawn `sleep 60` (long-running process)
   - Call terminate_gracefully() with 1 second grace
   - Assert it completes quickly (within 2 seconds)
   - Assert process is no longer running

2. `test_run_with_timeout_expires`:
   - Spawn `sleep 60`
   - Call run_with_timeout() with Duration::from_millis(100)
   - Assert returns Err(Timeout)
   - Verify process was killed (no zombie)

3. `test_run_with_timeout_completes_before_timeout`:
   - Spawn `/bin/echo test`
   - Call run_with_timeout() with Duration::from_secs(10)
   - Assert returns Ok with output

4. `test_cancellation_token_stops_execution`:
   - Create CancellationToken
   - Spawn `sleep 60`
   - Spawn separate tokio task that cancels token after 100ms
   - Call run_to_completion() with token
   - Assert returns Err(Cancelled)

5. `test_no_zombie_after_termination`:
   - Spawn `/bin/sh -c "sleep 60"`
   - Get PID
   - Call terminate_gracefully()
   - Wait a moment
   - Check that `/proc/{pid}` doesn't exist (Unix only) OR use ps command
   - This verifies wait() was called

Example test:
```rust
#[tokio::test]
async fn test_run_with_timeout_expires() {
    let mut runner = ClaudeRunner::spawn(
        "/bin/sleep",
        &["60".to_string()],
        &PathBuf::from("/tmp"),
    ).await.expect("spawn should succeed");

    let token = CancellationToken::new();
    let result = runner.run_with_timeout(
        Duration::from_millis(100),
        token,
    ).await;

    assert!(matches!(result, Err(RslphError::Timeout(_))));
}

#[tokio::test]
async fn test_cancellation_token_stops_execution() {
    let mut runner = ClaudeRunner::spawn(
        "/bin/sleep",
        &["60".to_string()],
        &PathBuf::from("/tmp"),
    ).await.expect("spawn should succeed");

    let token = CancellationToken::new();
    let token_clone = token.clone();

    // Cancel after 100ms
    tokio::spawn(async move {
        tokio::time::sleep(Duration::from_millis(100)).await;
        token_clone.cancel();
    });

    let result = runner.run_to_completion(token).await;
    assert!(matches!(result, Err(RslphError::Cancelled)));
}
```

In `src/subprocess/signals.rs`, add tests module:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_setup_ctrl_c_handler_returns_token() {
        let token = setup_ctrl_c_handler();
        assert!(!token.is_cancelled());
    }

    #[tokio::test]
    async fn test_is_cancelled_utility() {
        let token = CancellationToken::new();
        assert!(!is_cancelled(&token));
        token.cancel();
        assert!(is_cancelled(&token));
    }
}
```
  </action>
  <verify>
    - `cargo test subprocess` passes all tests
    - `cargo test` passes all tests
    - No zombie processes after running tests: `ps aux | grep defunct | grep -v grep` shows nothing
  </verify>
  <done>
    - Graceful termination stops long-running processes
    - Timeout handling kills stuck processes
    - Cancellation token integration works
    - No zombie processes after termination
    - All subprocess tests pass
  </done>
</task>

</tasks>

<verification>
All phase criteria addressed:
1. [x] Claude CLI runs as subprocess with piped stdout/stderr - Plan 02-01
2. [x] Output streams line-by-line in real-time - Plan 02-01
3. [x] Ctrl+C gracefully terminates Claude - setup_ctrl_c_handler + terminate_gracefully
4. [x] Stuck Claude invocations timeout - run_with_timeout
5. [x] No zombie processes - wait() called in all termination paths

Run verification:
```bash
cargo test subprocess
cargo test
ps aux | grep defunct | grep -v grep  # Should show nothing
```
</verification>

<success_criteria>
- setup_ctrl_c_handler() creates working signal handler
- terminate_gracefully() sends SIGTERM then SIGKILL after grace period
- run_with_timeout() terminates stuck processes
- run_to_completion() respects CancellationToken
- No zombie processes after any termination path
- All tests pass including timeout and cancellation tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-subprocess-management/02-02-SUMMARY.md`
</output>
