---
phase: 03-planning-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prompts/PROMPT_plan.md
  - src/prompts/mod.rs
  - src/prompts/defaults.rs
  - src/prompts/loader.rs
  - src/planning/mod.rs
  - src/planning/stack.rs
  - src/planning/command.rs
  - src/lib.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "User can run `rslph plan 'build a todo app'` and get a progress.md file"
    - "Basic mode produces structured tasks without asking questions"
    - "PROMPT_plan is baked into binary but can be overridden via config"
    - "Project stack is auto-detected for testing strategy"
  artifacts:
    - path: "prompts/PROMPT_plan.md"
      provides: "Default planning prompt"
      min_lines: 30
    - path: "src/prompts/mod.rs"
      provides: "Prompt module exports"
      exports: ["get_plan_prompt"]
    - path: "src/planning/stack.rs"
      provides: "Stack detection logic"
      exports: ["DetectedStack", "detect_stack", "Language"]
    - path: "src/planning/command.rs"
      provides: "Planning command handler"
      exports: ["run_plan_command"]
  key_links:
    - from: "src/main.rs"
      to: "src/planning/command.rs"
      via: "run_plan_command call in Commands::Plan"
      pattern: "run_plan_command"
    - from: "src/planning/command.rs"
      to: "src/prompts/mod.rs"
      via: "get_plan_prompt call"
      pattern: "get_plan_prompt"
    - from: "src/planning/command.rs"
      to: "src/subprocess/runner.rs"
      via: "ClaudeRunner::spawn for Claude CLI execution"
      pattern: "ClaudeRunner::spawn"
---

<objective>
Implement basic planning mode for `rslph plan` command.

Purpose: Enable users to transform ideas into structured progress files by running Claude in headless mode with a baked-in prompt. This is the default mode that does best-effort structuring without asking clarifying questions.

Output:
- `prompts/PROMPT_plan.md` - Default planning prompt (compiled into binary)
- `src/prompts/` - Prompt loading module with config override support
- `src/planning/` - Planning command and stack detection
- Updated `src/main.rs` to execute planning
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-planning-command/03-RESEARCH.md

# Existing codebase (Phase 1-2)
@src/config.rs
@src/progress.rs
@src/subprocess/runner.rs
@src/cli.rs
@src/main.rs
@src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prompt system with baked-in defaults</name>
  <files>
    - prompts/PROMPT_plan.md
    - src/prompts/mod.rs
    - src/prompts/defaults.rs
    - src/prompts/loader.rs
    - src/lib.rs
  </files>
  <action>
Create the prompt system:

1. Create `prompts/PROMPT_plan.md` at the project root with the planning prompt. Include:
   - Role: Planning assistant that transforms ideas into structured task lists
   - Instructions: Analyze requirements, break into tasks, organize by phases
   - Output format: EXACT progress.md format matching ProgressFile struct
   - Guidelines: Tasks should be 1-2 iterations each, use imperative verbs
   - Stack placeholder: `{STACK}` for detected stack info
   - See 03-RESEARCH.md "Example 1: PROMPT_plan.md Structure" for template

2. Create `src/prompts/mod.rs`:
   - Export `get_plan_prompt` function
   - Re-export from submodules

3. Create `src/prompts/defaults.rs`:
   - Use `include_str!("../../prompts/PROMPT_plan.md")` to embed at compile time
   - Provide `default_plan_prompt() -> &'static str`

4. Create `src/prompts/loader.rs`:
   - `get_plan_prompt(config: &Config) -> color_eyre::Result<String>`
   - If `config.plan_prompt` is Some, read from that path
   - Otherwise return the baked-in default
   - Handle file read errors with helpful messages

5. Update `src/lib.rs` to add `pub mod prompts;`
  </action>
  <verify>
    - `cargo build` succeeds
    - `prompts/PROMPT_plan.md` exists and contains progress file format
    - `cargo test` passes (no new tests needed, just compilation)
  </verify>
  <done>
    - `get_plan_prompt(&config)` returns baked-in prompt when no override configured
    - `get_plan_prompt(&config)` returns file contents when `plan_prompt` path is set
    - Prompt includes exact progress.md format that parses with `ProgressFile::parse()`
  </done>
</task>

<task type="auto">
  <name>Task 2: Create stack detection module</name>
  <files>
    - src/planning/mod.rs
    - src/planning/stack.rs
    - src/lib.rs
  </files>
  <action>
Create stack detection for testing strategy:

1. Create `src/planning/mod.rs`:
   - Export `stack` module
   - Re-export key types: `DetectedStack`, `detect_stack`, `Language`

2. Create `src/planning/stack.rs` following 03-RESEARCH.md "Pattern 3" and "Example 2":

   Define types:
   ```rust
   #[derive(Debug, Clone, Default)]
   pub struct DetectedStack {
       pub language: Language,
       pub framework: Option<String>,
       pub test_runner: Option<String>,
       pub type_checker: Option<String>,
       pub linter: Option<String>,
   }

   #[derive(Debug, Clone, Copy, PartialEq, Default)]
   pub enum Language {
       Rust,
       TypeScript,
       JavaScript,
       Python,
       Go,
       #[default]
       Unknown,
   }
   ```

   Implement `DetectedStack::to_summary(&self) -> String` for prompt injection.

   Implement `pub fn detect_stack(project_dir: &Path) -> DetectedStack`:
   - Check `Cargo.toml` -> detect_rust_stack()
   - Check `package.json` -> detect_node_stack() (parse JSON with serde_json)
   - Check `pyproject.toml` or `setup.py` -> detect_python_stack()
   - Check `go.mod` -> detect_go_stack()
   - Return DetectedStack::default() if none match

   For each language detector:
   - Rust: test_runner="cargo test", type_checker="rustc", linter="clippy"
   - Node: Parse package.json devDependencies for jest/vitest/eslint/typescript
   - Python: Check for pytest in pyproject.toml, mypy for type checking
   - Go: test_runner="go test", linter="golangci-lint"

3. Update `src/lib.rs` to add `pub mod planning;`

4. Add unit tests:
   - Test detect_stack with mock project directories (use tempfile)
   - Test to_summary() produces readable output
  </action>
  <verify>
    - `cargo build` succeeds
    - `cargo test planning` passes with stack detection tests
  </verify>
  <done>
    - `detect_stack("/path/to/rust/project")` returns Language::Rust with cargo test
    - `detect_stack("/path/to/node/project")` parses package.json for frameworks
    - `DetectedStack::to_summary()` returns human-readable stack description
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement basic planning command</name>
  <files>
    - src/planning/command.rs
    - src/planning/mod.rs
    - src/main.rs
  </files>
  <action>
Wire up the planning command to execute Claude:

1. Create `src/planning/command.rs`:

   ```rust
   pub async fn run_plan_command(
       input: &str,
       config: &Config,
       working_dir: &Path,
       cancel_token: CancellationToken,
       timeout: Duration,
   ) -> color_eyre::Result<PathBuf>
   ```

   Implementation:
   a. Detect project stack: `let stack = detect_stack(working_dir);`

   b. Get the planning prompt: `let system_prompt = get_plan_prompt(config)?;`

   c. Build user input with stack context:
      ```rust
      let full_input = format!(
          "## Detected Stack\n{}\n\n## User Request\n{}",
          stack.to_summary(),
          input
      );
      ```

   d. Build Claude CLI args for headless mode (see 03-RESEARCH.md "Pattern 2"):
      ```rust
      let args = vec![
          "-p".to_string(),
          "--system-prompt".to_string(),
          system_prompt,
          full_input,
      ];
      ```

   e. Spawn Claude: `ClaudeRunner::spawn(&config.claude_path, &args, working_dir)`

   f. Run with timeout: `runner.run_with_timeout(timeout, cancel_token).await?`

   g. Collect stdout lines into response text

   h. Parse response: `ProgressFile::parse(&response_text)?`

   i. Write to file:
      - Default filename: `progress.md` in working_dir
      - Use `progress_file.write(&output_path)?`

   j. Return the output path

2. Update `src/planning/mod.rs`:
   - Add `pub mod command;`
   - Re-export `run_plan_command`

3. Update `src/main.rs`:
   - Import planning command and tokio runtime
   - Make main function async OR wrap planning in tokio runtime
   - For Commands::Plan branch:
     a. Get working directory: `std::env::current_dir()?`
     b. Create CancellationToken
     c. Set up signal handling (copy pattern from 02-02 research)
     d. Calculate timeout from max_iterations * reasonable_per_iteration (e.g., 10min)
     e. Call `run_plan_command(&plan, &config, &working_dir, token, timeout).await`
     f. Print success message with output path
  </action>
  <verify>
    - `cargo build` succeeds
    - `cargo run -- plan "test idea" 2>&1` shows command executing (may fail if claude not available, but code path is hit)
    - Integration test: Create a mock command instead of real claude to verify flow
  </verify>
  <done>
    - `rslph plan "build a todo app"` executes Claude with system prompt
    - Claude output is parsed into ProgressFile struct
    - `progress.md` is written atomically to current directory
    - Stack detection info is included in the prompt sent to Claude
    - Ctrl+C gracefully terminates Claude subprocess
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   ```bash
   cargo build --release
   cargo clippy -- -D warnings
   cargo test
   ```

2. Integration test (requires Claude CLI):
   ```bash
   cd /tmp && mkdir test-plan && cd test-plan
   cargo init  # Creates a Rust project
   rslph plan "add a simple hello world function"
   cat progress.md  # Should have structured tasks
   ```

3. Config override test:
   ```bash
   echo "Custom prompt" > /tmp/custom_prompt.md
   RSLPH_PLAN_PROMPT=/tmp/custom_prompt.md rslph plan "test"
   # Should use custom prompt (will fail parsing but proves override works)
   ```
</verification>

<success_criteria>
- [ ] `rslph plan "idea"` runs Claude and produces progress.md
- [ ] Default PROMPT_plan.md is compiled into binary
- [ ] Config plan_prompt path overrides baked-in prompt
- [ ] Stack detection identifies Rust/Node/Python/Go projects
- [ ] Stack info included in prompt sent to Claude
- [ ] Ctrl+C terminates Claude gracefully
- [ ] `cargo test` passes
- [ ] `cargo clippy` passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-planning-command/03-01-SUMMARY.md`
</output>
