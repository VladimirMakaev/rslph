---
phase: 03-planning-command
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/planning/vagueness.rs
  - src/planning/personas.rs
  - src/planning/command.rs
  - src/planning/mod.rs
autonomous: true

must_haves:
  truths:
    - "Adaptive mode (`--adaptive`) detects vagueness and asks clarifying questions"
    - "Requirements clarifier persona surfaces ambiguity in adaptive mode"
    - "Testing strategist persona determines verification approach"
    - "Vague inputs trigger multi-turn conversation in adaptive mode"
  artifacts:
    - path: "src/planning/vagueness.rs"
      provides: "Vagueness detection heuristics"
      exports: ["VaguenessScore", "assess_vagueness"]
    - path: "src/planning/personas.rs"
      provides: "Persona prompts for adaptive mode"
      exports: ["REQUIREMENTS_CLARIFIER_PERSONA", "TESTING_STRATEGIST_PERSONA"]
    - path: "src/planning/command.rs"
      provides: "Updated command with adaptive mode"
      exports: ["run_plan_command", "run_adaptive_planning"]
  key_links:
    - from: "src/planning/command.rs"
      to: "src/planning/vagueness.rs"
      via: "assess_vagueness call when adaptive=true"
      pattern: "assess_vagueness"
    - from: "src/planning/command.rs"
      to: "src/planning/personas.rs"
      via: "Persona prompts for multi-turn conversation"
      pattern: "REQUIREMENTS_CLARIFIER|TESTING_STRATEGIST"
---

<objective>
Implement adaptive planning mode for `rslph plan --adaptive`.

Purpose: Adaptive mode detects vague inputs and engages in multi-turn conversation to gather requirements. It uses two personas (requirements clarifier, testing strategist) to produce more thorough plans with explicit testing strategies.

Output:
- `src/planning/vagueness.rs` - Vagueness detection heuristics
- `src/planning/personas.rs` - Multi-turn persona prompts
- Updated `src/planning/command.rs` with adaptive mode branch
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-planning-command/03-RESEARCH.md
@.planning/phases/03-planning-command/03-01-SUMMARY.md

# From 03-01 (dependencies)
@src/planning/command.rs
@src/planning/stack.rs
@src/planning/mod.rs
@src/prompts/loader.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create vagueness detection module</name>
  <files>
    - src/planning/vagueness.rs
    - src/planning/mod.rs
  </files>
  <action>
Create vagueness detection heuristics following 03-RESEARCH.md "Pattern 4":

1. Create `src/planning/vagueness.rs`:

   Define types:
   ```rust
   #[derive(Debug, Clone)]
   pub struct VaguenessScore {
       pub score: f32,           // 0.0 = very specific, 1.0 = very vague
       pub reasons: Vec<String>, // Why it's considered vague
   }
   ```

   Implement `pub fn assess_vagueness(input: &str) -> VaguenessScore`:

   a. Initialize score at 0.0

   b. Word count analysis:
      - < 5 words: +0.4 ("Very short input")
      - 5-15 words: +0.2 ("Short input")
      - > 15 words: no change

   c. Specificity markers (REDUCE vagueness -0.2 if ANY present):
      - Action verbs: "must", "should", "requires", "needs to"
      - Implementation: "using", "with", "implement", "add", "create"
      - Technical: "endpoint", "api", "database", "component", "module", "function", "class"

   d. Vagueness markers (INCREASE vagueness +0.15 each):
      - Indefinite: "something", "somehow", "stuff", "things", "whatever"
      - Uncertain: "maybe", "possibly", "kind of", "sort of", "like a", "basically"

   e. Question handling:
      - Short question (< 10 words with "?"): +0.2 ("Short question")

   f. Clamp final score to 0.0..1.0

   g. Return VaguenessScore with score and reasons

   Add helper:
   ```rust
   impl VaguenessScore {
       pub fn is_vague(&self) -> bool {
           self.score > 0.5  // Threshold for triggering clarification
       }
   }
   ```

2. Update `src/planning/mod.rs`:
   - Add `pub mod vagueness;`
   - Re-export `VaguenessScore`, `assess_vagueness`

3. Add comprehensive tests:
   - Test specific input: "Add a REST API endpoint for user authentication using JWT tokens" -> score < 0.3
   - Test vague input: "make something for stuff" -> score > 0.7
   - Test short input: "todo app" -> score > 0.5
   - Test medium input: "Build a todo app with React and PostgreSQL" -> score < 0.5
  </action>
  <verify>
    - `cargo build` succeeds
    - `cargo test vagueness` passes all test cases
  </verify>
  <done>
    - `assess_vagueness("todo app").is_vague()` returns true
    - `assess_vagueness("Add JWT auth endpoint using jose library").is_vague()` returns false
    - VaguenessScore includes reasons explaining the score
  </done>
</task>

<task type="auto">
  <name>Task 2: Create persona prompts module</name>
  <files>
    - src/planning/personas.rs
    - src/planning/mod.rs
  </files>
  <action>
Create persona prompts for adaptive mode multi-turn conversation:

1. Create `src/planning/personas.rs`:

   Define requirements clarifier persona:
   ```rust
   pub const REQUIREMENTS_CLARIFIER_PERSONA: &str = r#"
   # Requirements Clarifier

   You are a requirements analyst. Your job is to identify ambiguity and gaps in a project description.

   ## Instructions

   Given a project idea and detected stack, identify:
   1. Missing functional requirements (what should it DO?)
   2. Missing non-functional requirements (performance, security, scalability?)
   3. Unclear scope boundaries (what is IN vs OUT of scope?)
   4. Technology decisions needed (which libraries, databases, APIs?)

   ## Output Format

   If the requirements are clear enough, respond with:
   REQUIREMENTS_CLEAR

   If clarification is needed, output numbered questions:
   1. [First question about unclear aspect]
   2. [Second question about unclear aspect]
   ...

   Keep questions focused and actionable. Maximum 5 questions.
   "#;
   ```

   Define testing strategist persona:
   ```rust
   pub const TESTING_STRATEGIST_PERSONA: &str = r#"
   # Testing Strategist

   You are a testing strategy expert. Your job is to define a comprehensive testing approach.

   ## Given Information

   - Project stack (language, framework, test runner)
   - Project requirements
   - Any clarifications gathered

   ## Output Format

   Provide a testing strategy covering these layers:

   ### Unit Testing
   [Approach for unit tests - what to test, patterns to use]

   ### Type Checking
   [Type safety approach - static typing, runtime validation]

   ### Static Analysis
   [Linting rules, code quality checks]

   ### Integration Testing
   [API testing, component integration, database testing]

   ### E2E Testing (if applicable)
   [User flow testing, browser automation]

   Be specific to the detected stack. If the stack uses Jest, mention Jest patterns.
   If it's Rust, mention cargo test and integration test modules.
   "#;
   ```

2. Update `src/planning/mod.rs`:
   - Add `pub mod personas;`
   - Re-export persona constants

No tests needed for static strings - they're compile-time checked.
  </action>
  <verify>
    - `cargo build` succeeds
    - `cargo doc` shows persona constants in documentation
  </verify>
  <done>
    - `REQUIREMENTS_CLARIFIER_PERSONA` is available and contains question-generation instructions
    - `TESTING_STRATEGIST_PERSONA` is available and contains multi-layer testing approach
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement adaptive planning mode</name>
  <files>
    - src/planning/command.rs
    - src/planning/mod.rs
  </files>
  <action>
Extend planning command with adaptive mode branch:

1. Update `src/planning/command.rs`:

   Add helper function for single Claude invocation:
   ```rust
   async fn run_claude_headless(
       claude_path: &str,
       system_prompt: &str,
       user_input: &str,
       working_dir: &Path,
       cancel_token: CancellationToken,
       timeout: Duration,
   ) -> color_eyre::Result<String>
   ```
   - Build args: ["-p", "--system-prompt", system_prompt, user_input]
   - Spawn ClaudeRunner
   - Run with timeout
   - Collect stdout lines and join with newlines
   - Return the response text

   Add adaptive planning function:
   ```rust
   pub async fn run_adaptive_planning(
       input: &str,
       config: &Config,
       working_dir: &Path,
       cancel_token: CancellationToken,
       timeout: Duration,
   ) -> color_eyre::Result<PathBuf>
   ```

   Implementation:
   a. Detect stack: `let stack = detect_stack(working_dir);`

   b. Check vagueness: `let vagueness = assess_vagueness(input);`

   c. Initialize context variables:
      ```rust
      let mut clarifications = String::new();
      ```

   d. If vague, run requirements clarifier:
      ```rust
      if vagueness.is_vague() {
          let clarifier_input = format!(
              "## Project Stack\n{}\n\n## User Idea\n{}",
              stack.to_summary(),
              input
          );
          let questions = run_claude_headless(
              &config.claude_path,
              REQUIREMENTS_CLARIFIER_PERSONA,
              &clarifier_input,
              working_dir,
              cancel_token.clone(),
              timeout,
          ).await?;

          if !questions.contains("REQUIREMENTS_CLEAR") {
              // Print questions and get user input
              println!("\nðŸ“‹ Clarifying Questions:\n");
              println!("{}", questions);
              println!("\nPlease answer the questions above (type your answers, then Enter twice to submit):\n");

              // Read multi-line input from stdin
              clarifications = read_multiline_input()?;
          }
      }
      ```

   e. Run testing strategist:
      ```rust
      let testing_input = format!(
          "## Project Stack\n{}\n\n## Requirements\n{}\n\n## Clarifications\n{}",
          stack.to_summary(),
          input,
          clarifications
      );
      let testing_strategy = run_claude_headless(
          &config.claude_path,
          TESTING_STRATEGIST_PERSONA,
          &testing_input,
          working_dir,
          cancel_token.clone(),
          timeout,
      ).await?;
      ```

   f. Run final planning with all context:
      ```rust
      let plan_prompt = get_plan_prompt(config)?;
      let final_input = format!(
          "## Detected Stack\n{}\n\n## Requirements\n{}\n\n## Clarifications\n{}\n\n## Testing Strategy\n{}",
          stack.to_summary(),
          input,
          clarifications,
          testing_strategy
      );
      // Continue as in basic mode...
      ```

   g. Parse and write progress file (same as basic mode)

   Add helper for reading multi-line input:
   ```rust
   fn read_multiline_input() -> color_eyre::Result<String> {
       use std::io::{self, BufRead};
       let stdin = io::stdin();
       let mut lines = Vec::new();
       let mut empty_count = 0;

       for line in stdin.lock().lines() {
           let line = line?;
           if line.is_empty() {
               empty_count += 1;
               if empty_count >= 2 {
                   break;
               }
           } else {
               empty_count = 0;
           }
           lines.push(line);
       }

       Ok(lines.join("\n"))
   }
   ```

2. Update `run_plan_command` signature and implementation:
   ```rust
   pub async fn run_plan_command(
       input: &str,
       adaptive: bool,  // ADD this parameter
       config: &Config,
       working_dir: &Path,
       cancel_token: CancellationToken,
       timeout: Duration,
   ) -> color_eyre::Result<PathBuf>
   ```

   At the start of the function:
   ```rust
   if adaptive {
       return run_adaptive_planning(input, config, working_dir, cancel_token, timeout).await;
   }
   // ... existing basic mode implementation
   ```

3. Update `src/main.rs` to pass `adaptive` flag:
   ```rust
   Commands::Plan { plan, adaptive } => {
       // ... existing setup ...
       let output_path = run_plan_command(&plan, adaptive, &config, &working_dir, token, timeout).await?;
       // ...
   }
   ```

4. Update `src/planning/mod.rs`:
   - Re-export `run_adaptive_planning` (optional, internal use)
  </action>
  <verify>
    - `cargo build` succeeds
    - `cargo clippy` passes
    - `rslph plan --adaptive "test" 2>&1` shows adaptive mode executing
    - For vague input, clarifying questions are printed
  </verify>
  <done>
    - `rslph plan --adaptive "todo app"` asks clarifying questions before planning
    - `rslph plan --adaptive "Build REST API with JWT auth using Express"` skips questions (specific enough)
    - Testing strategy is generated and included in final progress.md
    - User can answer questions via stdin in adaptive mode
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   ```bash
   cargo build --release
   cargo clippy -- -D warnings
   cargo test
   ```

2. Vagueness detection test:
   ```bash
   cargo test vagueness -- --nocapture
   ```

3. Adaptive mode test (requires Claude CLI):
   ```bash
   # Vague input - should ask questions
   echo -e "yes\nno\n\n" | rslph plan --adaptive "make an app"

   # Specific input - should skip questions
   rslph plan --adaptive "Build a REST API with Express.js using PostgreSQL for a user management system with JWT authentication"
   ```

4. Compare basic vs adaptive:
   ```bash
   rslph plan "todo app"
   mv progress.md progress-basic.md

   echo -e "web app\nlocal storage\n\n" | rslph plan --adaptive "todo app"
   mv progress.md progress-adaptive.md

   diff progress-basic.md progress-adaptive.md
   # Adaptive should have more detailed testing strategy
   ```
</verification>

<success_criteria>
- [ ] `assess_vagueness()` correctly identifies vague vs specific inputs
- [ ] `--adaptive` flag triggers multi-turn conversation for vague inputs
- [ ] Requirements clarifier persona asks relevant questions
- [ ] Testing strategist persona produces stack-specific testing strategy
- [ ] User can provide answers via stdin
- [ ] Final progress.md includes testing strategy from adaptive mode
- [ ] Basic mode (no --adaptive) still works unchanged
- [ ] `cargo test` passes
- [ ] `cargo clippy` passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-planning-command/03-02-SUMMARY.md`
</output>
