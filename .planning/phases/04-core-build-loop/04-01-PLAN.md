---
phase: 04-core-build-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/build/mod.rs
  - src/build/state.rs
  - src/build/command.rs
  - src/build/iteration.rs
  - src/prompts/defaults.rs
  - src/prompts/loader.rs
  - src/prompts/mod.rs
  - prompts/PROMPT_build.md
  - src/lib.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "User can run `rslph build progress.md` and Claude executes on the progress file"
    - "Each iteration spawns a fresh Claude subprocess (no context pollution)"
    - "Progress file is re-read at start of each iteration"
    - "Output from Claude is parsed and used to update progress file"
  artifacts:
    - path: "src/build/mod.rs"
      provides: "Build module root, re-exports"
      exports: ["run_build_command"]
    - path: "src/build/state.rs"
      provides: "BuildState enum and BuildContext struct"
      exports: ["BuildState", "BuildContext", "DoneReason", "IterationResult"]
    - path: "src/build/command.rs"
      provides: "Main build command handler"
      exports: ["run_build_command"]
    - path: "src/build/iteration.rs"
      provides: "Single iteration execution logic"
      exports: ["run_single_iteration"]
    - path: "prompts/PROMPT_build.md"
      provides: "Build agent system prompt"
      min_lines: 30
  key_links:
    - from: "src/main.rs"
      to: "src/build/mod.rs"
      via: "run_build_command call in Commands::Build arm"
      pattern: "run_build_command"
    - from: "src/build/command.rs"
      to: "src/build/iteration.rs"
      via: "run_single_iteration call in main loop"
      pattern: "run_single_iteration"
    - from: "src/build/iteration.rs"
      to: "src/subprocess/runner.rs"
      via: "ClaudeRunner::spawn"
      pattern: "ClaudeRunner::spawn"
    - from: "src/prompts/loader.rs"
      to: "prompts/PROMPT_build.md"
      via: "get_build_prompt function"
      pattern: "get_build_prompt"
---

<objective>
Implement the core build loop infrastructure: state machine, iteration logic, and PROMPT_build.

Purpose: Enable `rslph build progress.md` to execute Claude iterations on a progress file, with fresh context per iteration and proper subprocess management.

Output:
- `src/build/` module with state machine, command handler, and iteration logic
- `prompts/PROMPT_build.md` baked into binary
- Main loop that can run iterations (termination logic in Plan 02)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-build-loop/04-RESEARCH.md

# Existing code to follow patterns from:
@src/planning/command.rs
@src/subprocess/runner.rs
@src/progress.rs
@src/prompts/loader.rs
@src/prompts/defaults.rs
@src/main.rs
@src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PROMPT_build.md and extend prompt system</name>
  <files>
    prompts/PROMPT_build.md
    src/prompts/defaults.rs
    src/prompts/loader.rs
    src/prompts/mod.rs
  </files>
  <action>
Create `prompts/PROMPT_build.md` with build agent instructions:
- Role: autonomous coding agent executing tasks from progress file
- One task per iteration rule
- How to mark tasks complete (`[ ]` -> `[x]`)
- RALPH_DONE placement rules (in Status section, on its own line)
- Output format: complete updated progress file in markdown
- Failure memory: check Recent Attempts section
- When to write RALPH_DONE (all tasks complete)

Extend prompt system following existing pattern in `src/prompts/`:
1. In `defaults.rs`:
   - Add `pub const BUILD_PROMPT: &str = include_str!("../../prompts/PROMPT_build.md");`
   - Add `pub fn default_build_prompt() -> &'static str { BUILD_PROMPT }`
   - Add test for BUILD_PROMPT existence

2. In `loader.rs`:
   - Add `get_build_prompt(config: &Config) -> color_eyre::Result<String>`
   - Follow exact pattern of `get_plan_prompt`: check config.build_prompt path, fall back to default
   - Add tests parallel to plan prompt tests

3. In `mod.rs`:
   - Add `pub use loader::get_build_prompt;`
  </action>
  <verify>
`cargo test prompts` passes (includes new build prompt tests)
`cargo build` compiles with new prompt embedded
  </verify>
  <done>
PROMPT_build.md exists with build agent instructions.
get_build_prompt function loads from config or default.
Tests verify prompt loading works correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create build module with state machine and iteration logic</name>
  <files>
    src/build/mod.rs
    src/build/state.rs
    src/build/command.rs
    src/build/iteration.rs
    src/lib.rs
  </files>
  <action>
Create `src/build/` module following patterns from Phase 4 Research and existing `src/planning/` structure:

1. Create `src/build/state.rs`:
```rust
#[derive(Debug, Clone, PartialEq)]
pub enum BuildState {
    Starting,
    Running { iteration: u32 },
    IterationComplete { iteration: u32, tasks_completed: u32 },
    Done { reason: DoneReason },
    Failed { error: String },
}

#[derive(Debug, Clone, PartialEq)]
pub enum DoneReason {
    AllTasksComplete,
    RalphDoneMarker,
    MaxIterationsReached,
    UserCancelled,
    SingleIterationComplete,
}

pub enum IterationResult {
    Continue { tasks_completed: u32 },
    Done(DoneReason),
}

pub struct BuildContext {
    pub progress_path: PathBuf,
    pub progress: ProgressFile,
    pub config: Config,
    pub cancel_token: CancellationToken,
    pub current_iteration: u32,
    pub max_iterations: u32,
    pub once_mode: bool,
    pub dry_run: bool,
}
```

2. Create `src/build/iteration.rs`:
- `pub async fn run_single_iteration(ctx: &mut BuildContext) -> Result<IterationResult, RslphError>`
- Re-read progress file at start (handles external edits)
- Check for RALPH_DONE or all tasks complete -> return Done
- Build system prompt via get_build_prompt
- Build user input: current progress file + instructions to execute next task
- Spawn fresh ClaudeRunner with args matching planning/command.rs pattern:
  - `--internet`, `-p`, `--verbose`, `--output-format stream-json`, `--system-prompt`, user_input
- Run with timeout (config.max_iterations * 10 minutes would be excessive; use 10 minutes per iteration)
- Parse JSONL response via StreamResponse
- Parse response text as ProgressFile
- Write updated progress file atomically
- Return Continue with count of newly completed tasks

3. Create `src/build/command.rs`:
- `pub async fn run_build_command(progress_path: PathBuf, once: bool, dry_run: bool, config: &Config, cancel_token: CancellationToken) -> color_eyre::Result<()>`
- Load initial ProgressFile
- Create BuildContext
- For now, stub dry_run (Plan 03 implements it)
- Main loop with state machine:
  - Starting -> Running { iteration: 1 }
  - Running -> call run_single_iteration, transition to IterationComplete or Done or Failed
  - IterationComplete -> check once_mode or max_iterations, transition to Running or Done
  - Done -> print completion message, return Ok
  - Failed -> return Err
- Check cancel_token between iterations

4. Create `src/build/mod.rs`:
```rust
mod command;
mod iteration;
mod state;

pub use command::run_build_command;
pub use state::{BuildContext, BuildState, DoneReason, IterationResult};
```

5. Update `src/lib.rs`:
- Add `pub mod build;`

Add unit tests:
- Test BuildState transitions
- Test IterationResult variants
  </action>
  <verify>
`cargo build` succeeds
`cargo test build` passes (state machine tests)
  </verify>
  <done>
src/build/ module exists with state.rs, iteration.rs, command.rs, mod.rs.
BuildState enum models all loop states.
run_single_iteration spawns Claude and updates progress file.
run_build_command orchestrates the main loop.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire build command in main.rs and integration test</name>
  <files>
    src/main.rs
  </files>
  <action>
Update `src/main.rs` to call the real build command:

1. Add import: `use rslph::build::run_build_command;`

2. Replace the placeholder in `Commands::Build` arm:
```rust
Commands::Build { plan, once, dry_run } => {
    // Set up Ctrl+C handling
    let cancel_token = setup_ctrl_c_handler();

    println!("Building: {}", plan.display());
    if once {
        println!("Mode: single iteration (--once)");
    }
    if dry_run {
        println!("Mode: dry run (--dry-run)");
    }

    match run_build_command(plan, once, dry_run, &config, cancel_token).await {
        Ok(()) => {
            println!("Build completed successfully.");
        }
        Err(e) => {
            eprintln!("Build failed: {}", e);
            std::process::exit(1);
        }
    }
}
```

3. Add basic integration test in command.rs (following planning/command.rs pattern):
- Test that build command with echo mock completes
- Test that timeout works
- Test that cancellation works
  </action>
  <verify>
`cargo build` succeeds
`cargo run -- build --help` shows options
`cargo test build::command` passes integration tests
  </verify>
  <done>
`rslph build progress.md` invokes the real build loop.
Integration tests verify subprocess spawning and timeout handling.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build` succeeds with no errors
2. `cargo test` passes all tests (including new build and prompt tests)
3. `cargo clippy` has no warnings
4. `rslph build --help` shows proper help text
5. Build module exists at src/build/ with expected files
</verification>

<success_criteria>
- Build module infrastructure complete (state machine, iteration, command)
- PROMPT_build embedded in binary with config override support
- `rslph build progress.md` executes Claude and updates progress file
- Each iteration uses fresh Claude context (new subprocess)
- Progress file atomically written after each iteration
- Tests cover state transitions and integration scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-build-loop/04-01-SUMMARY.md`
</output>
