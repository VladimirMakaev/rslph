---
phase: 04-core-build-loop
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/build/command.rs
  - src/build/iteration.rs
  - src/progress.rs
autonomous: true

must_haves:
  truths:
    - "Loop stops when RALPH_DONE marker is detected in progress file"
    - "Loop stops when all tasks are marked complete"
    - "Loop stops when max_iterations is reached"
    - "Recent attempts section accumulates failure memory across iterations"
    - "Iteration log is updated after each iteration"
    - "Build resumes correctly from a partially complete progress file"
  artifacts:
    - path: "src/build/command.rs"
      provides: "Completion checking and termination logic"
      contains: "DoneReason::RalphDoneMarker"
    - path: "src/build/iteration.rs"
      provides: "Progress update with attempts and logging"
      contains: "log_iteration"
    - path: "src/progress.rs"
      provides: "Trim recent attempts to configurable depth"
      contains: "trim_attempts"
  key_links:
    - from: "src/build/iteration.rs"
      to: "src/progress.rs"
      via: "progress.is_done(), progress.completed_tasks(), progress.add_attempt()"
      pattern: "is_done|completed_tasks|add_attempt"
    - from: "src/build/command.rs"
      to: "src/build/state.rs"
      via: "DoneReason variants determine completion message"
      pattern: "DoneReason::"
---

<objective>
Implement completion detection and loop termination logic.

Purpose: Ensure the build loop correctly terminates when tasks are complete, RALPH_DONE is detected, or max iterations is reached. Accumulate failure memory in Recent Attempts section.

Output:
- RALPH_DONE detection terminates loop with appropriate message
- Max iterations limit enforced with warning
- Recent attempts accumulated and trimmed to config depth
- Iteration log updated after each iteration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-build-loop/04-RESEARCH.md
@.planning/phases/04-core-build-loop/04-01-SUMMARY.md

# Built in previous plan:
@src/build/mod.rs
@src/build/state.rs
@src/build/command.rs
@src/build/iteration.rs
@src/progress.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance iteration with completion detection and logging</name>
  <files>
    src/build/iteration.rs
    src/progress.rs
  </files>
  <action>
Enhance `run_single_iteration` to properly detect completion and log iterations:

1. At start of iteration, before spawning Claude:
   - Check `progress.is_done()` -> return `IterationResult::Done(DoneReason::RalphDoneMarker)`
   - Check if all tasks complete -> return `IterationResult::Done(DoneReason::AllTasksComplete)`

2. Track iteration timing:
   - Record start time using `std::time::Instant`
   - After Claude completes, calculate duration

3. After parsing Claude's response:
   - Compare old progress tasks with new progress tasks to count newly completed
   - Call `progress.log_iteration(iteration, started, duration, tasks_completed, notes)`
   - The `started` should be formatted timestamp (chrono::Utc::now())
   - The `duration` should be human-readable (e.g., "5m 30s")

4. Add `trim_attempts` function to `src/progress.rs` (add in the `impl ProgressFile` block):
```rust
impl ProgressFile {
    /// Trim recent attempts to max_count (LOOP-09, CFG-07)
    pub fn trim_attempts(&mut self, max_count: usize) {
        while self.recent_attempts.len() > max_count {
            self.recent_attempts.remove(0); // Remove oldest
        }
    }
}
```

5. After updating progress file in iteration.rs:
   - Call `progress.trim_attempts(ctx.config.recent_threads as usize)`
   - Write progress file atomically

6. On iteration failure or Claude error:
   - Add attempt record with error information
   - `progress.add_attempt(iteration, "Execute next task", "Error: {error}", Some("Retry or skip"))`
   - Still write progress file to persist the attempt

7. Add test for `trim_attempts` in the existing `#[cfg(test)] mod tests` block in `src/progress.rs`:
```rust
#[test]
fn test_trim_attempts() {
    let mut progress = ProgressFile::default();
    // Add 5 attempts
    for i in 1..=5 {
        progress.add_attempt(i, "test", "result", None);
    }
    assert_eq!(progress.recent_attempts.len(), 5);

    // Trim to 3
    progress.trim_attempts(3);
    assert_eq!(progress.recent_attempts.len(), 3);

    // Verify oldest were removed (iterations 1 and 2 gone, 3-5 remain)
    assert_eq!(progress.recent_attempts[0].iteration, 3);
    assert_eq!(progress.recent_attempts[2].iteration, 5);
}
```
  </action>
  <verify>
`cargo test progress::tests::test_trim_attempts` passes (test is in src/progress.rs mod tests block)
`cargo test build` passes
  </verify>
  <done>
Iteration checks for completion before spawning Claude.
Each iteration logs timing and task count.
Recent attempts trimmed to configured depth.
trim_attempts test verifies oldest attempts are removed first.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement termination logic in main loop</name>
  <files>
    src/build/command.rs
  </files>
  <action>
Enhance the main loop in `run_build_command` to properly handle all termination conditions:

1. Update the `IterationComplete` state handling:
```rust
BuildState::IterationComplete { iteration, tasks_completed } => {
    // Log to stderr for visibility
    eprintln!("[BUILD] Iteration {} complete: {} task(s) completed", iteration, tasks_completed);

    // Check termination conditions in priority order
    if ctx.once_mode {
        BuildState::Done { reason: DoneReason::SingleIterationComplete }
    } else if iteration >= ctx.max_iterations {
        eprintln!("[BUILD] Max iterations ({}) reached", ctx.max_iterations);
        BuildState::Done { reason: DoneReason::MaxIterationsReached }
    } else {
        // Continue to next iteration
        ctx.current_iteration = iteration + 1;
        BuildState::Running { iteration: iteration + 1 }
    }
}
```

2. Update the `Done` state handling with clear messages:
```rust
BuildState::Done { reason } => {
    match reason {
        DoneReason::AllTasksComplete => {
            println!("Build complete! All tasks finished.");
        }
        DoneReason::RalphDoneMarker => {
            println!("Build complete! RALPH_DONE marker detected.");
        }
        DoneReason::MaxIterationsReached => {
            let remaining = ctx.progress.total_tasks() - ctx.progress.completed_tasks();
            println!("Build stopped: max iterations ({}) reached. {} task(s) remaining.",
                     ctx.max_iterations, remaining);
        }
        DoneReason::UserCancelled => {
            println!("Build cancelled by user. Progress saved.");
        }
        DoneReason::SingleIterationComplete => {
            println!("Single iteration complete (--once mode).");
        }
    }
    return Ok(());
}
```

3. Ensure progress is re-read before each Running state iteration (in case user edited file):
   - This is already in run_single_iteration, but verify it happens

4. Add a final progress file write before termination if needed (to ensure log is saved)

5. Add tests for termination conditions:
   - Test that max_iterations=1 stops after one iteration
   - Test that once_mode stops after one iteration with correct reason
  </action>
  <verify>
`cargo test build` passes
Manual test: create progress.md with 1 task, run `rslph build --max-iterations 1 progress.md`
  </verify>
  <done>
Loop terminates correctly for all DoneReason variants.
Clear user-facing messages for each termination type.
Max iterations enforced with remaining task count shown.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive termination and resume tests</name>
  <files>
    src/build/command.rs
  </files>
  <action>
Add integration tests to verify termination behavior AND resume capability (LOOP-02):

1. Test RALPH_DONE detection:
   - Create progress file with RALPH_DONE in status
   - Run build (with echo mock)
   - Verify it returns immediately without spawning Claude

2. Test all tasks complete detection:
   - Create progress file with all tasks marked `[x]`
   - Run build
   - Verify it returns immediately

3. Test max iterations reached:
   - Create progress file with incomplete tasks
   - Use echo mock that outputs the same progress (no changes)
   - Set max_iterations to 2
   - Verify loop runs exactly 2 times then stops

4. Test cancellation token:
   - Start build with slow mock
   - Cancel after brief delay
   - Verify DoneReason::UserCancelled

5. **Test resume from partially complete progress (LOOP-02)**:
   - Create progress file with:
     - 2 of 4 tasks already marked `[x]` (completed)
     - Iteration log showing 2 previous iterations
     - Some entries in Recent Attempts
   - Run build with max_iterations=1 (using echo mock)
   - Verify:
     - Build does NOT re-execute already completed tasks
     - Iteration counter in log continues from where it left off (iteration 3, not 1)
     - The next incomplete task is targeted
   - This validates the resume capability after interruption

```rust
#[tokio::test]
async fn test_resume_from_partial_progress() {
    let dir = tempfile::TempDir::new().expect("temp dir");

    // Create progress file simulating prior interruption
    // 2 tasks complete, 2 remaining, iteration log shows 2 prior runs
    let progress_content = r#"# Progress: Resume Test

## Status

In Progress

## Analysis

Testing resume capability.

## Tasks

### Phase 1

- [x] Task 1 - already done
- [x] Task 2 - already done
- [ ] Task 3 - next to execute
- [ ] Task 4 - waiting

## Testing Strategy

Test with cargo test.

## Completed This Iteration

## Recent Attempts

| Iteration | What Tried | Result | Next Step |
|-----------|-----------|--------|-----------|
| 1 | Task 1 | Completed | Continue |
| 2 | Task 2 | Completed | Continue |

## Iteration Log

| Iteration | Started | Duration | Tasks Completed | Notes |
|-----------|---------|----------|-----------------|-------|
| 1 | 2024-01-01 10:00 | 2m 30s | 1 | Task 1 |
| 2 | 2024-01-01 10:03 | 3m 15s | 1 | Task 2 |
"#;

    let progress_path = dir.path().join("progress.md");
    std::fs::write(&progress_path, progress_content).expect("write progress");

    // Run build - should resume from iteration 3, target Task 3
    // Mock should output progress with iteration 3 logged
    let config = Config {
        claude_path: "/bin/echo".to_string(),
        max_iterations: 1,
        ..Default::default()
    };

    let token = CancellationToken::new();
    let result = run_build_command(
        progress_path.clone(),
        true,  // once mode to limit execution
        false,
        &config,
        token,
    ).await;

    assert!(result.is_ok());

    // Read the progress file back
    let updated = ProgressFile::read(&progress_path).expect("read back");

    // Verify completed tasks were preserved (still 2 complete)
    assert_eq!(updated.completed_tasks(), 2);

    // Verify iteration count - should be 3 (continuing from 2)
    // (The exact assertion depends on implementation - may check iteration_log length)
}
```

Use the testing patterns from `planning/command.rs`:
- Temp directories for progress files
- Echo or sleep scripts as Claude mocks
- CancellationToken for cancellation tests
  </action>
  <verify>
`cargo test build::command::tests` passes all termination and resume tests
`cargo test build::command::tests::test_resume_from_partial_progress` specifically passes
  </verify>
  <done>
Tests verify RALPH_DONE stops loop immediately.
Tests verify all-tasks-complete stops loop.
Tests verify max iterations enforced.
Tests verify cancellation works.
Tests verify resume from partial progress works (LOOP-02).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo test` passes all tests
2. `cargo clippy` has no warnings
3. Manual test: `rslph build progress.md` with RALPH_DONE status exits immediately
4. Manual test: `rslph build --max-iterations 1 progress.md` runs exactly 1 iteration
</verification>

<success_criteria>
- RALPH_DONE in Status section terminates loop immediately
- All tasks complete terminates loop immediately
- Max iterations limit enforced with clear message
- Recent attempts trimmed to config.recent_threads depth
- Iteration log updated with timing after each iteration
- Cancellation handled gracefully with progress saved
- Resume from partial progress works correctly (LOOP-02)
- All termination paths tested including resume capability
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-build-loop/04-02-SUMMARY.md`
</output>
