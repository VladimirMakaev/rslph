---
phase: 04-core-build-loop
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/build/command.rs
  - src/build/iteration.rs
  - src/progress.rs
autonomous: true

must_haves:
  truths:
    - "Loop stops when RALPH_DONE marker is detected in progress file"
    - "Loop stops when all tasks are marked complete"
    - "Loop stops when max_iterations is reached"
    - "Recent attempts section accumulates failure memory across iterations"
    - "Iteration log is updated after each iteration"
  artifacts:
    - path: "src/build/command.rs"
      provides: "Completion checking and termination logic"
      contains: "DoneReason::RalphDoneMarker"
    - path: "src/build/iteration.rs"
      provides: "Progress update with attempts and logging"
      contains: "log_iteration"
    - path: "src/progress.rs"
      provides: "Trim recent attempts to configurable depth"
      contains: "trim_attempts"
  key_links:
    - from: "src/build/iteration.rs"
      to: "src/progress.rs"
      via: "progress.is_done(), progress.completed_tasks(), progress.add_attempt()"
      pattern: "is_done|completed_tasks|add_attempt"
    - from: "src/build/command.rs"
      to: "src/build/state.rs"
      via: "DoneReason variants determine completion message"
      pattern: "DoneReason::"
---

<objective>
Implement completion detection and loop termination logic.

Purpose: Ensure the build loop correctly terminates when tasks are complete, RALPH_DONE is detected, or max iterations is reached. Accumulate failure memory in Recent Attempts section.

Output:
- RALPH_DONE detection terminates loop with appropriate message
- Max iterations limit enforced with warning
- Recent attempts accumulated and trimmed to config depth
- Iteration log updated after each iteration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-build-loop/04-RESEARCH.md
@.planning/phases/04-core-build-loop/04-01-SUMMARY.md

# Built in previous plan:
@src/build/mod.rs
@src/build/state.rs
@src/build/command.rs
@src/build/iteration.rs
@src/progress.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance iteration with completion detection and logging</name>
  <files>
    src/build/iteration.rs
    src/progress.rs
  </files>
  <action>
Enhance `run_single_iteration` to properly detect completion and log iterations:

1. At start of iteration, before spawning Claude:
   - Check `progress.is_done()` -> return `IterationResult::Done(DoneReason::RalphDoneMarker)`
   - Check if all tasks complete -> return `IterationResult::Done(DoneReason::AllTasksComplete)`

2. Track iteration timing:
   - Record start time using `std::time::Instant`
   - After Claude completes, calculate duration

3. After parsing Claude's response:
   - Compare old progress tasks with new progress tasks to count newly completed
   - Call `progress.log_iteration(iteration, started, duration, tasks_completed, notes)`
   - The `started` should be formatted timestamp (chrono::Utc::now())
   - The `duration` should be human-readable (e.g., "5m 30s")

4. Add `trim_attempts` function to `src/progress.rs`:
```rust
impl ProgressFile {
    /// Trim recent attempts to max_count (LOOP-09, CFG-07)
    pub fn trim_attempts(&mut self, max_count: usize) {
        while self.recent_attempts.len() > max_count {
            self.recent_attempts.remove(0); // Remove oldest
        }
    }
}
```

5. After updating progress file in iteration.rs:
   - Call `progress.trim_attempts(ctx.config.recent_threads as usize)`
   - Write progress file atomically

6. On iteration failure or Claude error:
   - Add attempt record with error information
   - `progress.add_attempt(iteration, "Execute next task", "Error: {error}", Some("Retry or skip"))`
   - Still write progress file to persist the attempt

Add test for `trim_attempts` in progress.rs.
  </action>
  <verify>
`cargo test progress::tests::test_trim_attempts` passes
`cargo test build` passes
  </verify>
  <done>
Iteration checks for completion before spawning Claude.
Each iteration logs timing and task count.
Recent attempts trimmed to configured depth.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement termination logic in main loop</name>
  <files>
    src/build/command.rs
  </files>
  <action>
Enhance the main loop in `run_build_command` to properly handle all termination conditions:

1. Update the `IterationComplete` state handling:
```rust
BuildState::IterationComplete { iteration, tasks_completed } => {
    // Log to stderr for visibility
    eprintln!("[BUILD] Iteration {} complete: {} task(s) completed", iteration, tasks_completed);

    // Check termination conditions in priority order
    if ctx.once_mode {
        BuildState::Done { reason: DoneReason::SingleIterationComplete }
    } else if iteration >= ctx.max_iterations {
        eprintln!("[BUILD] Max iterations ({}) reached", ctx.max_iterations);
        BuildState::Done { reason: DoneReason::MaxIterationsReached }
    } else {
        // Continue to next iteration
        ctx.current_iteration = iteration + 1;
        BuildState::Running { iteration: iteration + 1 }
    }
}
```

2. Update the `Done` state handling with clear messages:
```rust
BuildState::Done { reason } => {
    match reason {
        DoneReason::AllTasksComplete => {
            println!("Build complete! All tasks finished.");
        }
        DoneReason::RalphDoneMarker => {
            println!("Build complete! RALPH_DONE marker detected.");
        }
        DoneReason::MaxIterationsReached => {
            let remaining = ctx.progress.total_tasks() - ctx.progress.completed_tasks();
            println!("Build stopped: max iterations ({}) reached. {} task(s) remaining.",
                     ctx.max_iterations, remaining);
        }
        DoneReason::UserCancelled => {
            println!("Build cancelled by user. Progress saved.");
        }
        DoneReason::SingleIterationComplete => {
            println!("Single iteration complete (--once mode).");
        }
    }
    return Ok(());
}
```

3. Ensure progress is re-read before each Running state iteration (in case user edited file):
   - This is already in run_single_iteration, but verify it happens

4. Add a final progress file write before termination if needed (to ensure log is saved)

5. Add tests for termination conditions:
   - Test that max_iterations=1 stops after one iteration
   - Test that once_mode stops after one iteration with correct reason
  </action>
  <verify>
`cargo test build` passes
Manual test: create progress.md with 1 task, run `rslph build --max-iterations 1 progress.md`
  </verify>
  <done>
Loop terminates correctly for all DoneReason variants.
Clear user-facing messages for each termination type.
Max iterations enforced with remaining task count shown.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive termination tests</name>
  <files>
    src/build/command.rs
  </files>
  <action>
Add integration tests to verify termination behavior:

1. Test RALPH_DONE detection:
   - Create progress file with RALPH_DONE in status
   - Run build (with echo mock)
   - Verify it returns immediately without spawning Claude

2. Test all tasks complete detection:
   - Create progress file with all tasks marked `[x]`
   - Run build
   - Verify it returns immediately

3. Test max iterations reached:
   - Create progress file with incomplete tasks
   - Use echo mock that outputs the same progress (no changes)
   - Set max_iterations to 2
   - Verify loop runs exactly 2 times then stops

4. Test cancellation token:
   - Start build with slow mock
   - Cancel after brief delay
   - Verify DoneReason::UserCancelled

Use the testing patterns from `planning/command.rs`:
- Temp directories for progress files
- Echo or sleep scripts as Claude mocks
- CancellationToken for cancellation tests
  </action>
  <verify>
`cargo test build::command` passes all termination tests
  </verify>
  <done>
Tests verify RALPH_DONE stops loop immediately.
Tests verify all-tasks-complete stops loop.
Tests verify max iterations enforced.
Tests verify cancellation works.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo test` passes all tests
2. `cargo clippy` has no warnings
3. Manual test: `rslph build progress.md` with RALPH_DONE status exits immediately
4. Manual test: `rslph build --max-iterations 1 progress.md` runs exactly 1 iteration
</verification>

<success_criteria>
- RALPH_DONE in Status section terminates loop immediately
- All tasks complete terminates loop immediately
- Max iterations limit enforced with clear message
- Recent attempts trimmed to config.recent_threads depth
- Iteration log updated with timing after each iteration
- Cancellation handled gracefully with progress saved
- All termination paths tested
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-build-loop/04-02-SUMMARY.md`
</output>
