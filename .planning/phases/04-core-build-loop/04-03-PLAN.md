---
phase: 04-core-build-loop
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/build/command.rs
  - src/build/mod.rs
autonomous: true

must_haves:
  truths:
    - "User can run `rslph build --dry-run progress.md` to preview without executing Claude"
    - "User can run `rslph build --once progress.md` to execute exactly one iteration"
    - "Dry-run shows progress file status, task counts, next task, and prompt info"
    - "Single iteration mode stops after one iteration regardless of task status"
  artifacts:
    - path: "src/build/command.rs"
      provides: "Dry-run and single iteration mode implementations"
      contains: ["run_dry_run", "once_mode"]
  key_links:
    - from: "src/build/command.rs"
      to: "src/progress.rs"
      via: "ProgressFile::next_task() for showing what would execute"
      pattern: "next_task"
---

<objective>
Implement `--dry-run` and `--once` modes for the build command.

Purpose: Enable users to preview what the build would do without executing (dry-run), and to run a single iteration for step-by-step control (once mode).

Output:
- `--dry-run` shows comprehensive preview without spawning Claude
- `--once` executes exactly one iteration then stops
- Both modes work correctly with existing loop infrastructure
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-build-loop/04-RESEARCH.md
@.planning/phases/04-core-build-loop/04-01-SUMMARY.md

# Built in previous plan:
@src/build/mod.rs
@src/build/state.rs
@src/build/command.rs
@src/progress.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement dry-run mode</name>
  <files>
    src/build/command.rs
  </files>
  <action>
Add `run_dry_run` function and integrate it into `run_build_command`:

1. Add the dry-run function following the pattern from research:
```rust
/// Preview what the build would do without executing (LOOP-07)
fn run_dry_run(ctx: &BuildContext) -> color_eyre::Result<()> {
    use crate::prompts::get_build_prompt;

    println!("=== DRY RUN MODE ===\n");

    // Progress file info
    println!("Progress file: {}", ctx.progress_path.display());
    println!("Project: {}", ctx.progress.name);
    println!();

    // Current status
    println!("Status: {}", ctx.progress.status);
    if ctx.progress.is_done() {
        println!("  -> RALPH_DONE detected, build would exit immediately");
    }
    println!();

    // Task summary
    let total = ctx.progress.total_tasks();
    let completed = ctx.progress.completed_tasks();
    let remaining = total - completed;
    println!("Tasks: {}/{} complete ({} remaining)", completed, total, remaining);

    if remaining == 0 {
        println!("  -> All tasks complete, build would exit immediately");
    }
    println!();

    // Next task to execute
    if let Some((phase, task)) = ctx.progress.next_task() {
        println!("Next task to execute:");
        println!("  Phase: {}", phase);
        println!("  Task:  {}", task.description);
    } else {
        println!("No pending tasks found.");
    }
    println!();

    // Configuration
    println!("Configuration:");
    println!("  Max iterations: {}", ctx.max_iterations);
    println!("  Once mode: {}", ctx.once_mode);
    println!("  Recent attempts depth: {}", ctx.config.recent_threads);
    println!();

    // Prompt info
    let prompt_source = if ctx.config.build_prompt.is_some() {
        format!("custom ({})", ctx.config.build_prompt.as_ref().unwrap().display())
    } else {
        "default (embedded)".to_string()
    };
    println!("Build prompt: {}", prompt_source);

    // Validate prompt is loadable
    match get_build_prompt(&ctx.config) {
        Ok(prompt) => println!("  Prompt length: {} chars", prompt.len()),
        Err(e) => println!("  WARNING: Failed to load prompt: {}", e),
    }
    println!();

    // Recent attempts summary
    if !ctx.progress.recent_attempts.is_empty() {
        println!("Recent attempts ({}):", ctx.progress.recent_attempts.len());
        for attempt in ctx.progress.recent_attempts.iter().rev().take(3) {
            println!("  Iteration {}: {} -> {}", attempt.iteration, attempt.tried, attempt.result);
        }
    }

    println!("\n=== END DRY RUN ===");
    println!("\nTo execute, run without --dry-run flag.");

    Ok(())
}
```

2. In `run_build_command`, call dry-run early if flag is set:
```rust
// Handle dry-run mode early
if dry_run {
    return run_dry_run(&ctx);
}
```

3. Add tests for dry-run:
   - Test that dry-run does not modify progress file
   - Test that dry-run shows correct task counts
   - Test that dry-run exits with Ok
  </action>
  <verify>
`cargo test build::command::tests::test_dry_run` passes
`cargo run -- build --dry-run progress.md` shows preview (with sample progress.md)
  </verify>
  <done>
--dry-run shows comprehensive preview.
No Claude subprocess spawned in dry-run.
Progress file not modified in dry-run.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify and test once mode</name>
  <files>
    src/build/command.rs
  </files>
  <action>
The once mode logic should already be implemented in Plan 02 via `ctx.once_mode` check in IterationComplete state. This task verifies and adds tests.

1. Verify once_mode is properly checked in the state machine:
   - In IterationComplete handling, once_mode should trigger `DoneReason::SingleIterationComplete`
   - This should have been added in Plan 02, verify it exists

2. Add comprehensive tests for once mode:
```rust
#[tokio::test]
async fn test_once_mode_stops_after_one_iteration() {
    let dir = tempfile::TempDir::new().expect("temp dir");

    // Create progress file with multiple incomplete tasks
    let progress_content = r#"# Progress: Test

## Status

In Progress

## Analysis

Test analysis.

## Tasks

### Phase 1

- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

## Testing Strategy

Test with cargo test.

## Completed This Iteration

## Recent Attempts

## Iteration Log

| Iteration | Started | Duration | Tasks Completed | Notes |
|-----------|---------|----------|-----------------|-------|
"#;

    let progress_path = dir.path().join("progress.md");
    std::fs::write(&progress_path, progress_content).expect("write progress");

    // Use echo mock that outputs the progress unchanged
    let config = Config {
        claude_path: "/bin/echo".to_string(),
        ..Default::default()
    };

    let token = CancellationToken::new();

    // Run with once=true
    let result = run_build_command(
        progress_path.clone(),
        true,  // once mode
        false, // not dry-run
        &config,
        token,
    ).await;

    assert!(result.is_ok());
    // Verify only ran once (iteration log would have 1 entry or echo output behavior)
}

#[tokio::test]
async fn test_once_mode_with_dry_run_shows_once() {
    // Test that dry-run shows once_mode: true when flag is set
    let dir = tempfile::TempDir::new().expect("temp dir");

    let progress = ProgressFile {
        name: "Test".to_string(),
        status: "In Progress".to_string(),
        tasks: vec![TaskPhase {
            name: "Phase 1".to_string(),
            tasks: vec![Task {
                description: "Task 1".to_string(),
                completed: false,
            }],
        }],
        ..Default::default()
    };

    let progress_path = dir.path().join("progress.md");
    progress.write(&progress_path).expect("write");

    let config = Config::default();
    let token = CancellationToken::new();

    // This just tests that the function runs without error
    // In reality we'd capture stdout to verify output
    let ctx = BuildContext {
        progress_path,
        progress,
        config: config.clone(),
        cancel_token: token,
        current_iteration: 0,
        max_iterations: config.max_iterations,
        once_mode: true,
        dry_run: true,
    };

    let result = run_dry_run(&ctx);
    assert!(result.is_ok());
}
```

3. If once_mode logic is missing from Plan 02, add it now:
   - Check `ctx.once_mode` in IterationComplete state
   - Return `DoneReason::SingleIterationComplete` if true
  </action>
  <verify>
`cargo test build::command::tests::test_once_mode` passes
`cargo run -- build --once progress.md` runs exactly one iteration (with real claude or mock)
  </verify>
  <done>
--once mode executes exactly one iteration.
--once with --dry-run shows once_mode: true.
Tests verify once mode behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Final cleanup and clippy</name>
  <files>
    src/build/mod.rs
    src/build/command.rs
    src/build/iteration.rs
    src/build/state.rs
  </files>
  <action>
Run final cleanup on the build module:

1. Run `cargo clippy` and fix any warnings in src/build/

2. Ensure all public items have doc comments:
   - `run_build_command` - main entry point docs
   - `run_dry_run` - dry-run mode docs
   - `BuildState` - state machine docs
   - `DoneReason` - termination reason docs
   - `IterationResult` - iteration outcome docs
   - `BuildContext` - context struct docs

3. Remove any `#[allow(dead_code)]` that's no longer needed

4. Ensure error handling is consistent:
   - Use `?` operator where appropriate
   - Use `color_eyre::Result` for public functions
   - Use `RslphError` for internal errors

5. Run full test suite: `cargo test`

6. Verify binary works:
   - `cargo run -- build --help`
   - `cargo run -- build --dry-run progress.md` (if progress.md exists)
  </action>
  <verify>
`cargo clippy -- -D warnings` passes (no warnings)
`cargo test` passes
`cargo run -- build --help` shows proper help
  </verify>
  <done>
All clippy warnings resolved.
All public items documented.
Build module ready for production use.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build` succeeds
2. `cargo test` passes all tests
3. `cargo clippy -- -D warnings` passes with no warnings
4. `rslph build --help` shows --once and --dry-run options
5. `rslph build --dry-run progress.md` shows preview
6. `rslph build --once progress.md` runs exactly one iteration
</verification>

<success_criteria>
- `--dry-run` shows comprehensive preview without executing
- `--once` runs exactly one iteration then stops
- Both modes have clear user-facing output
- All code has doc comments
- No clippy warnings
- Full test coverage for both modes
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-build-loop/04-03-SUMMARY.md`
</output>
