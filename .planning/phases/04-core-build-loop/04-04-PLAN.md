---
phase: 04-core-build-loop
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.rs
  - src/build/iteration.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Build command spawns Claude subprocess when claude is in PATH"
    - "User sees actionable error if claude cannot be found"
  artifacts:
    - path: "src/config.rs"
      provides: "resolve_command_path function using which fallback"
      contains: "resolve_command_path"
    - path: "src/build/iteration.rs"
      provides: "Enhanced spawn error with PATH diagnostic"
      pattern: "PATH"
  key_links:
    - from: "src/config.rs"
      to: "Config::load"
      via: "resolve_command_path called after loading"
      pattern: "resolve_command_path"
---

<objective>
Fix Claude subprocess spawn failure when claude is in shell PATH but not resolvable by Command::new()

Purpose: Close UAT gap where "Failed to spawn claude: No such file or directory" occurs despite claude being in user's PATH. The root cause is that relative command names ("claude") may not resolve in subprocess environments that differ from interactive shells.

Output: Config resolves relative claude_path to absolute path at load time; spawn errors include PATH diagnostic for troubleshooting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/claude-spawn-not-found.md
@src/config.rs
@src/build/iteration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add resolve_command_path function and apply to claude_path</name>
  <files>src/config.rs</files>
  <action>
Add a `resolve_command_path` function that:
1. If path is already absolute (starts with /), return as-is
2. Otherwise, try to resolve via `which` command
3. If which succeeds (exit code 0, non-empty stdout), use the resolved absolute path
4. If which fails, keep the original relative path (for backward compatibility)

Apply this function to `claude_path` in both `Config::load()` and `Config::load_with_overrides()` AFTER all figment merging is complete, but before returning the Config.

```rust
/// Resolve a command name to absolute path using `which`.
/// Returns original path if resolution fails (graceful fallback).
fn resolve_command_path(command: &str) -> String {
    use std::path::Path;
    use std::process::Command;

    // Already absolute - no resolution needed
    if Path::new(command).is_absolute() {
        return command.to_string();
    }

    // Try which to find absolute path
    Command::new("which")
        .arg(command)
        .output()
        .ok()
        .filter(|o| o.status.success())
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .unwrap_or_else(|| command.to_string())
}
```

After loading config via figment, call:
```rust
config.claude_path = resolve_command_path(&config.claude_path);
```

Add a test that verifies resolve_command_path works:
- `resolve_command_path("/bin/echo")` returns "/bin/echo" (absolute unchanged)
- `resolve_command_path("echo")` returns an absolute path ending in "echo"
- `resolve_command_path("nonexistent_command_xyz")` returns "nonexistent_command_xyz" (fallback)
  </action>
  <verify>
`cargo test --lib config::tests` passes with new tests.
`cargo clippy` has no warnings.
  </verify>
  <done>
resolve_command_path function exists and is applied to claude_path during config loading. Relative "claude" is resolved to absolute path when available.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance spawn error message with PATH diagnostic</name>
  <files>src/build/iteration.rs</files>
  <action>
In `run_single_iteration`, enhance the ClaudeRunner::spawn error handling to include:
1. The command path that failed
2. The current PATH environment variable (or "(not set)" if missing)
3. A hint to set claude_path to absolute path

Find the spawn error handling (approximately line 100) and change from:
```rust
Err(e) => return Err(RslphError::Subprocess(format!("Failed to spawn claude: {}", e))),
```

To:
```rust
Err(e) => {
    let path_env = std::env::var("PATH").unwrap_or_else(|_| "(not set)".to_string());
    return Err(RslphError::Subprocess(format!(
        "Failed to spawn '{}': {}. Ensure claude is in PATH or set claude_path to absolute path in config. PATH: {}",
        ctx.config.claude_path, e, path_env
    )));
}
```

Note: With Task 1's which resolution, this error should now be rare (only fires when which also fails), but the diagnostic helps users troubleshoot when it does occur.
  </action>
  <verify>
`cargo build` succeeds.
`cargo test` passes (existing tests still work).
`cargo clippy` has no warnings.
  </verify>
  <done>
Spawn error message includes the attempted command path, the PATH environment, and actionable guidance to use absolute path.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` - all tests pass
2. `cargo clippy` - no warnings
3. Run `cargo run -- build --dry-run progress.md` - should work if claude is in PATH
4. Intentionally set RSLPH_CLAUDE_PATH to a nonexistent command and run build - error message should show PATH and guidance
</verification>

<success_criteria>
- Config loading resolves "claude" to absolute path via which when available
- Spawn failures produce actionable error messages with PATH context
- All existing tests continue to pass
- UAT tests 5, 6, 7 now pass (build spawns claude successfully)
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-build-loop/04-04-SUMMARY.md`
</output>
