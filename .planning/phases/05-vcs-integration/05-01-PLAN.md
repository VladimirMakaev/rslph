---
phase: 05-vcs-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/vcs/mod.rs
  - src/vcs/git.rs
  - src/vcs/sapling.rs
  - src/error.rs
  - src/lib.rs
  - src/build/state.rs
  - src/build/iteration.rs
autonomous: true

must_haves:
  truths:
    - "After iteration completes with file changes, a VCS commit is created"
    - "Commit message includes project name and iteration number"
    - "VCS type is auto-detected without user configuration"
    - "Git and Sapling produce identical commit behavior"
    - "VCS errors warn but do not fail the build"
  artifacts:
    - path: "src/vcs/mod.rs"
      provides: "Vcs trait, VcsType enum, detect_vcs(), create_vcs()"
      exports: ["Vcs", "VcsType", "VcsDetection", "detect_vcs", "create_vcs"]
    - path: "src/vcs/git.rs"
      provides: "GitVcs implementation"
      exports: ["GitVcs"]
    - path: "src/vcs/sapling.rs"
      provides: "SaplingVcs implementation"
      exports: ["SaplingVcs"]
    - path: "src/error.rs"
      provides: "VcsError variants"
      contains: "VcsError"
  key_links:
    - from: "src/build/state.rs"
      to: "src/vcs/mod.rs"
      via: "BuildContext.vcs: Option<Box<dyn Vcs>>"
      pattern: "Option<Box<dyn Vcs>>"
    - from: "src/build/iteration.rs"
      to: "src/vcs/mod.rs"
      via: "commit after iteration"
      pattern: "vcs\\.commit_all"
    - from: "src/vcs/mod.rs"
      to: "sl root / .git detection"
      via: "detect_vcs function"
      pattern: "Command::new\\(\"sl\"\\)|Command::new\\(\"git\"\\)"
---

<objective>
Implement VCS auto-commit integration for rollback safety (VCS-01, VCS-02, VCS-03).

Purpose: After each iteration that completes with file changes, automatically create a VCS commit enabling users to roll back to any iteration via standard git/sl commands.

Output:
- VCS module with trait abstraction for Git and Sapling
- Auto-detection of VCS type (Sapling-first, Git-fallback)
- Build loop integration to commit after each iteration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-vcs-integration/05-RESEARCH.md

# Existing codebase patterns
@src/error.rs
@src/lib.rs
@src/build/state.rs
@src/build/iteration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VCS module with trait, detection, and error types</name>
  <files>
    src/vcs/mod.rs
    src/vcs/git.rs
    src/vcs/sapling.rs
    src/error.rs
    src/lib.rs
  </files>
  <action>
Create new `src/vcs/` module directory with:

**src/vcs/mod.rs:**
- `VcsType` enum: `Git`, `Sapling` (derive Debug, Clone, Copy, PartialEq, Eq, Display)
- `VcsDetection` struct: `vcs_type: VcsType`, `root: PathBuf`
- `Vcs` trait with methods:
  - `fn vcs_type(&self) -> VcsType`
  - `fn has_changes(&self) -> Result<bool, VcsError>`
  - `fn stage_all(&self) -> Result<(), VcsError>`
  - `fn commit(&self, message: &str) -> Result<String, VcsError>` (returns commit hash)
  - Default method `fn commit_all(&self, message: &str) -> Result<Option<String>, VcsError>` that checks has_changes, stages, commits
- `detect_vcs(start_path: &Path) -> Result<Option<VcsDetection>, VcsError>`:
  - If start_path is file, use parent directory
  - Canonicalize path
  - First try `sl root` command - if success, return Sapling with root from stdout
  - Otherwise walk up directories looking for `.git` directory
  - If found and `git --version` works, return Git with that directory as root
  - Return None if no VCS found (not an error)
- `create_vcs(working_dir: &Path) -> Option<Box<dyn Vcs>>`:
  - Call detect_vcs, return appropriate implementation or None

**src/vcs/git.rs:**
- `GitVcs` struct with `root: PathBuf`
- Helper `fn run_git(&self, args: &[&str]) -> Result<Output, VcsError>`
- Implement `Vcs` trait:
  - `has_changes`: `git status --porcelain` - non-empty output means changes
  - `stage_all`: `git add -A`
  - `commit`: `git commit -m "message" --no-verify` - parse hash from output

**src/vcs/sapling.rs:**
- `SaplingVcs` struct with `root: PathBuf`
- Helper `fn run_sl(&self, args: &[&str]) -> Result<Output, VcsError>`
- Implement `Vcs` trait:
  - `has_changes`: `sl status` - non-empty output means changes
  - `stage_all`: `sl addremove`
  - `commit`: `sl commit -m "message"` - parse hash from output

**src/error.rs additions:**
Add `VcsError` enum with variants:
- `CommandFailed { command: String, error: String }`
- `NothingToCommit`
- `CommitFailed(String)`
- `Detection(String)`

Implement `std::fmt::Display` for VcsError.
Add `Vcs(VcsError)` variant to `RslphError` enum.

**src/lib.rs:**
Add `pub mod vcs;` to module exports.

Use `std::process::Command` for subprocess calls (synchronous is fine for simple VCS operations).
  </action>
  <verify>
```bash
cargo build 2>&1 | head -20
cargo test vcs 2>&1 | head -30
```
Verify: Build succeeds, VCS module compiles, trait and implementations exist.
  </verify>
  <done>
VCS module exists with:
- Vcs trait defined with has_changes, stage_all, commit, commit_all
- VcsType enum with Git and Sapling variants
- detect_vcs function that tries Sapling first via `sl root`, falls back to Git via .git directory
- GitVcs and SaplingVcs structs implementing Vcs trait
- VcsError in error.rs with appropriate variants
- Module exported in lib.rs
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate VCS commit into build loop</name>
  <files>
    src/build/state.rs
    src/build/iteration.rs
  </files>
  <action>
**src/build/state.rs modifications:**

Add to BuildContext struct:
```rust
/// VCS for auto-commit after iterations (None if not in a repository)
pub vcs: Option<Box<dyn crate::vcs::Vcs>>,
```

Update BuildContext::new() to:
1. Import `crate::vcs::create_vcs`
2. Call `create_vcs(&progress_path)` to detect and create VCS
3. If VCS detected, log: `eprintln!("[VCS] Detected {} repository", v.vcs_type());`
4. Store in vcs field

**src/build/iteration.rs modifications:**

Add helper function for commit message formatting:
```rust
fn format_iteration_commit(
    project_name: &str,
    iteration: u32,
    tasks_completed: u32,
) -> String {
    format!(
        "[{}][iter {}] Completed {} task(s)",
        project_name,
        iteration,
        tasks_completed
    )
}
```

In `run_single_iteration`, after Step 9 (write updated progress file) and before Step 10 (calculate tasks completed):
1. Calculate `tasks_completed_this_iter = tasks_after.saturating_sub(tasks_before)`
2. If `tasks_completed_this_iter > 0` AND `ctx.vcs.is_some()`:
   - Get vcs reference
   - Call `vcs.commit_all(&format_iteration_commit(...))`
   - On Ok(Some(hash)), log: `eprintln!("[VCS] Committed: {} ({})", hash, vcs.vcs_type());`
   - On Ok(None), log: `eprintln!("[VCS] No file changes to commit");`
   - On Err(e), log: `eprintln!("[VCS] Warning: {}", e);` (do NOT fail the build)

Important: VCS errors must NOT fail the build - VCS is a convenience feature for rollback, not critical path.
  </action>
  <verify>
```bash
cargo build 2>&1 | head -20
cargo test build 2>&1 | head -30
```
Verify: Build succeeds with VCS integration, tests pass.
  </verify>
  <done>
BuildContext has vcs field populated via create_vcs() at construction.
run_single_iteration commits after successful iterations with tasks completed.
VCS errors are logged as warnings, not failures.
Commit message format: `[project-name][iter N] Completed M task(s)`
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for VCS module</name>
  <files>
    src/vcs/mod.rs
    src/vcs/git.rs
  </files>
  <action>
Add tests to validate VCS functionality:

**src/vcs/mod.rs tests:**
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::process::Command;
    use tempfile::TempDir;

    #[test]
    fn test_vcs_type_display() {
        assert_eq!(VcsType::Git.to_string(), "Git");
        assert_eq!(VcsType::Sapling.to_string(), "Sapling");
    }

    #[test]
    fn test_detect_vcs_in_git_repo() {
        // Create temp dir with git init
        let dir = TempDir::new().expect("temp dir");
        Command::new("git")
            .args(["init"])
            .current_dir(dir.path())
            .output()
            .expect("git init");

        let detection = detect_vcs(dir.path()).expect("detect");
        assert!(detection.is_some());
        let det = detection.unwrap();
        // May be Git or Sapling depending on environment
        assert!(det.vcs_type == VcsType::Git || det.vcs_type == VcsType::Sapling);
    }

    #[test]
    fn test_detect_vcs_no_repo() {
        let dir = TempDir::new().expect("temp dir");
        // No git init, just empty dir
        let detection = detect_vcs(dir.path()).expect("detect");
        // Either None or Sapling if sl is installed and initializes
        // For pure test, expect None in most environments
        // This test may vary by environment
    }

    #[test]
    fn test_create_vcs_returns_implementation() {
        let dir = TempDir::new().expect("temp dir");
        Command::new("git")
            .args(["init"])
            .current_dir(dir.path())
            .output()
            .expect("git init");

        let vcs = create_vcs(dir.path());
        assert!(vcs.is_some());
    }
}
```

**src/vcs/git.rs tests:**
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::vcs::Vcs;
    use std::fs;
    use std::process::Command;
    use tempfile::TempDir;

    fn setup_git_repo() -> (TempDir, GitVcs) {
        let dir = TempDir::new().expect("temp dir");
        Command::new("git")
            .args(["init"])
            .current_dir(dir.path())
            .output()
            .expect("git init");
        // Configure user for commits
        Command::new("git")
            .args(["config", "user.email", "test@test.com"])
            .current_dir(dir.path())
            .output()
            .expect("git config email");
        Command::new("git")
            .args(["config", "user.name", "Test"])
            .current_dir(dir.path())
            .output()
            .expect("git config name");

        let vcs = GitVcs::new(dir.path().to_path_buf());
        (dir, vcs)
    }

    #[test]
    fn test_git_has_no_changes_in_clean_repo() {
        let (dir, vcs) = setup_git_repo();
        // Fresh repo with no commits may show no changes
        let has_changes = vcs.has_changes().expect("has_changes");
        // Empty repo is clean
        assert!(!has_changes || has_changes); // Accept either - depends on git version
    }

    #[test]
    fn test_git_has_changes_with_new_file() {
        let (dir, vcs) = setup_git_repo();
        fs::write(dir.path().join("test.txt"), "hello").expect("write");
        assert!(vcs.has_changes().expect("has_changes"));
    }

    #[test]
    fn test_git_commit_all() {
        let (dir, vcs) = setup_git_repo();
        fs::write(dir.path().join("test.txt"), "hello").expect("write");

        let result = vcs.commit_all("Test commit");
        assert!(result.is_ok());
        let hash = result.unwrap();
        assert!(hash.is_some()); // Should have committed
    }

    #[test]
    fn test_git_commit_all_no_changes() {
        let (dir, vcs) = setup_git_repo();
        // Make an initial commit first
        fs::write(dir.path().join("test.txt"), "hello").expect("write");
        vcs.commit_all("Initial").expect("initial commit");

        // Now try to commit with no changes
        let result = vcs.commit_all("No changes");
        assert!(result.is_ok());
        assert!(result.unwrap().is_none()); // Nothing to commit
    }
}
```

Run tests to verify:
```bash
cargo test vcs -- --nocapture
```
  </action>
  <verify>
```bash
cargo test vcs -- --nocapture 2>&1 | tail -30
```
Verify: All VCS tests pass, including git repo detection, change detection, and commit.
  </verify>
  <done>
Unit tests exist and pass for:
- VcsType display
- detect_vcs in git repo
- detect_vcs with no repo
- create_vcs returns implementation
- GitVcs has_changes (clean and with changes)
- GitVcs commit_all (with and without changes)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   cargo build --release
   cargo test
   ```

2. **Manual integration test (in a git repo):**
   ```bash
   # Create test progress file
   echo "# Test\n## Status\nIn Progress" > /tmp/test-progress.md

   # Run with --once --dry-run to verify VCS detection
   cargo run -- build /tmp/test-progress.md --dry-run
   ```
   Expect: Output shows "[VCS] Detected Git repository" (or Sapling if installed)

3. **Commit behavior verification:**
   - VCS commits only happen when tasks complete
   - No commit if no file changes
   - VCS errors do not fail the build

4. **Rollback verification:**
   After running build, user can:
   - `git log --oneline` to see iteration commits
   - `git reset --hard HEAD~1` to rollback one iteration
</verification>

<success_criteria>
- [ ] VCS module compiles with trait, detection, Git/Sapling implementations
- [ ] detect_vcs prefers Sapling (sl root) over Git (.git directory)
- [ ] BuildContext creates VCS instance at construction
- [ ] After iteration with tasks completed, commit is created automatically
- [ ] Commit message format: `[project][iter N] Completed M task(s)`
- [ ] VCS errors logged as warnings, do not fail build
- [ ] All tests pass including new VCS unit tests
- [ ] Requirements VCS-01, VCS-02, VCS-03 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-vcs-integration/05-01-SUMMARY.md` using template @~/.claude/get-shit-done/templates/summary.md
</output>
