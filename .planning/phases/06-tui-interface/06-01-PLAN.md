---
phase: 06-tui-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/tui/mod.rs
  - src/tui/terminal.rs
  - src/tui/app.rs
  - src/tui/event.rs
autonomous: true

must_haves:
  truths:
    - "Terminal enters raw mode and alternate screen on TUI start"
    - "Terminal restores to normal state on panic or exit"
    - "App state struct holds all UI state fields"
    - "Event handler merges keyboard, subprocess, and render tick events"
  artifacts:
    - path: "src/tui/mod.rs"
      provides: "TUI module exports"
      exports: ["App", "EventHandler", "init_terminal", "restore_terminal"]
    - path: "src/tui/terminal.rs"
      provides: "Terminal setup and panic hooks"
      exports: ["init_terminal", "restore_terminal"]
    - path: "src/tui/app.rs"
      provides: "Application state struct"
      exports: ["App", "AppEvent"]
    - path: "src/tui/event.rs"
      provides: "Event handler for async event merging"
      exports: ["EventHandler"]
  key_links:
    - from: "src/tui/terminal.rs"
      to: "crossterm"
      via: "enable_raw_mode, EnterAlternateScreen"
      pattern: "enable_raw_mode|EnterAlternateScreen"
    - from: "src/tui/event.rs"
      to: "crossterm::event::EventStream"
      via: "futures::StreamExt"
      pattern: "EventStream::new"
---

<objective>
Create TUI module foundation with terminal setup, panic safety hooks, app state struct, and async event handler.

Purpose: Establish the core TUI infrastructure that all subsequent plans build upon. Terminal must be properly initialized with raw mode and alternate screen, panic hooks must restore terminal on crash, and the event system must be ready to multiplex keyboard input, subprocess output, and render ticks.

Output: Working TUI module with terminal init/restore, App state struct, and EventHandler for async event merging.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-tui-interface/06-RESEARCH.md
@.planning/phases/06-tui-interface/06-CONTEXT.md
@src/lib.rs
@Cargo.toml
@src/subprocess/runner.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TUI dependencies and create module structure</name>
  <files>Cargo.toml, src/lib.rs, src/tui/mod.rs</files>
  <action>
Add ratatui and crossterm dependencies to Cargo.toml:
- `ratatui = "0.30"`
- `crossterm = { version = "0.29", features = ["event-stream"] }`
- `futures = "0.3"` (for StreamExt on EventStream)

Create src/tui/ module directory with mod.rs that re-exports:
- `App`, `AppEvent` from app.rs
- `EventHandler` from event.rs
- `init_terminal`, `restore_terminal` from terminal.rs

Add `pub mod tui;` to src/lib.rs.

Do NOT use `ratatui::init()` helper - implement manual terminal setup for full control over panic hooks (the helper doesn't let us chain with existing hooks).
  </action>
  <verify>
`cargo check` passes with new dependencies resolved.
`grep "pub mod tui" src/lib.rs` shows the module is registered.
  </verify>
  <done>
TUI module structure exists with dependencies added to Cargo.toml.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement terminal setup with panic safety</name>
  <files>src/tui/terminal.rs</files>
  <action>
Create terminal.rs with:

1. `init_terminal()` function:
   - Install panic hook BEFORE entering raw mode (chains with existing hook)
   - Call `enable_raw_mode()`
   - Execute `EnterAlternateScreen` and `EnableMouseCapture` on stderr
   - Create and return `Terminal<CrosstermBackend<Stderr>>`

2. `restore_terminal()` function:
   - Call `disable_raw_mode()`
   - Execute `LeaveAlternateScreen` and `DisableMouseCapture`
   - Returns `io::Result<()>`

Panic hook pattern:
```rust
let original_hook = panic::take_hook();
panic::set_hook(Box::new(move |panic_info| {
    let _ = restore_terminal();
    original_hook(panic_info);
}));
```

Use stderr (not stdout) for terminal backend - allows stdout to remain available for non-TUI output if needed.
  </action>
  <verify>
`cargo check` passes.
Create a simple test binary that calls init_terminal, sleeps 1 second, then restore_terminal - terminal should return to normal state.
  </verify>
  <done>
Terminal init/restore functions exist with panic hook that restores terminal on crash.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create App state and EventHandler</name>
  <files>src/tui/app.rs, src/tui/event.rs</files>
  <action>
Create app.rs with App struct (TEA Model):
```rust
pub struct App {
    // Status bar state
    pub current_iteration: u32,
    pub max_iterations: u32,
    pub current_task: u32,
    pub total_tasks: u32,
    pub context_usage: f64,  // 0.0 to 1.0
    pub model_name: String,
    pub project_name: String,
    pub log_path: Option<PathBuf>,

    // Output view state
    pub messages: Vec<Message>,
    pub scroll_offset: u16,

    // Navigation state
    pub viewing_iteration: u32,
    pub is_paused: bool,
    pub should_quit: bool,
}

pub struct Message {
    pub role: String,      // "user", "assistant", "system"
    pub content: String,
    pub iteration: u32,
}

pub enum AppEvent {
    // Keyboard/mouse
    ScrollUp,
    ScrollDown,
    PrevIteration,
    NextIteration,
    TogglePause,
    Quit,

    // Subprocess
    ClaudeOutput(String),
    ContextUsage(f64),
    IterationComplete { tasks_done: u32 },

    // Timer
    Render,
}
```

Create event.rs with EventHandler:
- Spawns async task that uses `tokio::select!` to merge:
  1. crossterm EventStream (keyboard/mouse)
  2. mpsc channel for subprocess events
  3. tokio::time::interval for render ticks (~30 FPS = 33ms)
- Converts crossterm events to AppEvent using key mappings from CONTEXT.md:
  - j -> ScrollDown, k -> ScrollUp
  - { -> PrevIteration, } -> NextIteration
  - p -> TogglePause
  - Ctrl+C -> Quit
  - Mouse scroll -> ScrollUp/ScrollDown
- Provides `next(&mut self) -> Option<AppEvent>` for main loop to consume

Use unbounded channel internally to avoid backpressure issues with fast Claude output.
  </action>
  <verify>
`cargo check` passes.
`cargo test` passes (add basic unit tests for App::new and AppEvent variants).
  </verify>
  <done>
App state struct and EventHandler exist with proper event merging via tokio::select!.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles successfully
2. `cargo test` passes for any new tests
3. TUI module exports are accessible: `use rslph::tui::{App, EventHandler, init_terminal, restore_terminal};`
4. Terminal setup properly chains panic hooks (can be verified by intentional panic in test)
</verification>

<success_criteria>
- TUI module exists with mod.rs, terminal.rs, app.rs, event.rs
- ratatui 0.30 and crossterm 0.29 with event-stream feature in dependencies
- init_terminal creates raw mode + alternate screen
- restore_terminal returns terminal to normal
- Panic hook installed that calls restore_terminal
- App struct has all state fields for status bar, output, navigation
- AppEvent enum covers all user interactions and subprocess events
- EventHandler merges keyboard, subprocess channel, and render tick events
</success_criteria>

<output>
After completion, create `.planning/phases/06-tui-interface/06-01-SUMMARY.md`
</output>
