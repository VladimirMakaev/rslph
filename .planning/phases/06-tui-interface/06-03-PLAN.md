---
phase: 06-tui-interface
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/tui/widgets/output_view.rs
  - src/tui/widgets/mod.rs
  - src/subprocess/runner.rs
  - src/tui/app.rs
autonomous: true

must_haves:
  truths:
    - "Live Claude output streams to TUI without blocking the event loop"
    - "Output scrolls as new content arrives (auto-scroll to bottom)"
    - "User can scroll up/down with j/k keys or mouse wheel"
    - "Scroll position clamps to valid range (no blank screens)"
  artifacts:
    - path: "src/tui/widgets/output_view.rs"
      provides: "Scrollable paragraph widget for live output"
      exports: ["render_output"]
    - path: "src/subprocess/runner.rs"
      provides: "Channel-based streaming method"
      exports: ["run_with_channel"]
  key_links:
    - from: "src/tui/widgets/output_view.rs"
      to: "src/tui/app.rs"
      via: "app.messages and app.scroll_offset"
      pattern: "app\\.messages|app\\.scroll_offset"
    - from: "src/subprocess/runner.rs"
      to: "mpsc::UnboundedSender"
      via: "channel send"
      pattern: "tx\\.send"
---

<objective>
Create the live output view that displays Claude's streaming output with scrolling support, and add a channel-based streaming method to ClaudeRunner for TUI integration.

Purpose: Users need to see Claude's work in real-time without blocking the UI. The output view must handle fast streaming without backpressure issues, support manual scrolling for review, and auto-scroll to follow new output.

Output: Working output view widget with scroll support and ClaudeRunner channel integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-tui-interface/06-RESEARCH.md
@.planning/phases/06-tui-interface/06-CONTEXT.md
@.planning/phases/06-tui-interface/06-01-SUMMARY.md (after plan 01 completes)
@src/subprocess/runner.rs
@src/subprocess/stream_json.rs
@src/tui/app.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add channel-based streaming to ClaudeRunner</name>
  <files>src/subprocess/runner.rs</files>
  <action>
Add a new method to ClaudeRunner for TUI integration:

```rust
/// Run subprocess while sending output lines to a channel.
///
/// Unlike run_to_completion which collects all output, this streams
/// each line to the provided sender for real-time display.
///
/// # Arguments
/// * `tx` - Unbounded sender for output lines
/// * `cancel_token` - Token to request graceful cancellation
///
/// # Returns
/// * `Ok(())` - Process completed normally
/// * `Err(RslphError::Cancelled)` - User cancelled
/// * `Err(RslphError::Subprocess)` - Process error
pub async fn run_with_channel(
    &mut self,
    tx: mpsc::UnboundedSender<OutputLine>,
    cancel_token: CancellationToken,
) -> Result<(), RslphError> {
    loop {
        tokio::select! {
            biased;

            _ = cancel_token.cancelled() => {
                self.terminate_gracefully(Duration::from_secs(5)).await
                    .map_err(|e| RslphError::Subprocess(e.to_string()))?;
                return Err(RslphError::Cancelled);
            }

            line = self.next_output() => {
                match line {
                    Some(l) => {
                        // If receiver dropped, stop gracefully
                        if tx.send(l).is_err() {
                            break;
                        }
                    }
                    None => break, // Process finished
                }
            }
        }
    }

    // Reap child to prevent zombie
    let _ = self.child.wait().await;
    Ok(())
}
```

Add `use tokio::sync::mpsc;` if not already present.

Note: This method is intentionally similar to run_to_completion but sends to channel instead of collecting. Keep both methods - run_to_completion is still used in non-TUI mode.
  </action>
  <verify>
`cargo check` passes.
Method signature matches the documented pattern.
  </verify>
  <done>
ClaudeRunner has run_with_channel method for TUI streaming.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create output view widget with scrolling</name>
  <files>src/tui/widgets/output_view.rs, src/tui/widgets/mod.rs</files>
  <action>
Create output_view.rs with:

1. `render_output(frame: &mut Frame, area: Rect, app: &App)`:
   - Convert app.messages to Vec<Line> for Paragraph
   - Each message formatted as "role: content" (can be multiline)
   - Use Paragraph with wrap and scroll

```rust
pub fn render_output(frame: &mut Frame, area: Rect, app: &App) {
    let lines: Vec<Line> = app.messages
        .iter()
        .filter(|m| m.iteration == app.viewing_iteration)
        .flat_map(|msg| {
            // Format message with role prefix
            let prefix = format!("{}: ", msg.role);
            msg.content.lines().enumerate().map(move |(i, line)| {
                if i == 0 {
                    Line::from(format!("{}{}", prefix, line))
                } else {
                    Line::from(format!("{:width$}{}", "", line, width = prefix.len()))
                }
            }).collect::<Vec<_>>()
        })
        .collect();

    let paragraph = Paragraph::new(lines)
        .wrap(Wrap { trim: false })
        .scroll((app.scroll_offset, 0));  // (y, x)

    frame.render_widget(paragraph, area);
}
```

2. Add helper functions to App (in app.rs):

```rust
impl App {
    /// Scroll down by one line, clamped to content length.
    pub fn scroll_down(&mut self, viewport_height: u16, content_height: u16) {
        let max_offset = content_height.saturating_sub(viewport_height);
        self.scroll_offset = (self.scroll_offset + 1).min(max_offset);
    }

    /// Scroll up by one line.
    pub fn scroll_up(&mut self) {
        self.scroll_offset = self.scroll_offset.saturating_sub(1);
    }

    /// Auto-scroll to bottom (for following live output).
    pub fn scroll_to_bottom(&mut self, viewport_height: u16, content_height: u16) {
        let max_offset = content_height.saturating_sub(viewport_height);
        self.scroll_offset = max_offset;
    }

    /// Add a new message and auto-scroll if at bottom.
    pub fn add_message(&mut self, role: String, content: String, viewport_height: u16) {
        let was_at_bottom = self.is_at_bottom(viewport_height);
        self.messages.push(Message {
            role,
            content,
            iteration: self.current_iteration,
        });
        if was_at_bottom {
            // Content height increased, but we handle this on next render
            // Just mark that we should scroll
        }
    }

    fn is_at_bottom(&self, viewport_height: u16) -> bool {
        let content_height = self.content_height_for_iteration(self.viewing_iteration);
        let max_offset = content_height.saturating_sub(viewport_height);
        self.scroll_offset >= max_offset
    }

    fn content_height_for_iteration(&self, iteration: u32) -> u16 {
        self.messages
            .iter()
            .filter(|m| m.iteration == iteration)
            .map(|m| m.content.lines().count() as u16 + 1) // +1 for role line
            .sum()
    }
}
```

Add `pub mod output_view;` to widgets/mod.rs.
  </action>
  <verify>
`cargo check` passes.
Scroll functions properly clamp to valid range (test with 0 content).
  </verify>
  <done>
Output view renders with scrolling and auto-scroll behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate output view with main UI render</name>
  <files>src/tui/ui.rs</files>
  <action>
Update ui.rs to:

1. Import the output_view widget:
```rust
use super::widgets::output_view::render_output;
```

2. Replace placeholder render_body with real implementation:
```rust
fn render_body(frame: &mut Frame, area: Rect, app: &App) {
    // Optional: Add a subtle border or title
    let block = Block::default()
        .borders(Borders::TOP)
        .border_style(Style::default().fg(Color::DarkGray));

    let inner = block.inner(area);
    frame.render_widget(block, area);

    render_output(frame, inner, app);
}
```

3. Update the pause overlay to render over the body when paused:
```rust
// In render function, after render_body:
if app.is_paused {
    render_pause_overlay(frame, body);
}
```

4. Implement render_pause_overlay:
```rust
fn render_pause_overlay(frame: &mut Frame, area: Rect) {
    let message = "PAUSED - press p to resume";
    let width = message.len() as u16 + 4;
    let height = 3;

    let popup_area = Rect {
        x: area.x + (area.width.saturating_sub(width)) / 2,
        y: area.y + (area.height.saturating_sub(height)) / 2,
        width: width.min(area.width),
        height: height.min(area.height),
    };

    frame.render_widget(Clear, popup_area);

    let block = Block::default()
        .borders(Borders::ALL)
        .border_style(Style::default().fg(Color::Yellow));

    let text = Paragraph::new(message)
        .alignment(Alignment::Center)
        .block(block);

    frame.render_widget(text, popup_area);
}
```
  </action>
  <verify>
`cargo check` passes.
Main render function calls output view and shows pause overlay when paused.
  </verify>
  <done>
Output view integrated with main UI, pause overlay implemented.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles successfully
2. ClaudeRunner has run_with_channel method
3. Output view renders messages filtered by current iteration
4. Scroll functions clamp properly (no panic on empty content)
5. Pause overlay appears centered when app.is_paused is true
</verification>

<success_criteria>
- ClaudeRunner::run_with_channel streams to mpsc channel
- output_view.rs renders scrollable paragraph
- App has scroll_up, scroll_down, scroll_to_bottom helper methods
- Scroll offset clamped to valid range
- Pause overlay displays "PAUSED - press p to resume"
- All code compiles and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-tui-interface/06-03-SUMMARY.md`
</output>
