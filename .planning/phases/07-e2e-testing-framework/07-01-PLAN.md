---
phase: 07-e2e-testing-framework
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - tests/fake_claude/mod.rs
  - tests/fake_claude/scenario.rs
  - tests/fake_claude/stream_json.rs
  - tests/fake_claude/config.rs
  - tests/fake_claude.rs
autonomous: true

must_haves:
  truths:
    - "Fake Claude binary can be built and executed"
    - "Scenario builder can configure text responses"
    - "Output matches real Claude CLI stream-json format"
    - "Config file can be serialized and read by binary"
  artifacts:
    - path: "tests/fake_claude.rs"
      provides: "Binary entry point"
      min_lines: 30
    - path: "tests/fake_claude/scenario.rs"
      provides: "ScenarioBuilder with fluent API"
      exports: ["ScenarioBuilder", "FakeClaudeHandle"]
    - path: "tests/fake_claude/stream_json.rs"
      provides: "Serializable stream-json event types"
      contains: "Serialize"
    - path: "tests/fake_claude/config.rs"
      provides: "Configuration types for fake binary"
      exports: ["FakeClaudeConfig", "InvocationConfig"]
  key_links:
    - from: "tests/fake_claude.rs"
      to: "tests/fake_claude/config.rs"
      via: "deserialize config from FAKE_CLAUDE_CONFIG env var"
      pattern: "FAKE_CLAUDE_CONFIG"
    - from: "tests/fake_claude/scenario.rs"
      to: "tests/fake_claude/config.rs"
      via: "serialize config on build()"
      pattern: "serde_json::to_string"
    - from: "tests/fake_claude/stream_json.rs"
      to: "src/subprocess/stream_json.rs"
      via: "serializable types mirror deserialization types for format compatibility"
      pattern: "StreamEventOutput"
---

<objective>
Create core fake-claude infrastructure with scenario builder and stream-json output.

Purpose: Foundation for all E2E testing - a fake Claude binary that outputs deterministic stream-json responses based on pre-configured scenarios.

Output: Fake-claude binary and ScenarioBuilder API that can generate text responses.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-e2e-testing-framework/07-RESEARCH.md

# Key source files to understand existing types
@src/subprocess/stream_json.rs
@src/subprocess/mod.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dev-dependencies and configure test binary</name>
  <files>Cargo.toml</files>
  <action>
Add required dev-dependencies for E2E testing:
- tempfile = "3" (already present)
- assert_cmd = "2"
- assert_fs = "1"
- insta = "2"
- tokio with test-util feature

Add test binary configuration:
```toml
[[test]]
name = "fake_claude"
path = "tests/fake_claude.rs"
```

Note: Do NOT add ratatui-testlib yet - save for Plan 04 when TUI tests are implemented. The crate is very new (v0.1.0) and may need API verification.
  </action>
  <verify>
- `cargo check` succeeds
- `cargo test --no-run` succeeds
  </verify>
  <done>Cargo.toml has E2E dev-dependencies and test binary configured</done>
</task>

<task type="auto">
  <name>Task 2: Create stream-json serialization types</name>
  <files>tests/fake_claude/mod.rs, tests/fake_claude/stream_json.rs</files>
  <action>
Create `tests/fake_claude/` directory with mod.rs and stream_json.rs.

In stream_json.rs, create SERIALIZABLE versions of the stream-json types that mirror the existing deserialization types in src/subprocess/stream_json.rs. The fake binary needs to OUTPUT json, so these need Serialize derive.

IMPORTANT: These types must mirror the structure of src/subprocess/stream_json.rs to ensure format compatibility. When Claude CLI output format changes, both files should be updated together.

Types needed:
- `StreamEventOutput` - wraps event_type, message, uuid, timestamp
- `MessageOutput` - wraps id, role, content, model, stop_reason, usage
- `MessageContentOutput` - enum: Text(String), Blocks(Vec<ContentBlockOutput>)
- `ContentBlockOutput` - text, thinking, tool_use variants
- `UsageOutput` - token counts

Add helper constructors:
- `StreamEventOutput::assistant_text(text: &str) -> Self` - creates text response event
- `StreamEventOutput::system_init() -> Self` - creates init system event (first event of session)
- `StreamEventOutput::result(cost_usd: f64) -> Self` - creates result/summary event

Use `#[serde(skip_serializing_if = "Option::is_none")]` on optional fields to match real Claude output format.

In mod.rs:
```rust
pub mod config;
pub mod scenario;
pub mod stream_json;

pub use config::{FakeClaudeConfig, InvocationConfig};
pub use scenario::{FakeClaudeHandle, ScenarioBuilder};
pub use stream_json::StreamEventOutput;
```
  </action>
  <verify>
- `cargo test --no-run` succeeds
- Types compile with Serialize derive
  </verify>
  <done>Serializable stream-json types exist for fake Claude output generation</done>
</task>

<task type="auto">
  <name>Task 3: Create config types and scenario builder</name>
  <files>tests/fake_claude/config.rs, tests/fake_claude/scenario.rs</files>
  <action>
Create config.rs with serialization/deserialization types:
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct FakeClaudeConfig {
    pub invocations: Vec<InvocationConfig>,
    pub counter_path: PathBuf,
}

#[derive(Debug, Default, Serialize, Deserialize)]
pub struct InvocationConfig {
    pub events: Vec<StreamEventOutput>,
    pub delay_ms: Option<u64>,
    pub crash_after_events: Option<usize>,
}
```

Create scenario.rs with ScenarioBuilder:
```rust
pub struct ScenarioBuilder {
    invocations: Vec<InvocationConfig>,
    current_invocation: Option<InvocationConfig>,
    temp_dir: TempDir,
}

impl ScenarioBuilder {
    pub fn new() -> Self { ... }

    /// Add text response to current invocation
    pub fn respond_with_text(mut self, text: &str) -> Self { ... }

    /// Start configuring next invocation
    pub fn next_invocation(mut self) -> Self { ... }

    /// Build and return handle with paths
    pub fn build(mut self) -> FakeClaudeHandle { ... }
}

pub struct FakeClaudeHandle {
    pub executable_path: PathBuf,
    pub config_path: PathBuf,
    counter_path: PathBuf,
    _temp_dir: TempDir,
}

impl FakeClaudeHandle {
    /// Get invocation count for assertions
    pub fn invocation_count(&self) -> usize { ... }

    /// Environment variables to set when running rslph
    pub fn env_vars(&self) -> Vec<(&'static str, String)> { ... }
}
```

For executable_path, use `env!("CARGO_BIN_EXE_fake_claude")` or fall back to building path from CARGO_MANIFEST_DIR.
  </action>
  <verify>
- `cargo test --no-run` succeeds
- ScenarioBuilder compiles with all methods
  </verify>
  <done>ScenarioBuilder and config types exist with fluent API</done>
</task>

<task type="auto">
  <name>Task 4: Create fake-claude binary</name>
  <files>tests/fake_claude.rs</files>
  <action>
Create the fake-claude test binary at tests/fake_claude.rs.

The binary:
1. Reads FAKE_CLAUDE_CONFIG env var to get config path
2. Deserializes FakeClaudeConfig from that file
3. Reads invocation counter from counter_path, increments it
4. Gets the InvocationConfig for this invocation number (0-indexed)
5. For each event in events:
   - Apply delay_ms if configured (thread::sleep)
   - Serialize event to JSON and println!
   - Flush stdout
   - If crash_after_events reached, exit(1)
6. Exit(0) on success

Handle edge cases:
- Missing FAKE_CLAUDE_CONFIG: panic with clear message
- Config file missing: panic with clear message
- Invocation beyond configured: output nothing, exit(0) (silent pass-through)

```rust
// tests/fake_claude.rs
mod fake_claude;

use fake_claude::config::FakeClaudeConfig;
use std::env;
use std::fs;
use std::io::{self, Write};

fn main() {
    let config_path = env::var("FAKE_CLAUDE_CONFIG")
        .expect("FAKE_CLAUDE_CONFIG env var must be set");

    let config: FakeClaudeConfig = serde_json::from_str(
        &fs::read_to_string(&config_path)
            .expect("Failed to read config file")
    ).expect("Failed to parse config");

    // Read and increment counter
    let invocation = increment_counter(&config.counter_path);

    // Get response for this invocation (0-indexed)
    let Some(inv_config) = config.invocations.get(invocation) else {
        // Silent pass-through for unconfigured invocations
        return;
    };

    for (i, event) in inv_config.events.iter().enumerate() {
        if let Some(delay) = inv_config.delay_ms {
            std::thread::sleep(std::time::Duration::from_millis(delay));
        }

        println!("{}", serde_json::to_string(&event).unwrap());
        io::stdout().flush().unwrap();

        if inv_config.crash_after_events == Some(i + 1) {
            std::process::exit(1);
        }
    }
}

fn increment_counter(path: &std::path::Path) -> usize {
    let current = fs::read_to_string(path)
        .ok()
        .and_then(|s| s.trim().parse().ok())
        .unwrap_or(0);

    fs::write(path, format!("{}", current + 1)).ok();
    current
}
```
  </action>
  <verify>
- `cargo build --tests` succeeds
- Binary exists after build
- Test manually: Create config.json with one event, set FAKE_CLAUDE_CONFIG, run binary, verify JSON output
  </verify>
  <done>Fake-claude binary compiles and outputs stream-json based on config</done>
</task>

</tasks>

<verification>
All verification:
- `cargo check` passes
- `cargo test --no-run` passes
- `cargo build --tests` builds fake_claude binary
- Manual test: Create test config, run fake_claude binary, verify output format matches real Claude CLI stream-json
</verification>

<success_criteria>
- Fake-claude binary exists in target/debug/deps
- ScenarioBuilder can be constructed and .respond_with_text().build() produces valid handle
- Binary outputs stream-json that would parse correctly with existing StreamEvent::parse()
- Config round-trips through serialize/deserialize correctly
</success_criteria>

<output>
After completion, create `.planning/phases/07-e2e-testing-framework/07-01-SUMMARY.md`
</output>
