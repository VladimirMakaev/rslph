---
phase: 07-e2e-testing-framework
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - fake_claude/__init__.py
  - fake_claude/scenario.py
  - fake_claude/executable.py
  - fake_claude/stream_json.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "fake_claude() returns a builder that can configure responses"
    - "Builder can chain invocations with .on_invocation() and .next_invocation()"
    - "Tool calls can be added with .uses_read(), .uses_write(), .uses_bash()"
    - "Build produces executable path that outputs valid stream-json"
    - "Output matches Claude CLI format exactly (parseable by stream_json.rs)"
  artifacts:
    - path: "fake_claude/__init__.py"
      provides: "Package entry with fake_claude() factory function"
      exports: ["fake_claude"]
    - path: "fake_claude/scenario.py"
      provides: "ScenarioBuilder with fluent API"
      min_lines: 100
    - path: "fake_claude/executable.py"
      provides: "Executable script generator"
      min_lines: 50
    - path: "fake_claude/stream_json.py"
      provides: "Stream-json event generators matching Claude CLI format"
      min_lines: 80
    - path: "pyproject.toml"
      provides: "Python package configuration"
      contains: "fake_claude"
  key_links:
    - from: "fake_claude/scenario.py"
      to: "fake_claude/executable.py"
      via: "ScenarioBuilder.build() calls create_executable()"
      pattern: "create_executable"
    - from: "fake_claude/executable.py"
      to: "fake_claude/stream_json.py"
      via: "Generated script uses stream_json generators"
      pattern: "generate_"
---

<objective>
Create the core fake-claude Python package with fluent scenario builder API that generates executable scripts outputting valid stream-json format matching Claude CLI.

Purpose: Enable deterministic E2E testing by replacing Claude CLI with a predictable fake that outputs exact format rslph expects.

Output: `fake_claude` Python package with builder pattern API and stream-json generators.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-e2e-testing-framework/07-CONTEXT.md
@.planning/phases/07-e2e-testing-framework/07-RESEARCH.md

# Reference for exact stream-json format
@src/subprocess/stream_json.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stream-json generators matching Claude CLI format</name>
  <files>
    fake_claude/stream_json.py
    fake_claude/__init__.py
  </files>
  <action>
Create `fake_claude/stream_json.py` with functions to generate valid stream-json events:

1. Study `src/subprocess/stream_json.rs` tests for exact JSON format:
   - User message: `{"type":"user","message":{"role":"user","content":"..."},"uuid":"...","timestamp":"..."}`
   - Assistant text: `{"type":"assistant","message":{"id":"...","role":"assistant","content":[{"type":"text","text":"..."}],"model":"claude-opus-4.5","stop_reason":"end_turn","usage":{...}},"uuid":"...","timestamp":"..."}`
   - Tool use: `{"type":"assistant","message":{"content":[{"type":"tool_use","id":"...","name":"Read","input":{...}}],"stop_reason":"tool_use",...}}`

2. Implement generators:
   - `generate_assistant_text(text: str, model: str = "claude-opus-4.5", stop_reason: str = "end_turn", usage: dict = None) -> str`
   - `generate_tool_use(tool_name: str, tool_id: str, input_data: dict, model: str = "claude-opus-4.5") -> str`
   - `generate_thinking(thinking: str) -> dict` (returns content block, not full event)
   - `generate_user_event(content: str) -> str`
   - `generate_result_event(text: str, subtype: str) -> str`

3. Use uuid4() for UUIDs, datetime.now().isoformat() for timestamps.

4. Create `fake_claude/__init__.py` as empty file initially (will add factory in Task 2).
  </action>
  <verify>
```bash
cd /Users/vmakaev/NonWork/rslph
python3 -c "from fake_claude.stream_json import generate_assistant_text; import json; e = generate_assistant_text('hello'); json.loads(e); print('OK')"
```
  </verify>
  <done>stream_json.py exists with all generators, output is valid JSON matching Rust parser format</done>
</task>

<task type="auto">
  <name>Task 2: Create ScenarioBuilder with fluent API</name>
  <files>
    fake_claude/scenario.py
    fake_claude/__init__.py
  </files>
  <action>
Create `fake_claude/scenario.py` with fluent builder API per CONTEXT.md decisions:

1. `class InvocationBuilder`:
   - `respond_with_text(text: str) -> InvocationBuilder` - adds text response
   - `uses_read(path: str) -> InvocationBuilder` - adds Read tool use
   - `uses_write(path: str, content: str) -> InvocationBuilder` - adds Write tool use
   - `uses_bash(command: str) -> InvocationBuilder` - adds Bash tool use
   - `uses_edit(path: str, old: str, new: str) -> InvocationBuilder` - adds Edit tool use
   - `tool_call(name: str, input_data: dict) -> InvocationBuilder` - generic tool call
   - `with_thinking(text: str) -> InvocationBuilder` - adds thinking block before response
   - `with_delay(seconds: float) -> InvocationBuilder` - delay between output lines
   - `with_exit_code(code: int) -> InvocationBuilder` - configure exit code
   - `crash_after(lines: int) -> InvocationBuilder` - exit mid-stream
   - Stores list of content blocks and config internally

2. `class ScenarioBuilder`:
   - `on_invocation(n: int) -> InvocationBuilder` - start configuring invocation N
   - `next_invocation() -> InvocationBuilder` - shorthand for next invocation
   - `build() -> Scenario` - finalize and create executable
   - Tracks dict of invocation_number -> InvocationBuilder

3. `class Scenario`:
   - `executable_path: str` - path to generated Python script
   - `invocations: list` - log of actual invocations (populated after runs)
   - `cleanup()` - delete temp files

4. Update `fake_claude/__init__.py`:
   - `from .scenario import ScenarioBuilder`
   - `def fake_claude() -> ScenarioBuilder: return ScenarioBuilder()`
  </action>
  <verify>
```bash
cd /Users/vmakaev/NonWork/rslph
python3 -c "
from fake_claude import fake_claude
scenario = fake_claude().on_invocation(1).respond_with_text('hello').uses_read('/tmp/x').build()
print('Path:', scenario.executable_path)
scenario.cleanup()
print('OK')
"
```
  </verify>
  <done>ScenarioBuilder exists with full fluent API, fake_claude() factory works, Scenario holds executable path</done>
</task>

<task type="auto">
  <name>Task 3: Create executable generator and pyproject.toml</name>
  <files>
    fake_claude/executable.py
    pyproject.toml
  </files>
  <action>
1. Create `fake_claude/executable.py` with executable generator:

```python
def create_executable(invocations: dict, test_id: str = None) -> str:
    """
    Create a temporary Python script that acts as fake Claude CLI.

    Args:
        invocations: dict mapping invocation number to response config
        test_id: unique identifier for this test (prevents race conditions)

    Returns:
        Path to executable script
    """
```

The generated script should:
- Use shebang `#!/usr/bin/env python3`
- Track invocation count in temp file (use test_id in filename for isolation)
- Look up response config for current invocation number
- Output stream-json lines with configured delays
- Handle `crash_after` by exiting mid-stream
- Exit with configured exit code (default 0)
- Silent pass-through for unconfigured invocations (empty output, exit 0)

Use `tempfile.mkstemp(suffix=".py", prefix="fake_claude_")` with `delete=False`.
Make executable with `os.chmod(..., stat.S_IRWXU)`.

2. Update `fake_claude/scenario.py` to call `create_executable()` in `build()`.

3. Create `pyproject.toml`:
```toml
[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "fake-claude"
version = "0.1.0"
description = "Fake Claude CLI for E2E testing"
requires-python = ">=3.10"
dependencies = []

[project.optional-dependencies]
dev = ["pytest>=8.0", "pytest-git>=1.8.0"]

[tool.pytest.ini_options]
testpaths = ["tests/e2e"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
tmp_path_retention_policy = "failed"
tmp_path_retention_count = 5
```
  </action>
  <verify>
```bash
cd /Users/vmakaev/NonWork/rslph
python3 -c "
from fake_claude import fake_claude
s = fake_claude().on_invocation(1).respond_with_text('test').build()
import subprocess
result = subprocess.run([s.executable_path], capture_output=True, text=True)
print('stdout:', result.stdout[:100] if result.stdout else 'empty')
print('exit:', result.returncode)
s.cleanup()
"
```
  </verify>
  <done>Executable generator creates runnable fake Claude, pyproject.toml configures package and pytest</done>
</task>

</tasks>

<verification>
```bash
# Verify package structure
cd /Users/vmakaev/NonWork/rslph
ls -la fake_claude/
cat pyproject.toml

# Test full flow
python3 -c "
from fake_claude import fake_claude
import subprocess
import json

# Build scenario with text and tool use
s = (fake_claude()
    .on_invocation(1)
    .respond_with_text('I will read the file')
    .uses_read('/tmp/test.txt')
    .build())

# Run fake executable
result = subprocess.run([s.executable_path], capture_output=True, text=True)

# Parse output as stream-json
for line in result.stdout.strip().split('\n'):
    if line:
        event = json.loads(line)
        print(f'Event type: {event[\"type\"]}')

s.cleanup()
print('Full flow OK')
"

# Verify format matches Rust parser expectations
cargo test --lib stream_json -- --nocapture 2>/dev/null | head -20
```
</verification>

<success_criteria>
1. `fake_claude/` package exists with __init__.py, scenario.py, executable.py, stream_json.py
2. `fake_claude()` factory returns ScenarioBuilder
3. Fluent API supports: on_invocation, next_invocation, respond_with_text, uses_read/write/bash/edit, tool_call
4. build() creates executable that outputs valid stream-json
5. Stream-json format matches exactly what src/subprocess/stream_json.rs expects
6. pyproject.toml configures package and pytest settings
</success_criteria>

<output>
After completion, create `.planning/phases/07-e2e-testing-framework/07-01-SUMMARY.md`
</output>
