---
phase: 07-e2e-testing-framework
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/e2e/mod.rs
  - tests/e2e/fixtures.rs
  - tests/e2e/helpers.rs
autonomous: true

must_haves:
  truths:
    - "WorkspaceBuilder creates isolated temp directories"
    - "Workspace initializes git by default"
    - "Workspace can be configured with progress file and source files"
    - "Verifier helpers assert on task completion and file content"
  artifacts:
    - path: "tests/e2e/fixtures.rs"
      provides: "WorkspaceBuilder and Workspace types"
      exports: ["WorkspaceBuilder", "Workspace"]
      min_lines: 80
    - path: "tests/e2e/helpers.rs"
      provides: "Assertion helpers for test verification"
      exports: ["assert_task_complete", "assert_ralph_done", "assert_file_contains", "assert_git_commit_exists"]
    - path: "tests/e2e/mod.rs"
      provides: "Module declarations"
      contains: "pub mod"
  key_links:
    - from: "tests/e2e/fixtures.rs"
      to: "tempfile::TempDir"
      via: "workspace temp directory management"
      pattern: "TempDir::new"
    - from: "tests/e2e/helpers.rs"
      to: "Workspace"
      via: "assertions use workspace.read_file()"
      pattern: "workspace.read_file"
---

<objective>
Create workspace fixtures and verifier helpers for E2E tests.

Purpose: Provide isolated, reproducible test workspaces with git and config, plus assertion helpers for verifying test outcomes.

Output: WorkspaceBuilder for test setup and assertion helpers for test verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-e2e-testing-framework/07-RESEARCH.md

# Key source files
@src/config.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workspace fixtures module</name>
  <files>tests/e2e/mod.rs, tests/e2e/fixtures.rs</files>
  <action>
Create `tests/e2e/` directory with mod.rs and fixtures.rs.

In mod.rs:
```rust
pub mod fixtures;
pub mod helpers;

pub use fixtures::{Workspace, WorkspaceBuilder};
pub use helpers::*;
```

In fixtures.rs, create WorkspaceBuilder with fluent API:

```rust
use tempfile::TempDir;
use std::path::{Path, PathBuf};
use std::process::Command;

pub struct WorkspaceBuilder {
    temp_dir: TempDir,
    init_git: bool,
    config: Option<String>,
    progress_content: Option<String>,
    source_files: Vec<(PathBuf, String)>,
}

impl WorkspaceBuilder {
    pub fn new() -> Self {
        Self {
            temp_dir: TempDir::new().expect("Failed to create temp dir"),
            init_git: true,
            config: None,
            progress_content: None,
            source_files: vec![],
        }
    }

    /// Set progress file content
    pub fn with_progress_file(mut self, content: &str) -> Self {
        self.progress_content = Some(content.to_string());
        self
    }

    /// Add a source file to the workspace
    pub fn with_source_file(mut self, path: &str, content: &str) -> Self {
        self.source_files.push((PathBuf::from(path), content.to_string()));
        self
    }

    /// Set custom config TOML content
    pub fn with_config(mut self, config_toml: &str) -> Self {
        self.config = Some(config_toml.to_string());
        self
    }

    /// Disable git initialization
    pub fn without_git(mut self) -> Self {
        self.init_git = false;
        self
    }

    /// Build the workspace
    pub fn build(self) -> Workspace {
        let path = self.temp_dir.path();

        // Initialize git if requested
        if self.init_git {
            Command::new("git")
                .args(["init"])
                .current_dir(path)
                .output()
                .expect("Failed to init git");

            Command::new("git")
                .args(["config", "user.email", "test@test.com"])
                .current_dir(path)
                .output()
                .expect("Failed to set git email");

            Command::new("git")
                .args(["config", "user.name", "Test"])
                .current_dir(path)
                .output()
                .expect("Failed to set git name");
        }

        // Write config
        let config_dir = path.join(".rslph");
        std::fs::create_dir_all(&config_dir).expect("Failed to create config dir");
        let config_content = self.config.unwrap_or_else(|| {
            "[rslph]\nclaude_path = \"claude\"\n".to_string()
        });
        std::fs::write(config_dir.join("config.toml"), &config_content)
            .expect("Failed to write config");

        // Write progress file
        if let Some(content) = self.progress_content {
            std::fs::write(path.join("PROGRESS.md"), &content)
                .expect("Failed to write progress file");
        }

        // Write source files
        for (rel_path, content) in self.source_files {
            let full_path = path.join(&rel_path);
            if let Some(parent) = full_path.parent() {
                std::fs::create_dir_all(parent).expect("Failed to create parent dirs");
            }
            std::fs::write(full_path, content).expect("Failed to write source file");
        }

        Workspace {
            _temp_dir: self.temp_dir,
            path: path.to_path_buf(),
        }
    }
}
```

Create Workspace struct:
```rust
pub struct Workspace {
    _temp_dir: TempDir, // Keep alive for RAII cleanup
    path: PathBuf,
}

impl Workspace {
    /// Get workspace path
    pub fn path(&self) -> &Path {
        &self.path
    }

    /// Read a file from workspace
    pub fn read_file(&self, rel_path: &str) -> String {
        std::fs::read_to_string(self.path.join(rel_path))
            .unwrap_or_else(|e| panic!("Failed to read {}: {}", rel_path, e))
    }

    /// Check if file exists
    pub fn file_exists(&self, rel_path: &str) -> bool {
        self.path.join(rel_path).exists()
    }

    /// Write a file to workspace
    pub fn write_file(&self, rel_path: &str, content: &str) {
        let full_path = self.path.join(rel_path);
        if let Some(parent) = full_path.parent() {
            std::fs::create_dir_all(parent).ok();
        }
        std::fs::write(full_path, content)
            .unwrap_or_else(|e| panic!("Failed to write {}: {}", rel_path, e));
    }
}
```
  </action>
  <verify>
- `cargo check --tests` succeeds
- Types compile correctly
  </verify>
  <done>WorkspaceBuilder and Workspace types exist with fluent API</done>
</task>

<task type="auto">
  <name>Task 2: Create verifier helpers</name>
  <files>tests/e2e/helpers.rs</files>
  <action>
Create helpers.rs with assertion functions for test verification:

```rust
use super::fixtures::Workspace;
use std::process::Command;

/// Assert that a task is marked complete in progress file
pub fn assert_task_complete(workspace: &Workspace, task_pattern: &str) {
    let content = workspace.read_file("PROGRESS.md");
    let pattern = format!("- [x] {}", task_pattern);
    assert!(
        content.contains(&pattern),
        "Expected task '{}' to be complete in PROGRESS.md.\nActual content:\n{}",
        task_pattern,
        content
    );
}

/// Assert that a task is NOT complete (still pending)
pub fn assert_task_pending(workspace: &Workspace, task_pattern: &str) {
    let content = workspace.read_file("PROGRESS.md");
    let pattern = format!("- [ ] {}", task_pattern);
    assert!(
        content.contains(&pattern),
        "Expected task '{}' to be pending in PROGRESS.md.\nActual content:\n{}",
        task_pattern,
        content
    );
}

/// Assert that RALPH_DONE marker exists in progress file
pub fn assert_ralph_done(workspace: &Workspace) {
    let content = workspace.read_file("PROGRESS.md");
    assert!(
        content.contains("RALPH_DONE"),
        "Expected RALPH_DONE marker in PROGRESS.md.\nActual content:\n{}",
        content
    );
}

/// Assert that RALPH_DONE marker does NOT exist
pub fn assert_not_ralph_done(workspace: &Workspace) {
    if workspace.file_exists("PROGRESS.md") {
        let content = workspace.read_file("PROGRESS.md");
        assert!(
            !content.contains("RALPH_DONE"),
            "Expected NO RALPH_DONE marker in PROGRESS.md.\nActual content:\n{}",
            content
        );
    }
}

/// Assert file contains expected content
pub fn assert_file_contains(workspace: &Workspace, path: &str, expected: &str) {
    let content = workspace.read_file(path);
    assert!(
        content.contains(expected),
        "Expected '{}' to contain '{}'.\nActual content:\n{}",
        path,
        expected,
        content
    );
}

/// Assert file does NOT contain content
pub fn assert_file_not_contains(workspace: &Workspace, path: &str, unexpected: &str) {
    let content = workspace.read_file(path);
    assert!(
        !content.contains(unexpected),
        "Expected '{}' to NOT contain '{}'.\nActual content:\n{}",
        path,
        unexpected,
        content
    );
}

/// Assert git commit exists with message pattern
pub fn assert_git_commit_exists(workspace: &Workspace, message_pattern: &str) {
    let output = Command::new("git")
        .args(["log", "--oneline", "-10"])
        .current_dir(workspace.path())
        .output()
        .expect("Failed to run git log");

    let log = String::from_utf8_lossy(&output.stdout);
    assert!(
        log.contains(message_pattern),
        "Expected commit with '{}' in git log.\nActual log:\n{}",
        message_pattern,
        log
    );
}

/// Assert no uncommitted changes exist (working tree clean)
pub fn assert_git_clean(workspace: &Workspace) {
    let output = Command::new("git")
        .args(["status", "--porcelain"])
        .current_dir(workspace.path())
        .output()
        .expect("Failed to run git status");

    let status = String::from_utf8_lossy(&output.stdout);
    assert!(
        status.trim().is_empty(),
        "Expected clean git working tree.\nActual status:\n{}",
        status
    );
}

/// Get number of git commits in repository
pub fn git_commit_count(workspace: &Workspace) -> usize {
    let output = Command::new("git")
        .args(["rev-list", "--count", "HEAD"])
        .current_dir(workspace.path())
        .output()
        .ok()
        .filter(|o| o.status.success());

    output
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .and_then(|s| s.trim().parse().ok())
        .unwrap_or(0)
}
```
  </action>
  <verify>
- `cargo check --tests` succeeds
- All helper functions compile
  </verify>
  <done>Verifier helpers exist for task completion, file content, and git assertions</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for fixtures and helpers</name>
  <files>tests/e2e/fixtures.rs, tests/e2e/helpers.rs</files>
  <action>
Add unit tests to fixtures.rs:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_workspace_creates_temp_directory() {
        let workspace = WorkspaceBuilder::new().build();
        assert!(workspace.path().exists());
    }

    #[test]
    fn test_workspace_initializes_git() {
        let workspace = WorkspaceBuilder::new().build();
        assert!(workspace.path().join(".git").exists());
    }

    #[test]
    fn test_workspace_creates_config() {
        let workspace = WorkspaceBuilder::new().build();
        assert!(workspace.file_exists(".rslph/config.toml"));
    }

    #[test]
    fn test_workspace_with_progress_file() {
        let workspace = WorkspaceBuilder::new()
            .with_progress_file("- [ ] Task 1\n- [ ] Task 2")
            .build();
        let content = workspace.read_file("PROGRESS.md");
        assert!(content.contains("Task 1"));
        assert!(content.contains("Task 2"));
    }

    #[test]
    fn test_workspace_with_source_file() {
        let workspace = WorkspaceBuilder::new()
            .with_source_file("src/main.rs", "fn main() {}")
            .build();
        let content = workspace.read_file("src/main.rs");
        assert_eq!(content, "fn main() {}");
    }

    #[test]
    fn test_workspace_without_git() {
        let workspace = WorkspaceBuilder::new()
            .without_git()
            .build();
        assert!(!workspace.path().join(".git").exists());
    }

    #[test]
    fn test_workspace_custom_config() {
        let workspace = WorkspaceBuilder::new()
            .with_config("[custom]\nkey = \"value\"")
            .build();
        let content = workspace.read_file(".rslph/config.toml");
        assert!(content.contains("key = \"value\""));
    }

    #[test]
    fn test_workspace_write_file() {
        let workspace = WorkspaceBuilder::new().build();
        workspace.write_file("test.txt", "hello");
        assert_eq!(workspace.read_file("test.txt"), "hello");
    }
}
```

Add a simple test in helpers.rs to verify assertion functions work:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::e2e::fixtures::WorkspaceBuilder;

    #[test]
    fn test_assert_task_complete() {
        let workspace = WorkspaceBuilder::new()
            .with_progress_file("- [x] Task 1\n- [ ] Task 2")
            .build();
        assert_task_complete(&workspace, "Task 1");
    }

    #[test]
    fn test_assert_task_pending() {
        let workspace = WorkspaceBuilder::new()
            .with_progress_file("- [x] Task 1\n- [ ] Task 2")
            .build();
        assert_task_pending(&workspace, "Task 2");
    }

    #[test]
    fn test_assert_ralph_done() {
        let workspace = WorkspaceBuilder::new()
            .with_progress_file("- [x] Task 1\nRALPH_DONE")
            .build();
        assert_ralph_done(&workspace);
    }

    #[test]
    fn test_assert_file_contains() {
        let workspace = WorkspaceBuilder::new()
            .with_source_file("test.txt", "hello world")
            .build();
        assert_file_contains(&workspace, "test.txt", "hello");
    }

    #[test]
    fn test_assert_git_commit_exists() {
        let workspace = WorkspaceBuilder::new()
            .with_source_file("test.txt", "content")
            .build();

        // Create a commit
        std::process::Command::new("git")
            .args(["add", "."])
            .current_dir(workspace.path())
            .output()
            .unwrap();
        std::process::Command::new("git")
            .args(["commit", "-m", "Initial commit"])
            .current_dir(workspace.path())
            .output()
            .unwrap();

        assert_git_commit_exists(&workspace, "Initial commit");
    }
}
```
  </action>
  <verify>
- `cargo test e2e::fixtures::tests` passes
- `cargo test e2e::helpers::tests` passes
  </verify>
  <done>Unit tests verify fixtures and helpers work correctly</done>
</task>

</tasks>

<verification>
All verification:
- `cargo check --tests` passes
- `cargo test e2e::` passes (all e2e module tests)
- WorkspaceBuilder creates isolated directories with git
- Verifier helpers provide clear assertion failures
</verification>

<success_criteria>
- WorkspaceBuilder::new().with_progress_file(...).build() creates valid workspace
- Workspace is cleaned up when dropped (TempDir RAII)
- assert_task_complete correctly identifies complete tasks
- assert_git_commit_exists correctly checks git history
</success_criteria>

<output>
After completion, create `.planning/phases/07-e2e-testing-framework/07-02-SUMMARY.md`
</output>
