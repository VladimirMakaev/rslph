---
phase: 07-e2e-testing-framework
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - tests/fake_claude/scenario.rs
  - tests/fake_claude/stream_json.rs
  - tests/fake_claude.rs
autonomous: true

must_haves:
  truths:
    - "Tool calls can be added to scenarios (Read, Write, Edit, Bash)"
    - "Scenarios can configure delays between events"
    - "Scenarios can configure crash after N events"
    - "Multi-invocation scenarios work (next_invocation chaining)"
    - "Malformed output can be sent for edge case testing"
  artifacts:
    - path: "tests/fake_claude/scenario.rs"
      provides: "Extended scenario builder with tool methods"
      contains: ["uses_read", "uses_write", "uses_edit", "uses_bash", "crash_after", "with_delay"]
    - path: "tests/fake_claude/stream_json.rs"
      provides: "Tool use event generation"
      contains: "tool_use"
  key_links:
    - from: "tests/fake_claude/scenario.rs"
      to: "tests/fake_claude/stream_json.rs"
      via: "scenario uses StreamEventOutput::tool_use()"
      pattern: "StreamEventOutput::tool_use"
    - from: "tests/fake_claude.rs"
      to: "config.crash_after_events"
      via: "binary exits early on crash_after"
      pattern: "crash_after_events"
---

<objective>
Extend fake-claude with tool call simulation, edge cases, and multi-invocation support.

Purpose: Enable testing of tool calls (Read, Write, Edit, Bash), edge cases (timeout, crash, malformed), and multi-iteration scenarios.

Output: Complete scenario builder API supporting all test scenarios from requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-e2e-testing-framework/07-RESEARCH.md

# Prior plan artifacts (will exist after 07-01 completes)
# @.planning/phases/07-e2e-testing-framework/07-01-SUMMARY.md

# Key source files to understand tool format
@src/subprocess/stream_json.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tool_use event generation to stream_json</name>
  <files>tests/fake_claude/stream_json.rs</files>
  <action>
Extend stream_json.rs to support tool_use content blocks.

Add tool_use variant to ContentBlockOutput:
```rust
impl ContentBlockOutput {
    pub fn text(text: &str) -> Self {
        Self {
            block_type: "text".to_string(),
            text: Some(text.to_string()),
            ..Default::default()
        }
    }

    pub fn thinking(thinking: &str) -> Self {
        Self {
            block_type: "thinking".to_string(),
            thinking: Some(thinking.to_string()),
            ..Default::default()
        }
    }

    pub fn tool_use(id: &str, name: &str, input: serde_json::Value) -> Self {
        Self {
            block_type: "tool_use".to_string(),
            id: Some(id.to_string()),
            name: Some(name.to_string()),
            input: Some(input),
            ..Default::default()
        }
    }

    pub fn tool_result(tool_use_id: &str, content: &str) -> Self {
        Self {
            block_type: "tool_result".to_string(),
            tool_use_id: Some(tool_use_id.to_string()),
            content: Some(content.to_string()),
            ..Default::default()
        }
    }
}
```

Add static counter for generating unique tool IDs:
```rust
use std::sync::atomic::{AtomicUsize, Ordering};

static TOOL_ID_COUNTER: AtomicUsize = AtomicUsize::new(0);

pub fn next_tool_id() -> String {
    let id = TOOL_ID_COUNTER.fetch_add(1, Ordering::SeqCst);
    format!("toolu_{:04}", id)
}
```

Add helper to StreamEventOutput:
```rust
impl StreamEventOutput {
    // ... existing methods ...

    /// Create tool_use assistant event
    pub fn tool_use(name: &str, input: serde_json::Value) -> Self {
        let id = next_tool_id();
        Self::assistant_with_blocks(vec![
            ContentBlockOutput::tool_use(&id, name, input)
        ], Some("tool_use"))
    }

    /// Create event with multiple content blocks
    pub fn assistant_with_blocks(blocks: Vec<ContentBlockOutput>, stop_reason: Option<&str>) -> Self {
        Self {
            event_type: "assistant".to_string(),
            message: Some(MessageOutput {
                role: Some("assistant".to_string()),
                content: MessageContentOutput::Blocks(blocks),
                stop_reason: stop_reason.map(|s| s.to_string()),
                ..Default::default()
            }),
            ..Default::default()
        }
    }
}
```
  </action>
  <verify>
- `cargo check --tests` succeeds
- StreamEventOutput::tool_use("Read", json!({"file_path": "/test"})) compiles
  </verify>
  <done>Tool use events can be generated with proper JSON structure</done>
</task>

<task type="auto">
  <name>Task 2: Add tool call helpers to ScenarioBuilder</name>
  <files>tests/fake_claude/scenario.rs</files>
  <action>
Add tool call helper methods to ScenarioBuilder:

```rust
use serde_json::json;

impl ScenarioBuilder {
    // ... existing methods ...

    /// Add Read tool use to current invocation
    pub fn uses_read(mut self, path: &str) -> Self {
        let event = StreamEventOutput::tool_use("Read", json!({
            "file_path": path
        }));
        self.add_event(event);
        self
    }

    /// Add Write tool use to current invocation
    pub fn uses_write(mut self, path: &str, content: &str) -> Self {
        let event = StreamEventOutput::tool_use("Write", json!({
            "file_path": path,
            "content": content
        }));
        self.add_event(event);
        self
    }

    /// Add Edit tool use to current invocation
    pub fn uses_edit(mut self, path: &str, old_string: &str, new_string: &str) -> Self {
        let event = StreamEventOutput::tool_use("Edit", json!({
            "file_path": path,
            "old_string": old_string,
            "new_string": new_string
        }));
        self.add_event(event);
        self
    }

    /// Add Bash tool use to current invocation
    pub fn uses_bash(mut self, command: &str) -> Self {
        let event = StreamEventOutput::tool_use("Bash", json!({
            "command": command
        }));
        self.add_event(event);
        self
    }

    /// Add generic tool use (for less common tools or custom testing)
    pub fn uses_tool(mut self, name: &str, input: serde_json::Value) -> Self {
        let event = StreamEventOutput::tool_use(name, input);
        self.add_event(event);
        self
    }

    // Helper to add event to current invocation
    fn add_event(&mut self, event: StreamEventOutput) {
        if let Some(ref mut inv) = self.current_invocation {
            inv.events.push(event);
        }
    }
}
```
  </action>
  <verify>
- `cargo check --tests` succeeds
- ScenarioBuilder::new().uses_read("/test").uses_write("/out", "content").build() compiles
  </verify>
  <done>Tool call helpers exist with fluent API</done>
</task>

<task type="auto">
  <name>Task 3: Add edge case configuration methods</name>
  <files>tests/fake_claude/scenario.rs, tests/fake_claude/config.rs</files>
  <action>
Add edge case configuration to ScenarioBuilder:

```rust
impl ScenarioBuilder {
    // ... existing methods ...

    /// Configure delay between events (milliseconds)
    pub fn with_delay(mut self, delay_ms: u64) -> Self {
        if let Some(ref mut inv) = self.current_invocation {
            inv.delay_ms = Some(delay_ms);
        }
        self
    }

    /// Configure crash after N events (simulates process crash/timeout)
    pub fn crash_after(mut self, n: usize) -> Self {
        if let Some(ref mut inv) = self.current_invocation {
            inv.crash_after_events = Some(n);
        }
        self
    }

    /// Send raw JSON line (for malformed output testing)
    /// This is an escape hatch - use sparingly
    pub fn send_raw(mut self, raw_json: &str) -> Self {
        if let Some(ref mut inv) = self.current_invocation {
            inv.raw_lines.push(raw_json.to_string());
        }
        self
    }

    /// Configure exit code for this invocation
    pub fn with_exit_code(mut self, code: i32) -> Self {
        if let Some(ref mut inv) = self.current_invocation {
            inv.exit_code = Some(code);
        }
        self
    }
}
```

Update InvocationConfig in config.rs:
```rust
#[derive(Debug, Default, Serialize, Deserialize)]
pub struct InvocationConfig {
    pub events: Vec<StreamEventOutput>,
    #[serde(default)]
    pub raw_lines: Vec<String>,
    #[serde(default)]
    pub delay_ms: Option<u64>,
    #[serde(default)]
    pub crash_after_events: Option<usize>,
    #[serde(default)]
    pub exit_code: Option<i32>,
}
```

Update fake_claude.rs binary to handle these:
```rust
fn main() {
    // ... config loading ...

    let Some(inv_config) = config.invocations.get(invocation) else {
        return;
    };

    let mut events_output = 0;

    // Output raw lines first (for malformed output tests)
    for raw in &inv_config.raw_lines {
        println!("{}", raw);
        io::stdout().flush().unwrap();
    }

    for event in &inv_config.events {
        if let Some(delay) = inv_config.delay_ms {
            std::thread::sleep(std::time::Duration::from_millis(delay));
        }

        println!("{}", serde_json::to_string(&event).unwrap());
        io::stdout().flush().unwrap();
        events_output += 1;

        if inv_config.crash_after_events == Some(events_output) {
            std::process::exit(1);
        }
    }

    // Exit with configured code or 0
    std::process::exit(inv_config.exit_code.unwrap_or(0));
}
```
  </action>
  <verify>
- `cargo check --tests` succeeds
- ScenarioBuilder::new().respond_with_text("hi").crash_after(1).build() compiles
- `cargo build --tests` succeeds
  </verify>
  <done>Edge case configuration (delay, crash, raw output, exit code) works</done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests for tool calls and edge cases</name>
  <files>tests/fake_claude/scenario.rs</files>
  <action>
Add comprehensive unit tests for the scenario builder:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_scenario_with_text_response() {
        let handle = ScenarioBuilder::new()
            .respond_with_text("Hello, world!")
            .build();

        assert!(handle.config_path.exists());
        let config: FakeClaudeConfig = serde_json::from_str(
            &std::fs::read_to_string(&handle.config_path).unwrap()
        ).unwrap();

        assert_eq!(config.invocations.len(), 1);
        assert_eq!(config.invocations[0].events.len(), 1);
    }

    #[test]
    fn test_scenario_with_tool_calls() {
        let handle = ScenarioBuilder::new()
            .uses_read("/path/to/file")
            .uses_write("/output", "content")
            .uses_edit("/edit", "old", "new")
            .uses_bash("echo hello")
            .build();

        let config: FakeClaudeConfig = serde_json::from_str(
            &std::fs::read_to_string(&handle.config_path).unwrap()
        ).unwrap();

        assert_eq!(config.invocations[0].events.len(), 4);
    }

    #[test]
    fn test_multi_invocation() {
        let handle = ScenarioBuilder::new()
            .respond_with_text("First response")
            .next_invocation()
            .respond_with_text("Second response")
            .next_invocation()
            .respond_with_text("Third response")
            .build();

        let config: FakeClaudeConfig = serde_json::from_str(
            &std::fs::read_to_string(&handle.config_path).unwrap()
        ).unwrap();

        assert_eq!(config.invocations.len(), 3);
    }

    #[test]
    fn test_edge_case_delay() {
        let handle = ScenarioBuilder::new()
            .respond_with_text("Slow response")
            .with_delay(100)
            .build();

        let config: FakeClaudeConfig = serde_json::from_str(
            &std::fs::read_to_string(&handle.config_path).unwrap()
        ).unwrap();

        assert_eq!(config.invocations[0].delay_ms, Some(100));
    }

    #[test]
    fn test_edge_case_crash() {
        let handle = ScenarioBuilder::new()
            .respond_with_text("Will crash")
            .crash_after(1)
            .build();

        let config: FakeClaudeConfig = serde_json::from_str(
            &std::fs::read_to_string(&handle.config_path).unwrap()
        ).unwrap();

        assert_eq!(config.invocations[0].crash_after_events, Some(1));
    }

    #[test]
    fn test_raw_output() {
        let handle = ScenarioBuilder::new()
            .send_raw("not valid json at all")
            .build();

        let config: FakeClaudeConfig = serde_json::from_str(
            &std::fs::read_to_string(&handle.config_path).unwrap()
        ).unwrap();

        assert_eq!(config.invocations[0].raw_lines.len(), 1);
        assert_eq!(config.invocations[0].raw_lines[0], "not valid json at all");
    }

    #[test]
    fn test_invocation_counter() {
        let handle = ScenarioBuilder::new()
            .respond_with_text("First")
            .next_invocation()
            .respond_with_text("Second")
            .build();

        // Initially 0
        assert_eq!(handle.invocation_count(), 0);

        // After incrementing (simulate what binary does)
        std::fs::write(&handle.counter_path, "1").unwrap();
        assert_eq!(handle.invocation_count(), 1);
    }

    #[test]
    fn test_generic_tool() {
        let handle = ScenarioBuilder::new()
            .uses_tool("CustomTool", json!({"custom_field": "value"}))
            .build();

        let config: FakeClaudeConfig = serde_json::from_str(
            &std::fs::read_to_string(&handle.config_path).unwrap()
        ).unwrap();

        assert_eq!(config.invocations[0].events.len(), 1);
    }
}
```
  </action>
  <verify>
- `cargo test fake_claude::scenario::tests` passes
- All edge case scenarios can be configured
  </verify>
  <done>Unit tests verify tool calls and edge case configuration</done>
</task>

</tasks>

<verification>
All verification:
- `cargo check --tests` passes
- `cargo test fake_claude::` passes
- Tool call events serialize to correct JSON format
- Edge cases (delay, crash, raw) are properly configured
- Multi-invocation scenarios work correctly
</verification>

<success_criteria>
- uses_read, uses_write, uses_edit, uses_bash all generate correct JSON
- crash_after causes early exit in binary
- with_delay adds sleep between events
- send_raw outputs literal string (for malformed tests)
- Multi-invocation with next_invocation() chains correctly
</success_criteria>

<output>
After completion, create `.planning/phases/07-e2e-testing-framework/07-03-SUMMARY.md`
</output>
