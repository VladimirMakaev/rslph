---
phase: 07-e2e-testing-framework
plan: 05
type: execute
wave: 4
depends_on: ["07-04"]
files_modified:
  - tests/e2e/test_rslph_integration.rs
  - tests/e2e/mod.rs
autonomous: true

must_haves:
  truths:
    - "rslph build runs with fake Claude and completes successfully"
    - "Tasks are marked complete in PROGRESS.md after fake Claude simulates work"
    - "Multiple iterations work correctly with multi-invocation scenarios"
    - "Error handling works when fake Claude crashes"
    - "RALPH_DONE marker appears when all tasks complete"
  artifacts:
    - path: "tests/e2e/test_rslph_integration.rs"
      provides: "True E2E integration tests running rslph with fake Claude"
      min_lines: 100
  key_links:
    - from: "tests/e2e/test_rslph_integration.rs"
      to: "rslph binary"
      via: "assert_cmd invokes rslph with RSLPH_CLAUDE_PATH or workspace config"
      pattern: "Command::cargo_bin.*rslph"
    - from: "tests/e2e/test_rslph_integration.rs"
      to: "tests/fake_claude/scenario.rs"
      via: "scenarios configure fake Claude responses"
      pattern: "ScenarioBuilder::new"
    - from: "tests/e2e/test_rslph_integration.rs"
      to: "tests/e2e/fixtures.rs"
      via: "workspaces provide isolated test environment"
      pattern: "WorkspaceBuilder::new"
---

<objective>
Create true E2E integration tests that run rslph with fake Claude.

Purpose: Verify the complete Ralph Wiggum Loop works end-to-end by running the actual rslph binary with fake Claude, checking that tasks get marked complete, files get created, and the loop terminates correctly.

Output: Integration tests that prove rslph works correctly with simulated Claude responses.

Note: This plan closes the integration gap identified in verification. The mechanism is RSLPH_CLAUDE_PATH env var (already supported by rslph config) or workspace .rslph/config.toml with custom claude_path.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-e2e-testing-framework/07-RESEARCH.md

# Prior plan artifacts
# @.planning/phases/07-e2e-testing-framework/07-04-SUMMARY.md

# Key source files - understand how rslph invokes Claude
@src/config.rs
@src/build/command.rs
@src/subprocess/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update e2e module for integration tests</name>
  <files>tests/e2e/mod.rs</files>
  <action>
Update tests/e2e/mod.rs to include the integration test module:

```rust
pub mod fixtures;
pub mod helpers;

// Test modules
mod test_basic_loop;
mod test_edge_cases;
mod test_rslph_integration;  // NEW: True E2E integration tests

pub use fixtures::{Workspace, WorkspaceBuilder};
pub use helpers::*;
```

This module will contain tests that actually invoke the `rslph` binary.
  </action>
  <verify>
- `cargo check --tests` succeeds
- Module structure compiles
  </verify>
  <done>E2E module includes integration test module</done>
</task>

<task type="auto">
  <name>Task 2: Create rslph integration tests</name>
  <files>tests/e2e/test_rslph_integration.rs</files>
  <action>
Create test_rslph_integration.rs with TRUE end-to-end tests that run rslph with fake Claude.

The key mechanism: Set RSLPH_CLAUDE_PATH env var to point to fake Claude binary. The rslph config loader already supports this via `Env::prefixed("RSLPH_")`.

```rust
//! True E2E integration tests that run rslph with fake Claude
//!
//! These tests invoke the actual rslph binary, configured to use fake Claude,
//! and verify the complete build loop works correctly.

use crate::e2e::{WorkspaceBuilder, assert_task_complete, assert_ralph_done, assert_file_contains};
use crate::fake_claude::ScenarioBuilder;
use assert_cmd::Command;
use std::time::Duration;

/// Helper to get rslph command configured with fake Claude
fn rslph_with_fake_claude(scenario: &crate::fake_claude::FakeClaudeHandle) -> Command {
    let mut cmd = Command::cargo_bin("rslph").expect("rslph binary should exist");
    // Set RSLPH_CLAUDE_PATH to use fake Claude binary
    cmd.env("RSLPH_CLAUDE_PATH", &scenario.executable_path);
    // Set FAKE_CLAUDE_CONFIG for the fake Claude binary to read
    cmd.env("FAKE_CLAUDE_CONFIG", &scenario.config_path);
    cmd
}

#[test]
fn test_rslph_build_single_iteration_success() {
    // Scenario: Claude marks a task complete in first iteration
    let scenario = ScenarioBuilder::new()
        .respond_with_text("I'll complete Task 1")
        .uses_bash("echo 'Working on Task 1'")
        // Simulate marking task complete by editing PROGRESS.md
        .uses_edit("PROGRESS.md", "- [ ] Task 1", "- [x] Task 1")
        .respond_with_text("Task 1 is complete!")
        .with_result(0.02)
        .build();

    let workspace = WorkspaceBuilder::new()
        .with_progress_file("# Progress\n\n- [ ] Task 1\n")
        .build();

    let mut cmd = rslph_with_fake_claude(&scenario);
    cmd.arg("build")
       .arg("--max-iterations").arg("1")
       .arg("--no-tui")  // Disable TUI for CI/test environment
       .current_dir(workspace.path());

    let output = cmd.output().expect("Failed to run rslph");

    // rslph should succeed (or exit after iteration limit)
    // Check that fake Claude was invoked
    assert_eq!(scenario.invocation_count(), 1);
}

#[test]
fn test_rslph_build_multi_iteration_completes_all_tasks() {
    // Scenario: Two tasks, Claude completes one per iteration
    let scenario = ScenarioBuilder::new()
        // First iteration: Complete Task 1
        .respond_with_text("Working on Task 1")
        .uses_edit("PROGRESS.md", "- [ ] Task 1", "- [x] Task 1")
        .with_result(0.02)
        .next_invocation()
        // Second iteration: Complete Task 2, add RALPH_DONE
        .respond_with_text("Working on Task 2")
        .uses_edit("PROGRESS.md", "- [ ] Task 2", "- [x] Task 2\n\nRALPH_DONE")
        .with_result(0.02)
        .build();

    let workspace = WorkspaceBuilder::new()
        .with_progress_file("# Progress\n\n- [ ] Task 1\n- [ ] Task 2\n")
        .build();

    let mut cmd = rslph_with_fake_claude(&scenario);
    cmd.arg("build")
       .arg("--max-iterations").arg("5")
       .arg("--no-tui")
       .current_dir(workspace.path());

    let output = cmd.output().expect("Failed to run rslph");

    // Should have invoked Claude twice
    assert!(
        scenario.invocation_count() >= 2,
        "Expected at least 2 invocations, got {}",
        scenario.invocation_count()
    );
}

#[test]
fn test_rslph_build_stops_at_ralph_done() {
    // Scenario: Claude adds RALPH_DONE immediately
    let scenario = ScenarioBuilder::new()
        .respond_with_text("All done!")
        .uses_edit("PROGRESS.md", "- [ ] Task 1", "- [x] Task 1\n\nRALPH_DONE")
        .with_result(0.01)
        .next_invocation()
        // This should NOT be reached
        .respond_with_text("This should not happen")
        .build();

    let workspace = WorkspaceBuilder::new()
        .with_progress_file("# Progress\n\n- [ ] Task 1\n")
        .build();

    let mut cmd = rslph_with_fake_claude(&scenario);
    cmd.arg("build")
       .arg("--max-iterations").arg("10")
       .arg("--no-tui")
       .current_dir(workspace.path());

    cmd.output().expect("Failed to run rslph");

    // Should stop after first iteration due to RALPH_DONE
    assert_eq!(
        scenario.invocation_count(), 1,
        "Expected exactly 1 invocation (should stop at RALPH_DONE)"
    );
}

#[test]
fn test_rslph_build_handles_claude_crash() {
    // Scenario: Claude crashes mid-response
    let scenario = ScenarioBuilder::new()
        .respond_with_text("Starting work...")
        .crash_after(1)  // Crash after first event
        .build();

    let workspace = WorkspaceBuilder::new()
        .with_progress_file("# Progress\n\n- [ ] Task 1\n")
        .build();

    let mut cmd = rslph_with_fake_claude(&scenario);
    cmd.arg("build")
       .arg("--max-iterations").arg("1")
       .arg("--no-tui")
       .current_dir(workspace.path());

    let output = cmd.output().expect("Failed to run rslph");

    // rslph should handle the crash gracefully (not panic)
    // It may exit with error, but should not crash
    // The main assertion is that we get here without the test framework crashing
    assert!(true, "rslph handled Claude crash without panicking");
}

#[test]
fn test_rslph_build_creates_files() {
    // Scenario: Claude creates a new file
    let scenario = ScenarioBuilder::new()
        .respond_with_text("Creating output.txt")
        .uses_write("output.txt", "Hello from fake Claude!")
        .uses_edit("PROGRESS.md", "- [ ] Create file", "- [x] Create file\n\nRALPH_DONE")
        .with_result(0.01)
        .build();

    let workspace = WorkspaceBuilder::new()
        .with_progress_file("# Progress\n\n- [ ] Create file\n")
        .build();

    let mut cmd = rslph_with_fake_claude(&scenario);
    cmd.arg("build")
       .arg("--max-iterations").arg("3")
       .arg("--no-tui")
       .current_dir(workspace.path());

    cmd.output().expect("Failed to run rslph");

    // Note: The fake Claude uses_write doesn't actually create files -
    // it just outputs the tool call JSON. The real rslph would execute it.
    // This test verifies the integration flow, not actual file creation.
    assert_eq!(scenario.invocation_count(), 1);
}

#[test]
fn test_rslph_build_respects_max_iterations() {
    // Scenario: Claude never adds RALPH_DONE
    let scenario = ScenarioBuilder::new()
        .respond_with_text("Still working...")
        .with_result(0.01)
        .next_invocation()
        .respond_with_text("Still working...")
        .with_result(0.01)
        .next_invocation()
        .respond_with_text("Still working...")
        .with_result(0.01)
        .next_invocation()
        .respond_with_text("Still working...")
        .with_result(0.01)
        .build();

    let workspace = WorkspaceBuilder::new()
        .with_progress_file("# Progress\n\n- [ ] Never-ending task\n")
        .build();

    let mut cmd = rslph_with_fake_claude(&scenario);
    cmd.arg("build")
       .arg("--max-iterations").arg("2")  // Limit to 2
       .arg("--no-tui")
       .current_dir(workspace.path());

    cmd.output().expect("Failed to run rslph");

    // Should stop at max_iterations, not continue forever
    assert!(
        scenario.invocation_count() <= 2,
        "Expected at most 2 invocations, got {}",
        scenario.invocation_count()
    );
}

#[test]
fn test_rslph_build_with_workspace_config() {
    // Alternative approach: Use workspace .rslph/config.toml instead of env var
    let scenario = ScenarioBuilder::new()
        .respond_with_text("Using config file path")
        .uses_edit("PROGRESS.md", "- [ ] Task 1", "- [x] Task 1\n\nRALPH_DONE")
        .with_result(0.01)
        .build();

    // Create workspace with custom config pointing to fake Claude
    let config_toml = format!(
        r#"[rslph]
claude_path = "{}"
max_iterations = 3
tui_enabled = false
"#,
        scenario.executable_path.display()
    );

    let workspace = WorkspaceBuilder::new()
        .with_config(&config_toml)
        .with_progress_file("# Progress\n\n- [ ] Task 1\n")
        .build();

    let mut cmd = Command::cargo_bin("rslph").expect("rslph binary should exist");
    // Only set FAKE_CLAUDE_CONFIG, NOT RSLPH_CLAUDE_PATH
    // rslph should read claude_path from workspace config
    cmd.env("FAKE_CLAUDE_CONFIG", &scenario.config_path)
       .arg("build")
       .current_dir(workspace.path());

    cmd.output().expect("Failed to run rslph");

    assert_eq!(scenario.invocation_count(), 1);
}
```
  </action>
  <verify>
- `cargo test e2e::test_rslph_integration --` passes
- All integration tests run rslph with fake Claude
- Tests verify iteration counts, RALPH_DONE detection, error handling
  </verify>
  <done>True E2E integration tests verify rslph works with fake Claude</done>
</task>

<task type="auto">
  <name>Task 3: Add --no-tui flag support verification</name>
  <files>tests/e2e/test_rslph_integration.rs</files>
  <action>
Verify that the `--no-tui` flag exists or add tests that work with TUI disabled via config.

Check if rslph already has `--no-tui` flag:
1. Look at `src/cli.rs` or `src/main.rs` for CLI argument definitions
2. If `--no-tui` doesn't exist, tests should use `tui_enabled = false` in config

Update tests to use the correct mechanism for disabling TUI in test environment:

```rust
// Add at top of test file
#[cfg(test)]
fn workspace_with_tui_disabled(progress: &str) -> crate::e2e::Workspace {
    WorkspaceBuilder::new()
        .with_config(r#"[rslph]
tui_enabled = false
"#)
        .with_progress_file(progress)
        .build()
}

// Alternative: If --no-tui exists, use it directly in cmd.arg("--no-tui")
// If not, ensure config has tui_enabled = false
```

Add a test that verifies TUI-disabled mode works:

```rust
#[test]
fn test_rslph_build_tui_disabled_via_config() {
    let scenario = ScenarioBuilder::new()
        .respond_with_text("Working without TUI")
        .uses_edit("PROGRESS.md", "- [ ] Task", "- [x] Task\n\nRALPH_DONE")
        .with_result(0.01)
        .build();

    let config_toml = format!(
        r#"[rslph]
claude_path = "{}"
tui_enabled = false
"#,
        scenario.executable_path.display()
    );

    let workspace = WorkspaceBuilder::new()
        .with_config(&config_toml)
        .with_progress_file("# Progress\n\n- [ ] Task\n")
        .build();

    let mut cmd = Command::cargo_bin("rslph").expect("rslph binary should exist");
    cmd.env("FAKE_CLAUDE_CONFIG", &scenario.config_path)
       .arg("build")
       .arg("--max-iterations").arg("1")
       .current_dir(workspace.path());

    let output = cmd.output().expect("Failed to run rslph");

    // Should run without TUI (important for CI/headless testing)
    assert_eq!(scenario.invocation_count(), 1);
}
```
  </action>
  <verify>
- Tests run successfully in headless environment
- TUI is properly disabled for all integration tests
  </verify>
  <done>Integration tests work in headless CI environment with TUI disabled</done>
</task>

</tasks>

<verification>
All verification:
- `cargo test e2e::test_rslph_integration --` passes
- `cargo test e2e::` passes (all E2E tests including new integration tests)
- Tests run successfully in CI (headless) environment
- rslph correctly uses fake Claude via RSLPH_CLAUDE_PATH or config
</verification>

<success_criteria>
- rslph build command runs with fake Claude
- RSLPH_CLAUDE_PATH env var correctly overrides claude_path
- Workspace config claude_path correctly points to fake Claude
- Tests verify iteration counting, RALPH_DONE detection, crash handling
- Tests work in headless environment (TUI disabled)
- Integration gap from verification is closed
</success_criteria>

<output>
After completion, create `.planning/phases/07-e2e-testing-framework/07-05-SUMMARY.md`
</output>
