# Phase 7.1: TUI Testing with ratatui-testlib - Research

**Researched:** 2026-01-19
**Domain:** TUI testing, ratatui, snapshot testing
**Confidence:** HIGH

## Summary

This research investigates how to implement TUI-specific tests for the rslph application using ratatui's testing capabilities combined with insta snapshot testing. The codebase uses ratatui 0.30 for its terminal UI with crossterm as the backend.

**Key finding:** ratatui-testlib (v0.1.0) is a PTY-based testing library designed for integration testing with actual terminal emulation. However, for our use case of visual snapshot testing without actual terminal interaction, ratatui's built-in `TestBackend` combined with `insta` provides a simpler, more appropriate solution.

**Primary recommendation:** Use ratatui's `TestBackend` with insta `assert_snapshot!` for visual rendering tests, and construct `App` state directly with simulated events for input testing. Do NOT use ratatui-testlib since PTY-based testing is overkill for snapshot verification.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| ratatui | 0.30 | TUI framework | Already in use, has TestBackend for testing |
| insta | 1 | Snapshot testing | Already in dev-deps, provides assert_snapshot! |
| crossterm | 0.29 | Terminal abstraction | Already in use, provides KeyEvent for input simulation |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| cargo-insta | latest | Snapshot review CLI | Review/accept snapshot changes |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| TestBackend + insta | ratatui-testlib | ratatui-testlib is PTY-based, designed for testing actual terminal behavior (escape sequences, sixel graphics). Our needs are simpler - just verify rendered output matches expected. TestBackend is faster, simpler, doesn't require PTY. |
| insta | Manual Buffer comparison | insta provides snapshot file management, review workflow, better diffs. Manual comparison is more tedious. |

**Installation:**
```bash
# Already installed - insta is in dev-dependencies
# Only need to install cargo-insta for snapshot review workflow
cargo install cargo-insta
```

## Architecture Patterns

### Recommended Project Structure
```
tests/
  e2e/
    main.rs               # Existing E2E entry point
    tui_tests.rs          # NEW: TUI snapshot test module
    snapshots/            # NEW: TUI snapshot files
      tui_tests__*.snap
    fixtures.rs           # Existing - reuse for TUI tests
  fake_claude_lib/        # Existing - reuse for deterministic data
```

### Pattern 1: TestBackend Snapshot Testing

**What:** Create Terminal with TestBackend, render app state, snapshot the buffer
**When to use:** Visual verification of TUI rendering
**Example:**
```rust
// Source: ratatui official docs + insta docs
use ratatui::{backend::TestBackend, Terminal};
use insta::assert_snapshot;

#[test]
fn test_main_screen_render() {
    // Create test terminal with fixed dimensions
    let backend = TestBackend::new(80, 24);
    let mut terminal = Terminal::new(backend).unwrap();

    // Set up app state
    let mut app = App::new(10, "claude-sonnet-4-20250514", "test-project");
    app.current_iteration = 1;
    app.viewing_iteration = 1;
    // Add test data...

    // Render
    terminal.draw(|frame| render(frame, &app, 10)).unwrap();

    // Snapshot the backend (implements Display)
    assert_snapshot!(terminal.backend());
}
```

### Pattern 2: Programmatic Key Event Simulation

**What:** Create KeyEvent instances directly, pass through handle_event
**When to use:** Testing keyboard input handling
**Example:**
```rust
// Source: crossterm docs + project's keybindings.rs
use crossterm::event::{KeyCode, KeyEvent, KeyModifiers, KeyEventKind, KeyEventState};
use crate::tui::app::{App, AppEvent};
use crate::tui::keybindings::handle_event;

#[test]
fn test_quit_key() {
    let mut app = App::default();

    // Send 'q' key - result should be Quit
    let quit = handle_event(&mut app, AppEvent::Quit, 20);
    assert!(quit);
    assert!(app.should_quit);
}

#[test]
fn test_scroll_keys() {
    let mut app = App::default();
    app.scroll_offset = 5;

    handle_event(&mut app, AppEvent::ScrollUp, 20);
    assert_eq!(app.scroll_offset, 4);

    handle_event(&mut app, AppEvent::ScrollDown, 20);
    assert_eq!(app.scroll_offset, 5);
}
```

### Pattern 3: State-Based Testing (No Real Events)

**What:** Construct App state directly, update via AppEvent, verify state changes
**When to use:** Testing state transitions and business logic
**Example:**
```rust
// Source: project's existing app.rs tests
#[test]
fn test_iteration_navigation() {
    let mut app = App::new(10, "model", "project");
    app.current_iteration = 3;
    app.viewing_iteration = 3;

    app.update(AppEvent::PrevIteration);
    assert_eq!(app.viewing_iteration, 2);

    app.update(AppEvent::NextIteration);
    assert_eq!(app.viewing_iteration, 3);
}
```

### Anti-Patterns to Avoid
- **Using real terminal in tests:** Don't call init_terminal() in tests - it requires a TTY and is not reproducible
- **PTY-based testing for simple snapshot:** ratatui-testlib adds complexity we don't need
- **Testing raw crossterm events:** Use AppEvent abstraction instead of low-level KeyEvent for most tests
- **Hardcoding terminal sizes inconsistently:** Always use the same dimensions (80x24) for reproducible snapshots

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Snapshot management | Custom file comparison | insta crate | Handles snapshot files, diffs, review workflow |
| Buffer to string | Manual cell iteration | TestBackend Display impl | TestBackend implements Display, works with assert_snapshot! |
| Event simulation | Mock crossterm EventStream | AppEvent enum | App already uses AppEvent abstraction - just construct events directly |
| Deterministic data | Real timestamps | Fake Claude + fixed App state | Already have ScenarioBuilder for deterministic test data |

**Key insight:** The existing TUI code already has good abstractions (AppEvent, App::update()) that make testing straightforward. Don't bypass these abstractions with lower-level testing.

## Common Pitfalls

### Pitfall 1: Terminal Size Inconsistency
**What goes wrong:** Snapshots differ between developers/CI due to different terminal dimensions
**Why it happens:** TestBackend uses specified dimensions, but if these vary, layout changes
**How to avoid:** Always use fixed dimensions: `TestBackend::new(80, 24)` for all tests
**Warning signs:** Snapshots failing on CI but passing locally

### Pitfall 2: Style/Color Information Loss
**What goes wrong:** Snapshots only capture text, not colors
**Why it happens:** TestBackend's Display impl doesn't include ANSI codes (intentionally, for readability)
**How to avoid:** For style verification, use assert_debug_snapshot! on CompletedFrame or test specific style values in unit tests
**Warning signs:** Tests pass but visual styling is wrong
**Note:** This is a known ratatui limitation (see [issue #1402](https://github.com/ratatui/ratatui/issues/1402))

### Pitfall 3: Trying to Test Real Terminal Behavior
**What goes wrong:** Tests become flaky or require complex setup
**Why it happens:** Attempting to test with actual PTY, raw mode, etc.
**How to avoid:** Use TestBackend exclusively for TUI tests. The real terminal behavior is tested manually.
**Warning signs:** Tests requiring TTY, failing in CI

### Pitfall 4: Not Resetting App State Between Tests
**What goes wrong:** Tests affect each other, order-dependent failures
**Why it happens:** Reusing App instance across tests
**How to avoid:** Create fresh App::default() or App::new() in each test
**Warning signs:** Tests pass individually but fail when run together

### Pitfall 5: Snapshot Path Configuration
**What goes wrong:** Snapshots saved in wrong location, not found by cargo-insta
**Why it happens:** Insta uses default path relative to test file
**How to avoid:** Keep snapshots in `tests/e2e/snapshots/` adjacent to test files, or use `Settings::set_snapshot_path()`
**Warning signs:** Snapshot files appearing in unexpected locations

## Code Examples

Verified patterns from official sources:

### Rendering Snapshot Test
```rust
// Source: ratatui docs + insta docs
use ratatui::{backend::TestBackend, Terminal};
use insta::assert_snapshot;

#[test]
fn test_initial_render() {
    let backend = TestBackend::new(80, 24);
    let mut terminal = Terminal::new(backend).unwrap();

    let app = App::new(5, "claude-sonnet-4-20250514", "my-project");

    terminal.draw(|frame| render(frame, &app, 10)).unwrap();

    // TestBackend implements Display - outputs buffer content
    assert_snapshot!(terminal.backend());
}
```

### Testing Key Navigation
```rust
// Source: project's keybindings.rs pattern
use crate::tui::app::{App, AppEvent};
use crate::tui::keybindings::handle_event;

#[test]
fn test_scroll_navigation() {
    let mut app = App::default();
    app.viewing_iteration = 1;
    app.current_iteration = 1;
    app.scroll_offset = 10;

    // Scroll up
    handle_event(&mut app, AppEvent::ScrollUp, 20);
    assert_eq!(app.scroll_offset, 9);

    // Scroll down
    handle_event(&mut app, AppEvent::ScrollDown, 20);
    assert_eq!(app.scroll_offset, 10);
}
```

### Testing with App Events
```rust
// Source: project's existing app.rs tests
use crate::tui::app::{App, AppEvent, Message, MessageRole};

#[test]
fn test_claude_output_adds_message() {
    let mut app = App::default();
    app.current_iteration = 1;

    app.update(AppEvent::ClaudeOutput("Hello, world!".to_string()));

    assert_eq!(app.messages.len(), 1);
    assert_eq!(app.messages[0].role, MessageRole::Assistant);
    assert_eq!(app.messages[0].content, "Hello, world!");
}
```

### Snapshot with Populated State
```rust
// Source: combining patterns from ratatui docs and project code
#[test]
fn test_with_messages_render() {
    let backend = TestBackend::new(80, 24);
    let mut terminal = Terminal::new(backend).unwrap();

    let mut app = App::new(5, "claude-sonnet-4", "project");
    app.current_iteration = 1;
    app.viewing_iteration = 1;

    // Simulate receiving Claude output
    app.update(AppEvent::IterationStart { iteration: 1 });
    app.update(AppEvent::ToolMessage {
        tool_name: "Read".to_string(),
        content: "file.rs contents".to_string(),
    });
    app.update(AppEvent::ClaudeOutput("I read the file.".to_string()));

    terminal.draw(|frame| render(frame, &app, 10)).unwrap();

    assert_snapshot!("with_messages", terminal.backend());
}
```

### Setting Custom Snapshot Path
```rust
// Source: insta docs
use insta::Settings;

#[test]
fn test_with_custom_path() {
    let mut settings = Settings::clone_current();
    settings.set_snapshot_path("snapshots");
    settings.bind(|| {
        // Tests here will save snapshots to tests/e2e/snapshots/
        assert_snapshot!("my_test", "value");
    });
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual Buffer assertions | TestBackend + insta | ratatui 0.26+ | Much simpler test code |
| PTY-based testing for all cases | TestBackend for rendering, PTY only for terminal behavior | Ongoing | Simpler tests, faster execution |

**Deprecated/outdated:**
- `assert_buffer_lines` was added recently but insta snapshots are more maintainable
- ratatui-testlib is still in early development (v0.1.0) - use TestBackend for now

## Open Questions

Things that couldn't be fully resolved:

1. **Color/Style Snapshot Testing**
   - What we know: TestBackend Display doesn't include styles. Debug format includes styles but is verbose.
   - What's unclear: Best practice for verifying colors render correctly
   - Recommendation: For Phase 7.1, accept text-only snapshots. Style correctness verified manually. Could add specific style assertions in unit tests if needed.

2. **Integration with Fake Claude for Full E2E**
   - What we know: ScenarioBuilder can set up deterministic Claude responses. TUI tests need populated state.
   - What's unclear: Exact integration pattern (run rslph with fake Claude and capture TUI vs. construct App state directly)
   - Recommendation: Start with direct App state construction for TUI tests. Full E2E with real process spawning is more complex and may not be needed for Phase 7.1.

## Sources

### Primary (HIGH confidence)
- [ratatui 0.30 TestBackend docs](https://docs.rs/ratatui/0.30.0/ratatui/backend/struct.TestBackend.html) - Complete API reference
- [ratatui snapshot testing recipe](https://ratatui.rs/recipes/testing/snapshots/) - Official testing guide
- [crossterm KeyEvent docs](https://docs.rs/crossterm/latest/crossterm/event/struct.KeyEvent.html) - Input event structure
- [insta docs](https://insta.rs/docs/) - Snapshot testing framework
- Project source code: src/tui/*.rs - Existing TUI implementation

### Secondary (MEDIUM confidence)
- [GitHub discussion #1381](https://github.com/ratatui/ratatui/discussions/1381) - Community patterns for insta + ratatui
- [GitHub issue #1402](https://github.com/ratatui/ratatui/issues/1402) - Color assertion limitations

### Tertiary (LOW confidence)
- [ratatui-testlib on crates.io](https://crates.io/crates/ratatui-testlib) - PTY-based testing (not recommended for our use case)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using already-included libraries (ratatui, insta, crossterm)
- Architecture: HIGH - Patterns directly from official docs and existing project code
- Pitfalls: HIGH - Based on official docs and verified community issues

**Research date:** 2026-01-19
**Valid until:** 60 days (ratatui is stable, patterns unlikely to change significantly)
