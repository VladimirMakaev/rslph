---
phase: 08-token-tracking
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tui/app.rs
  - src/tui/widgets/status_bar.rs
  - src/planning/command.rs
autonomous: true

must_haves:
  truths:
    - "User sees token counts in TUI status bar during build"
    - "User sees token counts in iteration summary"
    - "Plan command reports token consumption at completion"
  artifacts:
    - path: "src/tui/app.rs"
      provides: "AppEvent::TokenUsage and App.total_tokens field"
      contains: "TokenUsage"
    - path: "src/tui/widgets/status_bar.rs"
      provides: "Token display in status bar"
      contains: "format_tokens"
  key_links:
    - from: "src/tui/app.rs"
      to: "src/build/tokens.rs"
      via: "TokenUsage type import"
      pattern: "use.*tokens::TokenUsage"
    - from: "src/tui/widgets/status_bar.rs"
      to: "src/build/tokens.rs"
      via: "format_tokens function"
      pattern: "format_tokens"
---

<objective>
Add token display to TUI status bar and plan command output.

Purpose: Users can observe token consumption during plan/build execution (visible feedback for TOK-01, TOK-02).

Output: Status bar shows "In: X | Out: Y | CacheW: Z | CacheR: W", plan command prints token totals.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-token-tracking/CONTEXT.md
@.planning/phases/08-token-tracking/RESEARCH.md
@src/tui/app.rs
@src/tui/widgets/status_bar.rs
@src/planning/command.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add token state to App and handle TokenUsage events</name>
  <files>src/tui/app.rs</files>
  <action>
1. Add import at top of file:
   ```rust
   use crate::build::tokens::TokenUsage;
   ```

2. Add new variant to AppEvent enum:
   ```rust
   /// Token usage update from build loop
   TokenUsage {
       input_tokens: u64,
       output_tokens: u64,
       cache_creation_input_tokens: u64,
       cache_read_input_tokens: u64,
   },
   ```

3. Add field to App struct (in the "Status bar state" section):
   ```rust
   /// Cumulative token usage across all iterations
   pub total_tokens: TokenUsage,
   ```

4. Initialize in Default impl:
   ```rust
   total_tokens: TokenUsage::default(),
   ```

5. Handle AppEvent::TokenUsage in the update method:
   ```rust
   AppEvent::TokenUsage { input_tokens, output_tokens, cache_creation_input_tokens, cache_read_input_tokens } => {
       // Accumulate tokens (events are incremental updates)
       self.total_tokens.input_tokens = input_tokens;
       self.total_tokens.output_tokens = output_tokens;
       self.total_tokens.cache_creation_input_tokens = cache_creation_input_tokens;
       self.total_tokens.cache_read_input_tokens = cache_read_input_tokens;
   }
   ```
   Note: Token events from stream contain cumulative values per message, not deltas. We overwrite with latest.

6. Add test for TokenUsage event handling:
   ```rust
   #[test]
   fn test_app_update_token_usage() {
       let mut app = App::default();

       app.update(AppEvent::TokenUsage {
           input_tokens: 5000,
           output_tokens: 1500,
           cache_creation_input_tokens: 2000,
           cache_read_input_tokens: 1000,
       });

       assert_eq!(app.total_tokens.input_tokens, 5000);
       assert_eq!(app.total_tokens.output_tokens, 1500);
       assert_eq!(app.total_tokens.cache_creation_input_tokens, 2000);
       assert_eq!(app.total_tokens.cache_read_input_tokens, 1000);
   }
   ```
  </action>
  <verify>`cargo test --lib tui::app` passes</verify>
  <done>App has total_tokens field and handles TokenUsage events</done>
</task>

<task type="auto">
  <name>Task 2: Display tokens in TUI status bar</name>
  <files>src/tui/widgets/status_bar.rs</files>
  <action>
1. Add import at top:
   ```rust
   use crate::build::tokens::format_tokens;
   ```

2. Modify `render_status_line` function to include token counts.

   Change the status_text format from:
   ```rust
   let status_text = format!(
       "Iter {}/{} | Task {}/{} | ",
       app.current_iteration, app.max_iterations, app.current_task, app.total_tasks
   );
   ```

   To include token counts (per CONTEXT.md decision - abbreviated format):
   ```rust
   let status_text = format!(
       "Iter {}/{} | Task {}/{} | In: {} | Out: {} | CacheW: {} | CacheR: {} | ",
       app.current_iteration,
       app.max_iterations,
       app.current_task,
       app.total_tasks,
       format_tokens(app.total_tokens.input_tokens),
       format_tokens(app.total_tokens.output_tokens),
       format_tokens(app.total_tokens.cache_creation_input_tokens),
       format_tokens(app.total_tokens.cache_read_input_tokens),
   );
   ```

3. If status bar width becomes a concern (narrow terminals), consider shorter format:
   ```rust
   // Alternative compact format (if needed):
   // "I:{} O:{} CW:{} CR:{}"
   ```
   Start with full labels per CONTEXT.md, can abbreviate later if needed.
  </action>
  <verify>`cargo check` passes; visually verify status bar renders correctly</verify>
  <done>Status bar displays token counts in "In: X | Out: Y | CacheW: Z | CacheR: W" format</done>
</task>

<task type="auto">
  <name>Task 3: Add token reporting to plan command</name>
  <files>src/planning/command.rs</files>
  <action>
1. Add import at top:
   ```rust
   use crate::build::tokens::format_tokens;
   ```

2. In `run_basic_planning`, after the existing TRACE logs for tokens (around line 112-115):
   ```rust
   eprintln!(
       "[TRACE] Tokens: {} in / {} out",
       stream_response.input_tokens, stream_response.output_tokens
   );
   ```

   Enhance to include cache tokens and use format_tokens for human-readable output:
   ```rust
   // Display token summary for user
   println!(
       "Tokens used: In: {} | Out: {} | CacheW: {} | CacheR: {}",
       format_tokens(stream_response.input_tokens),
       format_tokens(stream_response.output_tokens),
       format_tokens(stream_response.cache_creation_input_tokens),
       format_tokens(stream_response.cache_read_input_tokens),
   );
   ```

   Note: This requires StreamResponse to have cache token fields (added in Plan 01).

3. Do the same in `run_adaptive_planning` after the final Claude call (around line 332).

4. Also update `run_claude_headless` to return token info if needed for adaptive mode's intermediate calls.
   For now, focus on final planning output - the intermediate calls' tokens are less critical.

5. If StreamResponse doesn't have cache fields yet (Plan 01 not complete), use 0 as placeholder:
   ```rust
   // Temporary until Plan 01 adds cache fields to StreamResponse
   format_tokens(0), // cache_creation
   format_tokens(0), // cache_read
   ```
  </action>
  <verify>`cargo check` passes; `rslph plan "test"` shows token output (manual test)</verify>
  <done>Plan command displays token consumption summary at completion</done>
</task>

</tasks>

<verification>
1. `cargo check` - All code compiles
2. `cargo test --lib` - All unit tests pass including new TokenUsage test
3. Status bar format matches CONTEXT.md specification
</verification>

<success_criteria>
- App struct has total_tokens: TokenUsage field
- AppEvent::TokenUsage variant exists and is handled in update()
- Status bar shows "In: X | Out: Y | CacheW: Z | CacheR: W" format
- format_tokens produces human-readable numbers (5.2k, 1.2M)
- Plan command prints token summary after completion
</success_criteria>

<output>
After completion, create `.planning/phases/08-token-tracking/08-02-SUMMARY.md`
</output>
