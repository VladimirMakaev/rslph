---
phase: 08-token-tracking
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - tests/fake_claude_lib/scenario.rs
  - tests/fake_claude_lib/stream_json.rs
  - tests/fake_claude_lib/config.rs
  - tests/e2e/build_token_tracking.rs
  - tests/tui/token_display_test.rs
autonomous: true

must_haves:
  truths:
    - "E2E tests verify token tracking with configurable fake Claude responses"
    - "TUI snapshot tests verify token display in status bar"
    - "Tests use deterministic token values for reproducible snapshots"
  artifacts:
    - path: "tests/fake_claude_lib/scenario.rs"
      provides: "ScenarioBuilder.with_token_usage() method"
      contains: "with_token_usage"
    - path: "tests/e2e/build_token_tracking.rs"
      provides: "E2E test for token accumulation"
      contains: "token"
  key_links:
    - from: "tests/e2e/build_token_tracking.rs"
      to: "tests/fake_claude_lib/scenario.rs"
      via: "ScenarioBuilder usage"
      pattern: "ScenarioBuilder.*with_token_usage"
---

<objective>
Extend fake Claude infrastructure with token configuration and add E2E/TUI tests for token tracking.

Purpose: Verify token tracking works end-to-end with deterministic, configurable token values (testing requirements from CONTEXT.md).

Output: ScenarioBuilder.with_token_usage() method, E2E token tracking test, TUI snapshot test for token display.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-token-tracking/CONTEXT.md
@.planning/phases/08-token-tracking/RESEARCH.md
@tests/fake_claude_lib/scenario.rs
@tests/fake_claude_lib/stream_json.rs
@tests/fake_claude_lib/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add token configuration to ScenarioBuilder</name>
  <files>tests/fake_claude_lib/scenario.rs, tests/fake_claude_lib/stream_json.rs, tests/fake_claude_lib/config.rs</files>
  <action>
1. In `tests/fake_claude_lib/config.rs`, add TokenConfig struct:
   ```rust
   /// Token usage configuration for an invocation.
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct TokenConfig {
       pub input_tokens: u64,
       pub output_tokens: u64,
       pub cache_creation_input_tokens: u64,
       pub cache_read_input_tokens: u64,
   }

   impl Default for TokenConfig {
       fn default() -> Self {
           Self {
               input_tokens: 100,
               output_tokens: 50,
               cache_creation_input_tokens: 0,
               cache_read_input_tokens: 0,
           }
       }
   }
   ```

2. Add `token_config: Option<TokenConfig>` field to InvocationConfig struct.

3. In `tests/fake_claude_lib/scenario.rs`, add method to ScenarioBuilder:
   ```rust
   /// Set token usage for the current invocation's responses.
   ///
   /// All assistant events in this invocation will use these token values.
   pub fn with_token_usage(
       mut self,
       input_tokens: u64,
       output_tokens: u64,
       cache_creation: u64,
       cache_read: u64,
   ) -> Self {
       self.current_invocation.token_config = Some(TokenConfig {
           input_tokens,
           output_tokens,
           cache_creation_input_tokens: cache_creation,
           cache_read_input_tokens: cache_read,
       });
       self
   }
   ```

4. In `tests/fake_claude_lib/stream_json.rs`, modify assistant event creation to accept token config.

   Add method to StreamEventOutput:
   ```rust
   /// Create an assistant text response with custom token usage.
   pub fn assistant_text_with_tokens(text: &str, tokens: &TokenConfig) -> Self {
       let content_block = ContentBlockOutput {
           block_type: "text".to_string(),
           text: Some(text.to_string()),
           thinking: None,
           name: None,
           input: None,
           id: None,
       };

       Self {
           event_type: "assistant".to_string(),
           message: Some(MessageOutput {
               id: Some(format!("msg_{}", uuid_v4_simple())),
               role: Some("assistant".to_string()),
               content: MessageContentOutput::Blocks(vec![content_block]),
               model: Some("claude-opus-4-5-20251101".to_string()),
               stop_reason: Some("end_turn".to_string()),
               usage: Some(UsageOutput {
                   input_tokens: tokens.input_tokens,
                   output_tokens: tokens.output_tokens,
                   cache_creation_input_tokens: Some(tokens.cache_creation_input_tokens),
                   cache_read_input_tokens: Some(tokens.cache_read_input_tokens),
               }),
           }),
           uuid: Some(uuid_v4_simple()),
           timestamp: Some(chrono::Utc::now().to_rfc3339()),
       }
   }
   ```

5. Update `respond_with_text` in ScenarioBuilder to use token_config if set:
   ```rust
   pub fn respond_with_text(mut self, text: &str) -> Self {
       self.current_invocation.events.push(StreamEventOutput::system_init());

       // Use configured tokens or default
       let event = if let Some(ref tokens) = self.current_invocation.token_config {
           StreamEventOutput::assistant_text_with_tokens(text, tokens)
       } else {
           StreamEventOutput::assistant_text(text)
       };
       self.current_invocation.events.push(event);
       self.current_invocation.events.push(StreamEventOutput::result(0.001));
       self
   }
   ```

6. Also update `assistant_with_blocks` and `tool_use` to respect token_config.
  </action>
  <verify>`cargo test --lib fake_claude` passes; ScenarioBuilder chain compiles</verify>
  <done>ScenarioBuilder has with_token_usage() method that configures token values</done>
</task>

<task type="auto">
  <name>Task 2: Create E2E test for token tracking</name>
  <files>tests/e2e/build_token_tracking.rs, tests/e2e/mod.rs</files>
  <action>
1. Create new test file `tests/e2e/build_token_tracking.rs`:
   ```rust
   //! E2E tests for token tracking during build execution.

   use std::path::PathBuf;
   use tempfile::TempDir;

   mod common;
   use common::*;

   use crate::fake_claude_lib::ScenarioBuilder;

   /// Test that token usage is accumulated across iterations.
   #[tokio::test]
   async fn test_build_accumulates_tokens() {
       let dir = TempDir::new().expect("temp dir");

       // Create a progress file with 2 tasks
       let progress_content = r#"# Test Project

## Status
In Progress

## Analysis
Testing token accumulation

## Tasks

### Phase 1
- [ ] Task 1
- [ ] Task 2

## Testing Strategy
Unit tests

## Completed This Iteration
None

## Recent Attempts
None
"#;
       std::fs::write(dir.path().join("progress.md"), progress_content).unwrap();

       // Configure fake Claude with specific token values
       // First iteration: 5000 in, 1500 out, 2000 cache_create, 1000 cache_read
       // Second iteration: 3000 in, 1000 out, 500 cache_create, 2500 cache_read
       let handle = ScenarioBuilder::new()
           .with_token_usage(5000, 1500, 2000, 1000)
           .respond_with_text(&format_task_completion("Task 1"))
           .next_invocation()
           .with_token_usage(3000, 1000, 500, 2500)
           .respond_with_text(&format_task_completion("Task 2"))
           .build();

       // Run build with fake Claude
       let output = run_rslph_build(&dir, &handle, &["--no-tui"]).await;

       assert!(output.status.success(), "Build should succeed");

       // Verify token output in logs
       let stdout = String::from_utf8_lossy(&output.stdout);
       let stderr = String::from_utf8_lossy(&output.stderr);
       let combined = format!("{}{}", stdout, stderr);

       // Should see token logs from each iteration
       assert!(combined.contains("5000") || combined.contains("5.0k") || combined.contains("5k"),
           "Should log first iteration's input tokens");
       assert!(combined.contains("3000") || combined.contains("3.0k") || combined.contains("3k"),
           "Should log second iteration's input tokens");
   }

   fn format_task_completion(task: &str) -> String {
       // Return a valid progress file with the task marked complete
       format!(r#"# Test Project

## Status
In Progress

## Analysis
Testing token accumulation

## Tasks

### Phase 1
- [x] {}
- [ ] Task 2

## Testing Strategy
Unit tests

## Completed This Iteration
- {}

## Recent Attempts
None
"#, task, task)
   }
   ```

2. Add `mod build_token_tracking;` to `tests/e2e/mod.rs`.

3. Ensure the test helper functions (run_rslph_build, etc.) are available in tests/e2e/common.rs or create them.

Note: Adapt test structure to match existing E2E test patterns in the codebase.
  </action>
  <verify>`cargo test --test e2e build_token_tracking` passes</verify>
  <done>E2E test verifies token accumulation with configurable fake Claude responses</done>
</task>

<task type="auto">
  <name>Task 3: Create TUI snapshot test for token display</name>
  <files>tests/tui/token_display_test.rs</files>
  <action>
1. Check existing TUI test structure in tests/tui/ directory.

2. Create or update TUI snapshot test for status bar with tokens:
   ```rust
   //! TUI snapshot tests for token display in status bar.

   use ratatui::backend::TestBackend;
   use ratatui::Terminal;

   use rslph::tui::app::{App, AppEvent};
   use rslph::tui::widgets::status_bar::render_header;
   use rslph::build::tokens::TokenUsage;

   #[test]
   fn test_status_bar_displays_tokens() {
       let backend = TestBackend::new(100, 3);
       let mut terminal = Terminal::new(backend).unwrap();

       let mut app = App::new(10, "claude-opus-4-5", "test-project");
       app.current_iteration = 3;
       app.current_task = 2;
       app.total_tasks = 5;

       // Set deterministic token values for snapshot
       app.update(AppEvent::TokenUsage {
           input_tokens: 5200,
           output_tokens: 10900,
           cache_creation_input_tokens: 2100,
           cache_read_input_tokens: 1500,
       });

       terminal.draw(|frame| {
           let area = frame.area();
           render_header(frame, area, &app);
       }).unwrap();

       let buffer = terminal.backend().buffer().clone();

       // Verify token display in status bar
       let content = buffer_to_string(&buffer);

       // Check for formatted token values
       assert!(content.contains("In: 5.2k"), "Should show input tokens: {}", content);
       assert!(content.contains("Out: 10.9k"), "Should show output tokens: {}", content);
       assert!(content.contains("CacheW: 2.1k"), "Should show cache write tokens: {}", content);
       assert!(content.contains("CacheR: 1.5k"), "Should show cache read tokens: {}", content);
   }

   #[test]
   fn test_status_bar_zero_tokens() {
       let backend = TestBackend::new(100, 3);
       let mut terminal = Terminal::new(backend).unwrap();

       let app = App::new(10, "claude-opus-4-5", "test-project");
       // Default app has zero tokens

       terminal.draw(|frame| {
           let area = frame.area();
           render_header(frame, area, &app);
       }).unwrap();

       let buffer = terminal.backend().buffer().clone();
       let content = buffer_to_string(&buffer);

       // Should show zeros
       assert!(content.contains("In: 0"), "Should show zero input tokens: {}", content);
       assert!(content.contains("Out: 0"), "Should show zero output tokens: {}", content);
   }

   fn buffer_to_string(buffer: &ratatui::buffer::Buffer) -> String {
       let mut result = String::new();
       for y in 0..buffer.area.height {
           for x in 0..buffer.area.width {
               result.push_str(buffer.get(x, y).symbol());
           }
           result.push('\n');
       }
       result
   }
   ```

3. Use insta for snapshot testing if that's the existing pattern, otherwise use assertions.

4. Add test to appropriate test module.
  </action>
  <verify>`cargo test --test tui token_display` passes</verify>
  <done>TUI snapshot tests verify token display with deterministic values</done>
</task>

</tasks>

<verification>
1. `cargo test --lib` - All unit tests pass
2. `cargo test --test e2e` - E2E tests pass including token tracking
3. `cargo test --test tui` - TUI tests pass including token display
4. ScenarioBuilder.with_token_usage() works in fluent chain
</verification>

<success_criteria>
- ScenarioBuilder has with_token_usage(input, output, cache_create, cache_read) method
- Fake Claude responses include configured token values in Usage events
- E2E test verifies token accumulation across multiple iterations
- TUI snapshot test verifies status bar shows "In: 5.2k | Out: 10.9k | CacheW: 2.1k | CacheR: 1.5k"
- All tests use fixed token values for deterministic, reproducible results
</success_criteria>

<output>
After completion, create `.planning/phases/08-token-tracking/08-03-SUMMARY.md`
</output>
