---
phase: 09-eval-command-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/eval/mod.rs
  - src/cli.rs
autonomous: true

must_haves:
  truths:
    - "Eval module exists and compiles"
    - "CLI accepts eval subcommand with project argument"
    - "tempfile is a regular dependency (not just dev)"
  artifacts:
    - path: "src/eval/mod.rs"
      provides: "EvalResult struct and module exports"
      exports: ["EvalResult"]
    - path: "src/cli.rs"
      provides: "Commands::Eval variant"
      contains: "Eval {"
    - path: "Cargo.toml"
      provides: "tempfile in dependencies"
      contains: 'tempfile = "3"'
  key_links:
    - from: "src/lib.rs"
      to: "src/eval/mod.rs"
      via: "pub mod eval"
      pattern: "pub mod eval"
---

<objective>
Create the eval module structure and CLI subcommand for the evaluation system.

Purpose: Establish the foundational types and CLI interface that the eval command implementation will use.
Output: Compiling eval module with EvalResult type, CLI with eval subcommand, tempfile promoted to regular dependency.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-eval-command-foundation/09-RESEARCH.md

Reference files:
@src/cli.rs (existing CLI patterns)
@src/build/mod.rs (module export pattern)
@src/build/tokens.rs (TokenUsage type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Promote tempfile and create eval module</name>
  <files>Cargo.toml, src/lib.rs, src/eval/mod.rs</files>
  <action>
1. Edit Cargo.toml:
   - Move `tempfile = "3"` from [dev-dependencies] to [dependencies]
   - Remove the duplicate from dev-dependencies (keep it only in dependencies)

2. Create src/eval/mod.rs with:
   ```rust
   //! Eval command for controlled benchmarking in isolated environments.
   //!
   //! Provides the `eval` command handler that runs plan+build in temp directories
   //! and aggregates metrics (tokens, timing).

   mod command;

   pub use command::run_eval_command;

   use std::path::PathBuf;
   use crate::build::tokens::TokenUsage;

   /// Result of an eval run (EVAL-04, EVAL-05).
   #[derive(Debug, Clone)]
   pub struct EvalResult {
       /// Project that was evaluated
       pub project: String,
       /// Total execution time in seconds
       pub elapsed_secs: f64,
       /// Total tokens consumed across plan and build
       pub total_tokens: TokenUsage,
       /// Number of build iterations
       pub iterations: u32,
       /// Path to preserved workspace (if --keep was used)
       pub workspace_path: Option<PathBuf>,
   }
   ```

3. Create src/eval/command.rs as a stub:
   ```rust
   //! Eval command handler.

   use std::path::PathBuf;
   use tokio_util::sync::CancellationToken;

   use crate::config::Config;
   use crate::build::tokens::TokenUsage;
   use super::EvalResult;

   /// Run the eval command (stub - to be implemented in plan 02).
   pub async fn run_eval_command(
       project: String,
       keep: bool,
       no_tui: bool,
       config: &Config,
       cancel_token: CancellationToken,
   ) -> color_eyre::Result<EvalResult> {
       // Stub implementation - returns placeholder result
       Ok(EvalResult {
           project,
           elapsed_secs: 0.0,
           total_tokens: TokenUsage::default(),
           iterations: 0,
           workspace_path: None,
       })
   }
   ```

4. Add to src/lib.rs:
   ```rust
   pub mod eval;
   ```
  </action>
  <verify>
  Run `cargo check` - should compile without errors.
  </verify>
  <done>
  - src/eval/mod.rs exists with EvalResult struct
  - src/eval/command.rs exists with stub run_eval_command
  - tempfile is in [dependencies] section of Cargo.toml
  - `cargo check` passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add eval CLI subcommand</name>
  <files>src/cli.rs</files>
  <action>
Add the Eval variant to the Commands enum in src/cli.rs:

```rust
#[derive(Subcommand, Debug)]
pub enum Commands {
    // ... existing Plan and Build variants ...

    /// Run evaluation in isolated environment (EVAL-01)
    Eval {
        /// Project directory or name to evaluate
        project: String,

        /// Keep temp directory after completion
        #[arg(long)]
        keep: bool,

        /// Disable TUI output
        #[arg(long)]
        no_tui: bool,
    },
}
```

Add a test for the new subcommand:

```rust
#[test]
fn test_parse_eval_command() {
    let cli = Cli::try_parse_from(["rslph", "eval", "calculator"]).expect("Should parse");
    match cli.command {
        Commands::Eval { project, keep, no_tui } => {
            assert_eq!(project, "calculator");
            assert!(!keep);
            assert!(!no_tui);
        }
        _ => panic!("Expected Eval command"),
    }
}

#[test]
fn test_parse_eval_with_keep() {
    let cli = Cli::try_parse_from(["rslph", "eval", "calculator", "--keep"]).expect("Should parse");
    match cli.command {
        Commands::Eval { project, keep, no_tui } => {
            assert_eq!(project, "calculator");
            assert!(keep);
            assert!(!no_tui);
        }
        _ => panic!("Expected Eval command"),
    }
}
```
  </action>
  <verify>
  Run `cargo test --lib cli` - CLI parsing tests should pass.
  </verify>
  <done>
  - Commands::Eval variant exists with project, keep, no_tui fields
  - CLI tests for eval subcommand pass
  - `cargo check` passes
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes
2. `cargo test --lib` passes (all existing + new CLI tests)
3. `cargo build` produces binary that accepts `rslph eval --help`
</verification>

<success_criteria>
- Eval module compiles with EvalResult type exported
- CLI accepts `rslph eval <project>` with --keep and --no-tui flags
- tempfile is a regular dependency
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-eval-command-foundation/09-01-SUMMARY.md`
</output>
