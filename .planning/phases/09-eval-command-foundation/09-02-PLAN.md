---
phase: 09-eval-command-foundation
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/eval/command.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "User can run rslph eval <path> and see plan+build execute"
    - "Eval creates isolated temp directory for execution"
    - "Eval reports execution time at completion"
    - "Eval reports token consumption at completion"
    - "Temp directory is cleaned up by default"
    - "With --keep flag, temp directory is preserved"
  artifacts:
    - path: "src/eval/command.rs"
      provides: "run_eval_command implementation"
      min_lines: 80
    - path: "src/main.rs"
      provides: "Commands::Eval dispatch"
      contains: "Commands::Eval"
  key_links:
    - from: "src/eval/command.rs"
      to: "run_plan_command"
      via: "function call"
      pattern: "run_plan_command"
    - from: "src/eval/command.rs"
      to: "run_build_command"
      via: "function call"
      pattern: "run_build_command"
    - from: "src/main.rs"
      to: "run_eval_command"
      via: "async call"
      pattern: "run_eval_command"
---

<objective>
Implement the eval command that orchestrates plan+build in an isolated temp directory and reports metrics.

Purpose: Enable users to run controlled evaluations with automatic isolation and metric collection (EVAL-01, EVAL-04, EVAL-05).
Output: Working `rslph eval <path>` command that creates temp workspace, runs plan+build, and reports time/tokens.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-eval-command-foundation/09-RESEARCH.md
@.planning/phases/09-eval-command-foundation/09-01-SUMMARY.md

Reference files:
@src/main.rs (command dispatch pattern)
@src/planning/command.rs (run_plan_command signature)
@src/build/command.rs (run_build_command signature)
@src/build/tokens.rs (format_tokens function)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement run_eval_command</name>
  <files>src/eval/command.rs</files>
  <action>
Replace the stub implementation in src/eval/command.rs with full implementation:

```rust
//! Eval command handler.
//!
//! Orchestrates plan+build execution in isolated temporary directories
//! for controlled benchmarking.

use std::path::PathBuf;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio_util::sync::CancellationToken;

use crate::build::run_build_command;
use crate::build::tokens::{format_tokens, TokenUsage};
use crate::config::Config;
use crate::planning::run_plan_command;
use crate::progress::ProgressFile;

use super::EvalResult;

/// Run the eval command (EVAL-01).
///
/// Executes plan and build in an isolated temporary directory,
/// collecting metrics for tokens and timing.
///
/// # Arguments
///
/// * `project` - Path to project directory to evaluate
/// * `keep` - If true, preserve temp directory after completion
/// * `no_tui` - If true, disable TUI output
/// * `config` - Application configuration
/// * `cancel_token` - Token for graceful cancellation
///
/// # Returns
///
/// * `Ok(EvalResult)` - Eval completed with metrics
/// * `Err(e)` - Eval failed
pub async fn run_eval_command(
    project: String,
    keep: bool,
    no_tui: bool,
    config: &Config,
    cancel_token: CancellationToken,
) -> color_eyre::Result<EvalResult> {
    let start = Instant::now();

    // Step 1: Resolve project path
    let project_path = PathBuf::from(&project);
    if !project_path.exists() {
        return Err(color_eyre::eyre::eyre!(
            "Project path does not exist: {}",
            project_path.display()
        ));
    }

    // Step 2: Create isolated temp directory
    let workspace = TempDir::with_prefix(&format!("rslph-eval-{}-",
        project_path.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("project")
    ))?;
    let working_dir = workspace.path().to_path_buf();

    println!("Eval workspace: {}", working_dir.display());

    // Step 3: Copy project files to temp directory
    copy_dir_recursive(&project_path, &working_dir)?;
    println!("Copied project files to workspace");

    // Step 4: Initialize git in workspace (required for VCS tracking)
    init_git_repo(&working_dir)?;

    // Step 5: Detect starting prompt
    let prompt = detect_eval_prompt(&working_dir)?;
    println!("Detected prompt: {} chars", prompt.len());

    // Step 6: Run plan command
    println!("\n=== PLANNING PHASE ===\n");
    let timeout = Duration::from_secs(config.max_iterations as u64 * 600);
    let progress_path = run_plan_command(
        &prompt,
        false, // not adaptive
        config,
        &working_dir,
        cancel_token.clone(),
        timeout,
    )
    .await?;

    // Step 7: Run build command
    println!("\n=== BUILD PHASE ===\n");
    run_build_command(
        progress_path.clone(),
        false, // not once
        false, // not dry-run
        no_tui || true, // force no-tui for eval to get clean output
        config,
        cancel_token.clone(),
    )
    .await?;

    // Step 8: Collect metrics from progress file
    let progress = ProgressFile::load(&progress_path)?;
    let iterations = progress.iteration_log.len() as u32;

    // Note: Token tracking is done within the plan and build commands.
    // For now, we track execution time. Full token aggregation will be
    // enhanced when we modify run_plan_command to return tokens.
    let elapsed_secs = start.elapsed().as_secs_f64();

    // Step 9: Handle workspace cleanup
    let workspace_path = if keep {
        let preserved = workspace.into_path();
        println!("\nWorkspace preserved at: {}", preserved.display());
        Some(preserved)
    } else {
        // TempDir will be dropped and cleaned up automatically
        drop(workspace);
        None
    };

    Ok(EvalResult {
        project,
        elapsed_secs,
        total_tokens: TokenUsage::default(), // TODO: aggregate from plan+build
        iterations,
        workspace_path,
    })
}

/// Copy directory contents recursively.
fn copy_dir_recursive(src: &PathBuf, dst: &PathBuf) -> std::io::Result<()> {
    if !dst.exists() {
        std::fs::create_dir_all(dst)?;
    }

    for entry in std::fs::read_dir(src)? {
        let entry = entry?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());

        if src_path.is_dir() {
            // Skip .git directories
            if entry.file_name() == ".git" {
                continue;
            }
            copy_dir_recursive(&src_path, &dst_path)?;
        } else {
            std::fs::copy(&src_path, &dst_path)?;
        }
    }

    Ok(())
}

/// Initialize a git repository in the workspace.
fn init_git_repo(working_dir: &PathBuf) -> std::io::Result<()> {
    use std::process::Command;

    Command::new("git")
        .args(["init"])
        .current_dir(working_dir)
        .output()?;

    Command::new("git")
        .args(["config", "user.email", "eval@rslph.local"])
        .current_dir(working_dir)
        .output()?;

    Command::new("git")
        .args(["config", "user.name", "Eval"])
        .current_dir(working_dir)
        .output()?;

    // Initial commit so we have a clean baseline
    Command::new("git")
        .args(["add", "."])
        .current_dir(working_dir)
        .output()?;

    Command::new("git")
        .args(["commit", "-m", "Initial eval state", "--allow-empty"])
        .current_dir(working_dir)
        .output()?;

    Ok(())
}

/// Detect the eval prompt from the project directory.
///
/// Looks for prompt.txt or README.md in the project root.
fn detect_eval_prompt(working_dir: &PathBuf) -> color_eyre::Result<String> {
    // Priority 1: prompt.txt
    let prompt_file = working_dir.join("prompt.txt");
    if prompt_file.exists() {
        return Ok(std::fs::read_to_string(prompt_file)?);
    }

    // Priority 2: README.md
    let readme_file = working_dir.join("README.md");
    if readme_file.exists() {
        return Ok(std::fs::read_to_string(readme_file)?);
    }

    // Priority 3: PROMPT.md
    let prompt_md = working_dir.join("PROMPT.md");
    if prompt_md.exists() {
        return Ok(std::fs::read_to_string(prompt_md)?);
    }

    Err(color_eyre::eyre::eyre!(
        "No prompt file found. Expected prompt.txt, README.md, or PROMPT.md in project root"
    ))
}
```

Key implementation notes:
- Uses TempDir with prefix for identifiable temp directories
- Copies project files (excluding .git) to workspace
- Initializes fresh git repo for VCS tracking
- Runs plan then build in sequence
- Reports timing metrics
- Preserves workspace with --keep flag
  </action>
  <verify>
  Run `cargo check` - should compile without errors.
  </verify>
  <done>
  - run_eval_command fully implemented
  - Uses TempDir for isolation
  - Orchestrates plan + build
  - Tracks elapsed time
  - Handles --keep flag
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire eval command to main.rs</name>
  <files>src/main.rs</files>
  <action>
Add the eval command dispatch to main.rs:

1. Add import at top:
```rust
use rslph::eval::run_eval_command;
use rslph::build::format_tokens;
```

2. Add match arm for Commands::Eval after the Commands::Build arm:
```rust
Commands::Eval { project, keep, no_tui } => {
    let cancel_token = setup_ctrl_c_handler();

    println!("Evaluating: {}", project);

    match run_eval_command(project, keep, no_tui, &config, cancel_token).await {
        Ok(result) => {
            println!("\n=== EVAL COMPLETE ===");
            println!("Project: {}", result.project);
            println!("Time: {:.1}s", result.elapsed_secs);
            println!("Iterations: {}", result.iterations);
            println!(
                "Tokens: In: {} | Out: {} | CacheW: {} | CacheR: {}",
                format_tokens(result.total_tokens.input_tokens),
                format_tokens(result.total_tokens.output_tokens),
                format_tokens(result.total_tokens.cache_creation_input_tokens),
                format_tokens(result.total_tokens.cache_read_input_tokens),
            );
            if let Some(path) = result.workspace_path {
                println!("Workspace: {}", path.display());
            }
        }
        Err(e) => {
            eprintln!("Eval failed: {}", e);
            std::process::exit(1);
        }
    }
}
```
  </action>
  <verify>
  Run `cargo build` and verify `./target/debug/rslph eval --help` shows the eval subcommand.
  </verify>
  <done>
  - main.rs dispatches Commands::Eval to run_eval_command
  - Prints EvalResult metrics on success
  - Exits with error code on failure
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds
2. `./target/debug/rslph eval --help` shows project, --keep, --no-tui options
3. Create a test project with prompt.txt and run `rslph eval ./test-project` (will fail on Claude but verifies wiring)
</verification>

<success_criteria>
- run_eval_command creates temp directory, copies files, runs plan+build
- main.rs dispatches eval command correctly
- Timing metrics are reported at completion
- --keep flag preserves workspace directory
</success_criteria>

<output>
After completion, create `.planning/phases/09-eval-command-foundation/09-02-SUMMARY.md`
</output>
