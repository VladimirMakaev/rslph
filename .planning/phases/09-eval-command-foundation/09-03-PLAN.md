---
phase: 09-eval-command-foundation
plan: 03
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - tests/e2e/eval_command.rs
  - tests/e2e/mod.rs
autonomous: true

must_haves:
  truths:
    - "E2E tests verify eval command creates temp workspace"
    - "E2E tests verify eval command runs plan and build"
    - "E2E tests verify --keep flag preserves workspace"
    - "E2E tests verify metrics are collected"
  artifacts:
    - path: "tests/e2e/eval_command.rs"
      provides: "E2E tests for eval command"
      min_lines: 50
    - path: "tests/e2e/mod.rs"
      provides: "Module exports for eval tests"
      contains: "mod eval_command"
  key_links:
    - from: "tests/e2e/eval_command.rs"
      to: "rslph eval"
      via: "Command::cargo_bin"
      pattern: "cargo_bin.*rslph"
---

<objective>
Add E2E tests for the eval command to verify isolation, orchestration, and metric collection.

Purpose: Ensure the eval command works correctly with the fake Claude test harness.
Output: Passing E2E tests that verify eval creates workspace, runs plan+build, and reports metrics.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-eval-command-foundation/09-02-SUMMARY.md

Reference files:
@tests/e2e/mod.rs (existing E2E test structure)
@tests/e2e/fixtures.rs (WorkspaceBuilder pattern)
@tests/e2e/build_command.rs (existing build command tests)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create eval command E2E tests</name>
  <files>tests/e2e/eval_command.rs, tests/e2e/mod.rs</files>
  <action>
1. Add to tests/e2e/mod.rs:
```rust
mod eval_command;
```

2. Create tests/e2e/eval_command.rs:
```rust
//! E2E tests for the eval command.

use assert_cmd::Command;
use tempfile::TempDir;

/// Create a minimal eval project with a prompt file.
fn create_eval_project(dir: &TempDir) -> std::path::PathBuf {
    let project_dir = dir.path().join("test-project");
    std::fs::create_dir_all(&project_dir).expect("create project dir");

    // Create prompt.txt
    std::fs::write(
        project_dir.join("prompt.txt"),
        "Create a simple hello world program that prints 'Hello, World!' to stdout.",
    )
    .expect("write prompt.txt");

    project_dir
}

#[test]
fn test_eval_help() {
    let mut cmd = Command::cargo_bin("rslph").expect("binary");
    cmd.args(["eval", "--help"]);

    cmd.assert()
        .success()
        .stdout(predicates::str::contains("project"))
        .stdout(predicates::str::contains("--keep"))
        .stdout(predicates::str::contains("--no-tui"));
}

#[test]
fn test_eval_missing_project() {
    let mut cmd = Command::cargo_bin("rslph").expect("binary");
    cmd.args(["eval", "/nonexistent/project/path"]);

    cmd.assert()
        .failure()
        .stderr(predicates::str::contains("does not exist"));
}

#[test]
fn test_eval_missing_prompt() {
    let dir = TempDir::new().expect("temp dir");
    let project_dir = dir.path().join("empty-project");
    std::fs::create_dir_all(&project_dir).expect("create project dir");

    let mut cmd = Command::cargo_bin("rslph").expect("binary");
    cmd.args(["eval", project_dir.to_str().unwrap()]);

    cmd.assert()
        .failure()
        .stderr(predicates::str::contains("No prompt file found"));
}

#[test]
fn test_eval_with_keep_flag() {
    // This test verifies the --keep flag is accepted
    // Full execution requires fake Claude which is tested separately
    let mut cmd = Command::cargo_bin("rslph").expect("binary");
    cmd.args(["eval", "--keep", "--help"]);

    // --help with --keep should still show help (clap behavior)
    cmd.assert().success();
}

use predicates::prelude::*;
```

Note: Full integration tests with fake Claude require the fake_claude_lib infrastructure.
For now, we test CLI parsing and basic validation. More comprehensive tests can be added
after Phase 10 establishes eval project patterns.
  </action>
  <verify>
  Run `cargo test --test e2e eval_command` - tests should pass.
  </verify>
  <done>
  - tests/e2e/eval_command.rs exists with basic tests
  - tests/e2e/mod.rs exports eval_command module
  - Tests verify CLI parsing and basic validation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for eval helpers</name>
  <files>src/eval/command.rs</files>
  <action>
Add unit tests to src/eval/command.rs:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_copy_dir_recursive() {
        let src_dir = TempDir::new().expect("src temp dir");
        let dst_dir = TempDir::new().expect("dst temp dir");

        // Create source structure
        std::fs::write(src_dir.path().join("file.txt"), "content").expect("write file");
        std::fs::create_dir(src_dir.path().join("subdir")).expect("create subdir");
        std::fs::write(src_dir.path().join("subdir/nested.txt"), "nested").expect("write nested");

        // Create .git directory that should be skipped
        std::fs::create_dir(src_dir.path().join(".git")).expect("create .git");
        std::fs::write(src_dir.path().join(".git/config"), "git stuff").expect("write git config");

        // Copy
        copy_dir_recursive(
            &src_dir.path().to_path_buf(),
            &dst_dir.path().to_path_buf(),
        )
        .expect("copy");

        // Verify
        assert!(dst_dir.path().join("file.txt").exists());
        assert!(dst_dir.path().join("subdir/nested.txt").exists());
        assert!(!dst_dir.path().join(".git").exists(), ".git should be skipped");
    }

    #[test]
    fn test_detect_eval_prompt_priority() {
        let dir = TempDir::new().expect("temp dir");

        // No prompt file
        let result = detect_eval_prompt(&dir.path().to_path_buf());
        assert!(result.is_err());

        // Add README.md
        std::fs::write(dir.path().join("README.md"), "readme content").expect("write readme");
        let result = detect_eval_prompt(&dir.path().to_path_buf());
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "readme content");

        // Add prompt.txt (should take priority)
        std::fs::write(dir.path().join("prompt.txt"), "prompt content").expect("write prompt");
        let result = detect_eval_prompt(&dir.path().to_path_buf());
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "prompt content");
    }

    #[test]
    fn test_init_git_repo() {
        let dir = TempDir::new().expect("temp dir");
        let path = dir.path().to_path_buf();

        init_git_repo(&path).expect("init git");

        assert!(path.join(".git").exists(), ".git directory should exist");
    }
}
```
  </action>
  <verify>
  Run `cargo test eval::command` - unit tests should pass.
  </verify>
  <done>
  - Unit tests for copy_dir_recursive
  - Unit tests for detect_eval_prompt
  - Unit tests for init_git_repo
  - All tests pass
  </done>
</task>

</tasks>

<verification>
1. `cargo test --test e2e` passes (including new eval_command tests)
2. `cargo test eval::command` passes (unit tests)
3. `cargo test` passes (all tests)
</verification>

<success_criteria>
- E2E tests verify eval CLI parsing and validation
- Unit tests verify helper functions
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-eval-command-foundation/09-03-SUMMARY.md`
</output>
