---
phase: 10-eval-projects-and-testing
plan: 03
type: execute
wave: 3
depends_on: [10-02]
files_modified:
  - src/eval/mod.rs
  - src/eval/command.rs
  - src/cli.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "User can run eval with built-in project name (not path)"
    - "Hidden tests execute automatically after build completes"
    - "User sees pass rate in eval output"
    - "User can list available projects with --list flag"
  artifacts:
    - path: "src/eval/mod.rs"
      provides: "EvalResult with test_results field"
      contains: "test_results: Option<TestResults>"
    - path: "src/eval/command.rs"
      provides: "Integrated test execution in eval flow"
      contains: "TestRunner"
    - path: "src/cli.rs"
      provides: "Eval --list flag"
      contains: "list: bool"
  key_links:
    - from: "src/eval/command.rs"
      to: "src/eval/test_runner.rs"
      via: "TestRunner::new().run_tests()"
      pattern: "TestRunner.*run_tests"
    - from: "src/eval/command.rs"
      to: "src/eval/projects.rs"
      via: "is_builtin check and extract"
      pattern: "is_builtin|extract_project_files"
---

<objective>
Integrate test runner into eval command and add project listing

Purpose: Complete the eval flow by executing hidden tests after build and reporting pass rate
Output: Working `rslph eval calculator` that runs tests and shows "Tests: 8/10 passed (80%)"
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-eval-projects-and-testing/10-RESEARCH.md

@src/eval/mod.rs
@src/eval/command.rs
@src/eval/projects.rs
@src/eval/test_runner.rs
@src/cli.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend EvalResult and integrate test runner into eval command</name>
  <files>
    - src/eval/mod.rs
    - src/eval/command.rs
  </files>
  <action>
1. Update src/eval/mod.rs EvalResult struct:
   - Add field `pub test_results: Option<TestResults>`

2. Update src/eval/command.rs run_eval_command():

   a. Add imports for projects and test_runner modules

   b. Modify project resolution (Step 1) to handle built-in projects:
   ```rust
   // Check if project is a built-in name
   let (is_builtin_project, project_source) = if crate::eval::projects::is_builtin(&project) {
       (true, None)
   } else {
       let path = PathBuf::from(&project);
       if !path.exists() {
           return Err(eyre!("Project '{}' is neither a built-in project nor a valid path", project));
       }
       (false, Some(path))
   };
   ```

   c. Modify Step 3 (copy files) to handle built-in vs external:
   ```rust
   if is_builtin_project {
       let proj = crate::eval::projects::get_project(&project)
           .ok_or_else(|| eyre!("Built-in project not found: {}", project))?;
       crate::eval::projects::extract_project_files(proj, &working_dir)?;
       println!("Extracted built-in project: {}", project);
   } else {
       copy_dir_recursive(project_source.as_ref().unwrap(), &working_dir)?;
       println!("Copied project files to workspace");
   }
   ```

   d. After build completes (after Step 9), add test execution phase:
   ```rust
   // Step 10: Execute hidden tests (EVAL-02)
   let test_results = if is_builtin_project {
       println!("\n=== TEST PHASE ===\n");

       // Get test data from embedded project
       let proj = crate::eval::projects::get_project(&project).unwrap();
       if let Some(test_content) = crate::eval::projects::get_test_data(proj) {
           let test_cases = crate::eval::load_test_cases(test_content);

           // Find the built program (look for common patterns)
           if let Some(program_path) = find_built_program(&working_dir) {
               let runner = crate::eval::TestRunner::new(program_path);
               let results = runner.run_tests(&test_cases);

               println!("Tests: {}/{} passed ({:.1}%)",
                   results.passed, results.total, results.pass_rate());

               // Print failed tests for debugging
               for case in &results.cases {
                   if !case.passed {
                       println!("  FAIL: input='{}' expected='{}' got='{}'",
                           case.input, case.expected, case.actual);
                   }
               }

               Some(results)
           } else {
               println!("Warning: Could not find built program to test");
               None
           }
       } else {
           None
       }
   } else {
       None // External projects don't have hidden tests
   };
   ```

   e. Add helper function to find the built program:
   ```rust
   /// Attempt to find a runnable program in the workspace.
   /// Looks for common patterns: Rust target, Python script, shell script.
   fn find_built_program(working_dir: &PathBuf) -> Option<PathBuf> {
       // Check for Rust binary in target/debug or target/release
       let cargo_toml = working_dir.join("Cargo.toml");
       if cargo_toml.exists() {
           // Parse Cargo.toml to find package name
           if let Ok(content) = std::fs::read_to_string(&cargo_toml) {
               for line in content.lines() {
                   if line.starts_with("name = ") {
                       let name = line.split('"').nth(1)?;
                       let debug_path = working_dir.join("target/debug").join(name);
                       let release_path = working_dir.join("target/release").join(name);
                       if debug_path.exists() {
                           return Some(debug_path);
                       }
                       if release_path.exists() {
                           return Some(release_path);
                       }
                   }
               }
           }
       }

       // Check for executable scripts
       for script_name in &["main.py", "main.sh", "calculator", "calc"] {
           let script_path = working_dir.join(script_name);
           if script_path.exists() {
               return Some(script_path);
           }
       }

       None
   }
   ```

   f. Update EvalResult construction to include test_results

   g. Print test summary after the execution summary
  </action>
  <verify>
    cargo build
    cargo test eval -- --nocapture
  </verify>
  <done>
    - EvalResult includes test_results field
    - Built-in projects are extracted via projects module
    - Test runner executes after build completes
    - Pass rate is displayed in output
    - Failed tests show input/expected/actual for debugging
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --list flag to eval command</name>
  <files>
    - src/cli.rs
    - src/main.rs
  </files>
  <action>
1. Update src/cli.rs Commands::Eval variant:
   ```rust
   /// Run evaluation in isolated environment (EVAL-01)
   Eval {
       /// Project directory or name to evaluate (optional with --list)
       #[arg(required_unless_present = "list")]
       project: Option<String>,

       /// Keep temp directory after completion
       #[arg(long)]
       keep: bool,

       /// Disable TUI output
       #[arg(long)]
       no_tui: bool,

       /// List available built-in projects
       #[arg(long)]
       list: bool,
   },
   ```

2. Update src/main.rs eval command handling:
   ```rust
   Commands::Eval { project, keep, no_tui, list } => {
       if list {
           println!("Available built-in projects:");
           for name in rslph::eval::list_projects() {
               println!("  - {}", name);
           }
           return Ok(());
       }

       let project = project.expect("project required when not listing");
       // ... existing eval code ...
   }
   ```

3. Update CLI tests in cli.rs:
   - Add test for `rslph eval --list`
   - Update existing eval tests to handle Option<String>
  </action>
  <verify>
    cargo test cli -- --nocapture
    cargo run -- eval --list
  </verify>
  <done>
    - `--list` flag added to eval command
    - `rslph eval --list` prints available projects
    - Project argument is optional when --list is present
    - CLI tests updated and passing
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive unit tests for integration</name>
  <files>
    - src/eval/command.rs
  </files>
  <action>
1. Add unit tests to src/eval/command.rs for:
   - `find_built_program` with various project types
   - Built-in project detection (is_builtin check)

2. Add test for find_built_program:
   ```rust
   #[test]
   fn test_find_built_program_cargo_project() {
       let dir = TempDir::new().expect("temp dir");

       // Create Cargo.toml
       std::fs::write(
           dir.path().join("Cargo.toml"),
           r#"[package]
name = "myapp"
version = "0.1.0"
"#
       ).expect("write");

       // Create fake binary
       std::fs::create_dir_all(dir.path().join("target/debug")).expect("create dir");
       std::fs::write(dir.path().join("target/debug/myapp"), "binary").expect("write");

       let result = find_built_program(&dir.path().to_path_buf());
       assert!(result.is_some());
       assert!(result.unwrap().ends_with("myapp"));
   }

   #[test]
   fn test_find_built_program_script() {
       let dir = TempDir::new().expect("temp dir");

       // Create main.py
       std::fs::write(dir.path().join("main.py"), "print('hello')").expect("write");

       let result = find_built_program(&dir.path().to_path_buf());
       assert!(result.is_some());
       assert!(result.unwrap().ends_with("main.py"));
   }
   ```
  </action>
  <verify>
    cargo test command -- --nocapture
  </verify>
  <done>
    - Unit tests for find_built_program passing
    - Integration between projects, test_runner, and command verified
  </done>
</task>

</tasks>

<verification>
- `cargo build` succeeds
- `cargo test` passes all tests
- `cargo run -- eval --list` shows "calculator"
- EvalResult has test_results field populated for built-in projects
</verification>

<success_criteria>
- Built-in project support in eval command (EVAL-02 complete)
- Pass rate displayed after build (EVAL-03 complete)
- `--list` flag working for project discovery
- External project paths still work (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/10-eval-projects-and-testing/10-03-SUMMARY.md`
</output>
