---
phase: 11-prompt-engineering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/prompts/modes.rs
  - src/prompts/mod.rs
  - src/config.rs
autonomous: true

must_haves:
  truths:
    - "PromptMode enum has three variants: Basic, Gsd, GsdTdd"
    - "Config struct includes prompt_mode field with Basic as default"
    - "Mode selection respects precedence: CLI > env > config > default"
  artifacts:
    - path: "src/prompts/modes.rs"
      provides: "PromptMode enum definition with strum derives"
      contains: "pub enum PromptMode"
    - path: "src/config.rs"
      provides: "prompt_mode field in Config"
      contains: "prompt_mode: PromptMode"
  key_links:
    - from: "src/prompts/modes.rs"
      to: "src/config.rs"
      via: "PromptMode type import"
      pattern: "use.*PromptMode"
---

<objective>
Add PromptMode enum and update config to support mode selection.

Purpose: Enable users to select between different prompt philosophies (basic, gsd, gsd-tdd) via configuration.
Output: PromptMode enum with strum derives, Config with prompt_mode field.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-prompt-engineering/CONTEXT.md
@.planning/phases/11-prompt-engineering/11-RESEARCH.md

# Current implementation
@src/prompts/mod.rs
@src/config.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add strum dependency</name>
  <files>Cargo.toml</files>
  <action>
Add strum and strum_macros dependencies to Cargo.toml:

```toml
strum = "0.26"
strum_macros = "0.26"
```

Add them in alphabetical order within the [dependencies] section.
  </action>
  <verify>Run `cargo check` - should compile without errors</verify>
  <done>strum and strum_macros appear in Cargo.toml dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create PromptMode enum</name>
  <files>src/prompts/modes.rs, src/prompts/mod.rs</files>
  <action>
Create `src/prompts/modes.rs` with PromptMode enum:

```rust
//! Prompt mode selection for different agent philosophies.

use serde::{Deserialize, Serialize};
use strum_macros::{Display, EnumString};

/// Available prompt modes for plan and build commands.
///
/// Each mode represents a coherent pair of plan + build prompts
/// designed to work together with a specific philosophy.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Serialize, Deserialize, EnumString, Display)]
#[strum(serialize_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum PromptMode {
    /// Current rslph prompts (default for backward compatibility)
    #[default]
    Basic,
    /// GSD-adapted prompts with XML structure and must-haves
    Gsd,
    /// GSD with strict test-driven development flow
    GsdTdd,
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    #[test]
    fn test_default_mode_is_basic() {
        assert_eq!(PromptMode::default(), PromptMode::Basic);
    }

    #[test]
    fn test_parse_from_string() {
        assert_eq!(PromptMode::from_str("basic").unwrap(), PromptMode::Basic);
        assert_eq!(PromptMode::from_str("gsd").unwrap(), PromptMode::Gsd);
        assert_eq!(PromptMode::from_str("gsd_tdd").unwrap(), PromptMode::GsdTdd);
    }

    #[test]
    fn test_display() {
        assert_eq!(PromptMode::Basic.to_string(), "basic");
        assert_eq!(PromptMode::Gsd.to_string(), "gsd");
        assert_eq!(PromptMode::GsdTdd.to_string(), "gsd_tdd");
    }

    #[test]
    fn test_serde_roundtrip() {
        let mode = PromptMode::GsdTdd;
        let json = serde_json::to_string(&mode).unwrap();
        assert_eq!(json, "\"gsd_tdd\"");
        let parsed: PromptMode = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed, mode);
    }
}
```

Update `src/prompts/mod.rs` to include the new module:
- Add `mod modes;`
- Add `pub use modes::PromptMode;`
  </action>
  <verify>Run `cargo test --lib prompts::modes` - all tests pass</verify>
  <done>PromptMode enum exists with Basic/Gsd/GsdTdd variants, parses from snake_case strings</done>
</task>

<task type="auto">
  <name>Task 3: Add prompt_mode to Config</name>
  <files>src/config.rs</files>
  <action>
Update `src/config.rs`:

1. Add import at top: `use crate::prompts::PromptMode;`

2. Add `prompt_mode` field to Config struct after existing fields:
```rust
/// Prompt mode selection (basic, gsd, gsd_tdd)
pub prompt_mode: PromptMode,
```

3. Add default in `impl Default for Config`:
```rust
prompt_mode: PromptMode::default(),
```

4. Add to PartialConfig struct:
```rust
#[serde(skip_serializing_if = "Option::is_none")]
pub prompt_mode: Option<PromptMode>,
```

5. Add test in config tests:
```rust
#[test]
fn test_default_prompt_mode() {
    let config = Config::default();
    assert_eq!(config.prompt_mode, PromptMode::Basic);
}
```
  </action>
  <verify>Run `cargo test --lib config` - all tests pass including new test</verify>
  <done>Config has prompt_mode field, defaults to Basic, serializes correctly</done>
</task>

</tasks>

<verification>
- `cargo check` compiles successfully
- `cargo test --lib prompts::modes` passes
- `cargo test --lib config` passes
- PromptMode enum has three variants with correct string parsing
- Config.prompt_mode defaults to Basic
</verification>

<success_criteria>
- [ ] strum and strum_macros added to Cargo.toml
- [ ] PromptMode enum in src/prompts/modes.rs with Basic/Gsd/GsdTdd
- [ ] Config struct has prompt_mode field
- [ ] All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-prompt-engineering/11-01-SUMMARY.md`
</output>
