---
phase: 11-prompt-engineering
plan: 04
type: execute
wave: 2
depends_on: ["11-01", "11-02", "11-03"]
files_modified:
  - prompts/basic/PROMPT_plan.md
  - prompts/basic/PROMPT_build.md
  - src/prompts/defaults.rs
  - src/prompts/loader.rs
  - src/prompts/mod.rs
  - src/cli.rs
autonomous: true

must_haves:
  truths:
    - "Basic mode uses current rslph prompts (backward compatible)"
    - "Mode selection works via CLI flag --mode"
    - "Mode selection works via config prompt_mode"
    - "File overrides still take precedence over mode selection"
  artifacts:
    - path: "prompts/basic/PROMPT_plan.md"
      provides: "Basic mode plan prompt (current rslph)"
      min_lines: 80
    - path: "prompts/basic/PROMPT_build.md"
      provides: "Basic mode build prompt (current rslph)"
      min_lines: 60
    - path: "src/prompts/defaults.rs"
      provides: "Mode-aware prompt loading"
      contains: "impl PromptMode"
    - path: "src/cli.rs"
      provides: "CLI --mode flag"
      contains: "--mode"
  key_links:
    - from: "src/prompts/loader.rs"
      to: "src/prompts/modes.rs"
      via: "mode.plan_prompt() calls"
      pattern: "prompt_mode.*plan_prompt"
    - from: "src/cli.rs"
      to: "src/config.rs"
      via: "mode override in PartialConfig"
      pattern: "prompt_mode.*Option"
---

<objective>
Create basic mode prompts and integrate mode selection into loader and CLI.

Purpose: Complete the prompt mode infrastructure by adding basic mode (current prompts) and wiring mode selection through loader and CLI (PROMPT-04).
Output: Basic mode prompts, updated loader with mode awareness, CLI --mode flag.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/11-prompt-engineering/CONTEXT.md
@.planning/phases/11-prompt-engineering/11-RESEARCH.md

# Files created by prior plans
@src/prompts/modes.rs
@src/config.rs

# Current implementation to update
@src/prompts/defaults.rs
@src/prompts/loader.rs
@src/cli.rs
@prompts/PROMPT_plan.md
@prompts/PROMPT_build.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create basic mode prompts</name>
  <files>prompts/basic/PROMPT_plan.md, prompts/basic/PROMPT_build.md</files>
  <action>
Create `prompts/basic/` directory and copy current prompts as basic mode.

The basic mode should be the current rslph prompts for backward compatibility:

1. Create `prompts/basic/PROMPT_plan.md`:
   - Copy content from `prompts/PROMPT_plan.md` exactly
   - This preserves current behavior as the default mode

2. Create `prompts/basic/PROMPT_build.md`:
   - Copy content from `prompts/PROMPT_build.md` exactly
   - Maintains backward compatibility

Note: The CONTEXT.md mentioned using PortableRalph prompts for basic mode, but for backward compatibility, we use current rslph prompts. Users wanting PortableRalph can use file overrides.
  </action>
  <verify>Files exist and match current prompts in content</verify>
  <done>prompts/basic/ contains exact copies of current plan and build prompts</done>
</task>

<task type="auto">
  <name>Task 2: Update defaults.rs with mode-aware prompt methods</name>
  <files>src/prompts/defaults.rs</files>
  <action>
Update `src/prompts/defaults.rs` to load prompts based on mode:

```rust
//! Baked-in default prompts embedded at compile time.

use super::PromptMode;

// Basic mode prompts
const BASIC_PLAN: &str = include_str!("../../prompts/basic/PROMPT_plan.md");
const BASIC_BUILD: &str = include_str!("../../prompts/basic/PROMPT_build.md");

// GSD mode prompts
const GSD_PLAN: &str = include_str!("../../prompts/gsd/PROMPT_plan.md");
const GSD_BUILD: &str = include_str!("../../prompts/gsd/PROMPT_build.md");

// GSD-TDD mode prompts
const GSD_TDD_PLAN: &str = include_str!("../../prompts/gsd_tdd/PROMPT_plan.md");
const GSD_TDD_BUILD: &str = include_str!("../../prompts/gsd_tdd/PROMPT_build.md");

/// Test discovery prompt (mode-independent)
pub const TEST_DISCOVERY_PROMPT: &str = include_str!("../../prompts/PROMPT_test_discovery.md");

impl PromptMode {
    /// Get the plan prompt for this mode.
    pub fn plan_prompt(&self) -> &'static str {
        match self {
            PromptMode::Basic => BASIC_PLAN,
            PromptMode::Gsd => GSD_PLAN,
            PromptMode::GsdTdd => GSD_TDD_PLAN,
        }
    }

    /// Get the build prompt for this mode.
    pub fn build_prompt(&self) -> &'static str {
        match self {
            PromptMode::Basic => BASIC_BUILD,
            PromptMode::Gsd => GSD_BUILD,
            PromptMode::GsdTdd => GSD_TDD_BUILD,
        }
    }
}

/// Get the test discovery prompt.
pub fn test_discovery_prompt() -> &'static str {
    TEST_DISCOVERY_PROMPT
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_plan_prompt_exists() {
        let prompt = PromptMode::Basic.plan_prompt();
        assert!(!prompt.is_empty());
        assert!(prompt.contains("Planning"));
    }

    #[test]
    fn test_basic_build_prompt_exists() {
        let prompt = PromptMode::Basic.build_prompt();
        assert!(!prompt.is_empty());
        assert!(prompt.contains("RALPH_DONE"));
    }

    #[test]
    fn test_gsd_prompts_exist() {
        let plan = PromptMode::Gsd.plan_prompt();
        let build = PromptMode::Gsd.build_prompt();
        assert!(!plan.is_empty());
        assert!(!build.is_empty());
        // GSD prompts should have deviation handling
        assert!(build.contains("deviation") || build.contains("Deviation"));
    }

    #[test]
    fn test_gsd_tdd_prompts_exist() {
        let plan = PromptMode::GsdTdd.plan_prompt();
        let build = PromptMode::GsdTdd.build_prompt();
        assert!(!plan.is_empty());
        assert!(!build.is_empty());
        // TDD prompts should reference TDD
        assert!(build.contains("TDD") || build.contains("tdd"));
    }

    #[test]
    fn test_discovery_prompt_exists() {
        let prompt = test_discovery_prompt();
        assert!(!prompt.is_empty());
        assert!(prompt.contains("Test Runner Discovery"));
    }
}
```

Remove the old constants (PLAN_PROMPT, BUILD_PROMPT) and helper functions (default_plan_prompt, default_build_prompt) as they're replaced by PromptMode methods.
  </action>
  <verify>Run `cargo test --lib prompts::defaults` - all tests pass</verify>
  <done>defaults.rs loads prompts via PromptMode methods, all three modes have working prompts</done>
</task>

<task type="auto">
  <name>Task 3: Update loader.rs to use mode selection</name>
  <files>src/prompts/loader.rs</files>
  <action>
Update `src/prompts/loader.rs` to use config.prompt_mode:

```rust
//! Prompt loading with config override support.

use crate::config::Config;

/// Get the planning prompt, using config override if specified.
///
/// Precedence: file override > mode selection
pub fn get_plan_prompt(config: &Config) -> color_eyre::Result<String> {
    // File override takes precedence (power users)
    if let Some(path) = &config.plan_prompt {
        return std::fs::read_to_string(path).map_err(|e| {
            color_eyre::eyre::eyre!(
                "Failed to read plan prompt from '{}': {}",
                path.display(),
                e
            )
        });
    }

    // Mode-based selection
    Ok(config.prompt_mode.plan_prompt().to_string())
}

/// Get the build prompt, using config override if specified.
///
/// Precedence: file override > mode selection
pub fn get_build_prompt(config: &Config) -> color_eyre::Result<String> {
    // File override takes precedence (power users)
    if let Some(path) = &config.build_prompt {
        return std::fs::read_to_string(path).map_err(|e| {
            color_eyre::eyre::eyre!(
                "Failed to read build prompt from '{}': {}",
                path.display(),
                e
            )
        });
    }

    // Mode-based selection
    Ok(config.prompt_mode.build_prompt().to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::prompts::PromptMode;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_get_plan_prompt_uses_mode_default() {
        let config = Config::default();
        let prompt = get_plan_prompt(&config).expect("Should get default prompt");
        // Default is basic mode
        assert!(prompt.contains("Planning"));
    }

    #[test]
    fn test_get_plan_prompt_respects_mode() {
        let mut config = Config::default();
        config.prompt_mode = PromptMode::Gsd;
        let prompt = get_plan_prompt(&config).expect("Should get GSD prompt");
        // GSD prompt should have different content
        assert!(!prompt.is_empty());
    }

    #[test]
    fn test_get_plan_prompt_file_override_wins() {
        let mut temp = NamedTempFile::new().expect("Should create temp file");
        writeln!(temp, "Custom planning prompt").expect("Should write");

        let config = Config {
            plan_prompt: Some(temp.path().to_path_buf()),
            prompt_mode: PromptMode::Gsd, // Mode should be ignored
            ..Default::default()
        };

        let prompt = get_plan_prompt(&config).expect("Should read override");
        assert!(prompt.contains("Custom planning prompt"));
    }

    #[test]
    fn test_get_build_prompt_uses_mode_default() {
        let config = Config::default();
        let prompt = get_build_prompt(&config).expect("Should get default prompt");
        assert!(prompt.contains("RALPH_DONE"));
    }

    #[test]
    fn test_get_build_prompt_respects_mode() {
        let mut config = Config::default();
        config.prompt_mode = PromptMode::GsdTdd;
        let prompt = get_build_prompt(&config).expect("Should get TDD prompt");
        assert!(prompt.contains("TDD") || prompt.contains("tdd"));
    }

    #[test]
    fn test_get_build_prompt_file_override_wins() {
        let mut temp = NamedTempFile::new().expect("Should create temp file");
        writeln!(temp, "Custom build prompt").expect("Should write");

        let config = Config {
            build_prompt: Some(temp.path().to_path_buf()),
            prompt_mode: PromptMode::GsdTdd, // Mode should be ignored
            ..Default::default()
        };

        let prompt = get_build_prompt(&config).expect("Should read override");
        assert!(prompt.contains("Custom build prompt"));
    }

    #[test]
    fn test_get_plan_prompt_error_on_missing_override() {
        let config = Config {
            plan_prompt: Some("/nonexistent/path/prompt.md".into()),
            ..Default::default()
        };

        let result = get_plan_prompt(&config);
        assert!(result.is_err());
    }
}
```
  </action>
  <verify>Run `cargo test --lib prompts::loader` - all tests pass</verify>
  <done>loader.rs uses config.prompt_mode, file overrides still take precedence</done>
</task>

<task type="auto">
  <name>Task 4: Add --mode CLI flag</name>
  <files>src/cli.rs</files>
  <action>
Update `src/cli.rs` to add --mode global flag:

1. Add import: `use crate::prompts::PromptMode;`

2. Add global flag to Cli struct:
```rust
/// Prompt mode selection (basic, gsd, gsd_tdd)
#[arg(long, global = true, value_parser = clap::value_parser!(PromptMode))]
pub mode: Option<PromptMode>,
```

3. Update `to_overrides` method to include mode:
```rust
pub fn to_overrides(&self, matches: &clap::ArgMatches) -> PartialConfig {
    PartialConfig {
        claude_path: self.extract_if_explicit(matches, "claude_path", &self.claude_path),
        max_iterations: self.extract_if_explicit(matches, "max_iterations", &self.max_iterations),
        prompt_mode: self.extract_if_explicit(matches, "mode", &self.mode),
        ..Default::default()
    }
}
```

4. Add test:
```rust
#[test]
fn test_parse_with_mode_flag() {
    let cli = Cli::try_parse_from([
        "rslph",
        "--mode",
        "gsd_tdd",
        "plan",
        "idea.txt",
    ])
    .expect("Should parse");

    assert_eq!(cli.mode, Some(PromptMode::GsdTdd));
}

#[test]
fn test_mode_flag_values() {
    // Test all valid mode values
    for (input, expected) in [
        ("basic", PromptMode::Basic),
        ("gsd", PromptMode::Gsd),
        ("gsd_tdd", PromptMode::GsdTdd),
    ] {
        let cli = Cli::try_parse_from([
            "rslph",
            "--mode",
            input,
            "plan",
            "idea.txt",
        ])
        .expect("Should parse");
        assert_eq!(cli.mode, Some(expected));
    }
}
```

Note: PromptMode derives EnumString from strum, which clap can use via value_parser for string-to-enum conversion.
  </action>
  <verify>Run `cargo test --lib cli` - all tests pass including new mode tests</verify>
  <done>CLI has --mode flag that accepts basic/gsd/gsd_tdd and passes to PartialConfig</done>
</task>

</tasks>

<verification>
- prompts/basic/ contains current rslph prompts
- `cargo test --lib prompts` passes (all prompt modules)
- `cargo test --lib cli` passes with mode flag tests
- `rslph --help` shows --mode flag with valid values
- Mode precedence: CLI --mode > env RSLPH_PROMPT_MODE > config prompt_mode > default (basic)
- File overrides still work and take precedence over mode
</verification>

<success_criteria>
- [ ] prompts/basic/ has plan and build prompts (PROMPT-04 backward compat)
- [ ] defaults.rs loads prompts via PromptMode methods
- [ ] loader.rs respects config.prompt_mode
- [ ] CLI has --mode flag (PROMPT-04)
- [ ] File overrides still take precedence
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-prompt-engineering/11-04-SUMMARY.md`
</output>
