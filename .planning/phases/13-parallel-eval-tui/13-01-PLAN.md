---
phase: 13-parallel-eval-tui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli.rs
  - src/eval/mod.rs
  - src/eval/parallel.rs
  - src/eval/command.rs
  - src/prompts/modes.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can run evals across multiple modes with --modes flag"
    - "Trials execute in parallel using JoinSet"
    - "Each mode/trial combination produces independent results"
  artifacts:
    - path: "src/cli.rs"
      provides: "--modes flag for eval command"
      contains: "modes:"
    - path: "src/eval/parallel.rs"
      provides: "Parallel execution orchestrator"
      exports: ["run_parallel_evals", "TrialEvent", "TrialResult"]
    - path: "src/eval/command.rs"
      provides: "Integration of parallel eval into existing command"
      contains: "run_parallel_evals"
  key_links:
    - from: "src/cli.rs"
      to: "src/eval/command.rs"
      via: "modes Vec<PromptMode> passed to run_eval_command"
      pattern: "modes.*Vec.*PromptMode"
    - from: "src/eval/command.rs"
      to: "src/eval/parallel.rs"
      via: "calls run_parallel_evals when modes.len() > 1"
      pattern: "run_parallel_evals"
---

<objective>
Add --modes CLI flag and parallel eval execution infrastructure.

Purpose: Enable users to run evals across multiple prompt modes (basic, gsd, gsd_tdd) in a single command, with trials executing in parallel for faster iteration.

Output: Working `rslph eval calculator --modes basic,gsd,gsd_tdd --trials 3` command that spawns 9 parallel trials.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-parallel-eval-tui/13-RESEARCH.md

@src/cli.rs
@src/eval/command.rs
@src/eval/mod.rs
@src/prompts/modes.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --modes CLI flag to eval command</name>
  <files>src/cli.rs, src/prompts/modes.rs</files>
  <action>
Add --modes flag to the Eval command in src/cli.rs:

1. Add new field to Commands::Eval variant:
   ```rust
   /// Comma-separated list of modes to evaluate (basic,gsd,gsd_tdd)
   #[arg(long, value_delimiter = ',')]
   modes: Option<Vec<PromptMode>>,
   ```

2. The PromptMode enum in src/prompts/modes.rs already has strum derives for parsing - verify it works with clap's value_parser.

3. Add unit test for parsing --modes flag:
   ```rust
   #[test]
   fn test_parse_eval_with_modes() {
       let cli = Cli::try_parse_from([
           "rslph", "eval", "calculator", "--modes", "basic,gsd,gsd_tdd"
       ]).expect("Should parse");
       // ... assert modes vector contains all three
   }
   ```

Note: When modes is None or has single mode, use existing sequential behavior. When modes has multiple values, use parallel execution (Task 3).
  </action>
  <verify>
`cargo test test_parse_eval_with_modes` passes.
`cargo build` succeeds.
`./target/debug/rslph eval --help` shows --modes flag.
  </verify>
  <done>
--modes flag parses comma-separated PromptMode values into Vec<PromptMode>.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create parallel execution module with TrialEvent and JoinSet</name>
  <files>src/eval/parallel.rs, src/eval/mod.rs</files>
  <action>
Create src/eval/parallel.rs with parallel execution infrastructure:

1. Define TrialEvent struct for channel communication:
   ```rust
   #[derive(Debug, Clone)]
   pub struct TrialEvent {
       pub mode: PromptMode,
       pub trial_num: u32,
       pub event: TrialEventKind,
   }

   #[derive(Debug, Clone)]
   pub enum TrialEventKind {
       Started,
       Planning,
       Building { iteration: u32, max_iterations: u32 },
       Testing,
       Complete { result: TrialResult },
       Failed { error: String },
   }
   ```

2. Define TrialResult struct:
   ```rust
   #[derive(Debug, Clone)]
   pub struct TrialResult {
       pub mode: PromptMode,
       pub trial_num: u32,
       pub eval_result: EvalResult,
   }
   ```

3. Create run_parallel_evals function using tokio::task::JoinSet:
   ```rust
   pub async fn run_parallel_evals(
       modes: Vec<PromptMode>,
       trials_per_mode: u32,
       project_name: &str,
       config: &Config,
       event_tx: mpsc::UnboundedSender<TrialEvent>,
       cancel_token: CancellationToken,
   ) -> Vec<TrialResult> {
       use tokio::task::JoinSet;
       use tokio::sync::Semaphore;

       // Limit parallelism to avoid API rate limits
       let semaphore = Arc::new(Semaphore::new(3));
       let mut set = JoinSet::new();

       for mode in &modes {
           for trial_num in 1..=trials_per_mode {
               let permit = semaphore.clone().acquire_owned().await.unwrap();
               let tx = event_tx.clone();
               let mode = *mode;
               let config = config.clone();
               let project_name = project_name.to_string();
               let cancel = cancel_token.clone();

               set.spawn(async move {
                   let _permit = permit; // Hold until done
                   run_single_trial_parallel(mode, trial_num, &project_name, &config, tx, cancel).await
               });
           }
       }

       let mut results = Vec::new();
       while let Some(result) = set.join_next().await {
           match result {
               Ok(Ok(trial_result)) => results.push(trial_result),
               Ok(Err(e)) => eprintln!("Trial failed: {}", e),
               Err(e) => eprintln!("Task panicked: {}", e),
           }
       }

       results
   }
   ```

4. Add helper function run_single_trial_parallel that wraps existing run_single_trial and sends TrialEvents.

5. Export from src/eval/mod.rs:
   ```rust
   mod parallel;
   pub use parallel::{run_parallel_evals, TrialEvent, TrialEventKind, TrialResult};
   ```

Use Arc::new(Semaphore::new(3)) for parallelism limit - this prevents API rate limiting. Follow the pattern from 13-RESEARCH.md.
  </action>
  <verify>
`cargo build` succeeds.
`cargo test -p rslph` runs without errors.
  </verify>
  <done>
parallel.rs exports run_parallel_evals, TrialEvent, TrialEventKind, TrialResult.
JoinSet manages parallel trial spawning with Semaphore for rate limiting.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate parallel execution into eval command handler</name>
  <files>src/eval/command.rs, src/main.rs</files>
  <action>
Update src/eval/command.rs to use parallel execution when multiple modes specified:

1. Modify run_eval_command signature to accept modes:
   ```rust
   pub async fn run_eval_command(
       project_name: &str,
       trials: u32,
       modes: Option<Vec<PromptMode>>,  // NEW
       keep: bool,
       no_tui: bool,
       config: &Config,
   ) -> color_eyre::Result<EvalResult>
   ```

2. Add branch at start of function:
   ```rust
   // If multiple modes specified, use parallel execution
   let modes = modes.unwrap_or_else(|| vec![config.prompt_mode]);

   if modes.len() > 1 || trials > 1 {
       return run_parallel_eval_mode(
           project_name, trials, &modes, keep, no_tui, config
       ).await;
   }

   // Single mode, single trial - use existing sequential logic
   // ... existing code ...
   ```

3. Create run_parallel_eval_mode helper function that:
   - Creates aggregator channel for TrialEvents
   - Calls run_parallel_evals with event sender
   - Aggregates results by mode
   - Computes and prints statistics per mode
   - Saves results to JSON with mode grouping

4. Update MultiTrialResult to include mode information:
   ```rust
   pub struct MultiTrialResult {
       pub project: String,
       pub modes: Vec<ModeResult>,  // NEW: Group by mode
       pub timestamp: String,
       // ... keep existing fields for backward compatibility
   }

   pub struct ModeResult {
       pub mode: PromptMode,
       pub trials: Vec<EvalResult>,
       pub statistics: Statistics,
   }
   ```

5. Update src/main.rs to pass modes from CLI to run_eval_command.

Note: For backward compatibility, when only single mode used (either from config or explicit), output format remains unchanged. Multi-mode output groups results by mode.
  </action>
  <verify>
`cargo build` succeeds.
`cargo test` passes.
Running `./target/debug/rslph eval calculator --trials 2` works (sequential fallback).
Running `./target/debug/rslph eval --list` still works.
  </verify>
  <done>
run_eval_command handles --modes flag.
Multiple modes trigger parallel execution via run_parallel_evals.
Results are grouped by mode in output.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --release` succeeds without warnings
2. `cargo test` passes all tests including new CLI parsing tests
3. `./target/release/rslph eval --help` shows --modes flag with description
4. Unit tests verify TrialEvent serialization and JoinSet completion
</verification>

<success_criteria>
1. User can run `rslph eval calculator --modes basic,gsd,gsd_tdd --trials 3` (9 parallel trials)
2. Semaphore limits concurrent trials to 3 to avoid API rate limits
3. Results are grouped by mode in console output
4. JSON output includes mode grouping for multi-mode runs
5. Single-mode runs maintain backward-compatible behavior
</success_criteria>

<output>
After completion, create `.planning/phases/13-parallel-eval-tui/13-01-SUMMARY.md`
</output>
