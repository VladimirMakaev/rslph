---
phase: 13-parallel-eval-tui
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/tui/dashboard.rs
  - src/tui/mod.rs
  - src/tui/app.rs
  - src/eval/command.rs
  - src/eval/parallel.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User sees real-time progress of all parallel trials in TUI dashboard"
    - "Dashboard shows mode, trial number, iteration, elapsed time per trial"
    - "Completed trials show pass rate, failed trials show error"
  artifacts:
    - path: "src/tui/dashboard.rs"
      provides: "Dashboard widget for parallel eval"
      exports: ["DashboardState", "render_dashboard"]
    - path: "src/tui/app.rs"
      provides: "Extended App state for dashboard mode"
      contains: "DashboardState"
  key_links:
    - from: "src/eval/command.rs"
      to: "src/tui/dashboard.rs"
      via: "TrialEvent updates DashboardState"
      pattern: "DashboardState.*update"
    - from: "src/tui/dashboard.rs"
      to: "ratatui render"
      via: "render_dashboard called from UI"
      pattern: "render_dashboard.*Frame"
---

<objective>
Create TUI dashboard for parallel eval execution showing real-time progress.

Purpose: Give users visibility into parallel eval runs with at-a-glance progress for each trial/mode combination.

Output: Multi-pane dashboard showing all trials with progress bars, status, elapsed time, and pass rates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-parallel-eval-tui/13-RESEARCH.md
@.planning/phases/13-parallel-eval-tui/13-01-SUMMARY.md

@src/tui/app.rs
@src/tui/ui.rs
@src/tui/run.rs
@src/eval/parallel.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard state and widget module</name>
  <files>src/tui/dashboard.rs, src/tui/mod.rs</files>
  <action>
Create src/tui/dashboard.rs with dashboard state and rendering:

1. Define DashboardState to track all parallel trials:
   ```rust
   use crate::eval::parallel::{TrialEvent, TrialEventKind};
   use crate::prompts::PromptMode;
   use std::collections::HashMap;
   use std::time::Instant;

   #[derive(Debug, Clone)]
   pub struct DashboardState {
       /// Trial progress keyed by (mode, trial_num)
       pub trials: HashMap<(PromptMode, u32), TrialProgress>,
       /// Start time for elapsed calculation
       pub start_time: Instant,
       /// Whether all trials are complete
       pub all_complete: bool,
   }

   #[derive(Debug, Clone)]
   pub struct TrialProgress {
       pub mode: PromptMode,
       pub trial_num: u32,
       pub status: TrialStatus,
       pub current_iteration: u32,
       pub max_iterations: u32,
       pub elapsed_secs: f64,
       pub pass_rate: Option<f64>,
       pub error: Option<String>,
   }

   #[derive(Debug, Clone, PartialEq)]
   pub enum TrialStatus {
       Pending,
       Planning,
       Building,
       Testing,
       Complete,
       Failed,
   }
   ```

2. Implement DashboardState methods:
   ```rust
   impl DashboardState {
       pub fn new(modes: &[PromptMode], trials_per_mode: u32) -> Self {
           let mut trials = HashMap::new();
           for mode in modes {
               for trial_num in 1..=trials_per_mode {
                   trials.insert((*mode, trial_num), TrialProgress {
                       mode: *mode,
                       trial_num,
                       status: TrialStatus::Pending,
                       current_iteration: 0,
                       max_iterations: 0,
                       elapsed_secs: 0.0,
                       pass_rate: None,
                       error: None,
                   });
               }
           }
           Self {
               trials,
               start_time: Instant::now(),
               all_complete: false,
           }
       }

       pub fn update(&mut self, event: &TrialEvent) {
           if let Some(trial) = self.trials.get_mut(&(event.mode, event.trial_num)) {
               match &event.event {
                   TrialEventKind::Started => trial.status = TrialStatus::Pending,
                   TrialEventKind::Planning => trial.status = TrialStatus::Planning,
                   TrialEventKind::Building { iteration, max_iterations } => {
                       trial.status = TrialStatus::Building;
                       trial.current_iteration = *iteration;
                       trial.max_iterations = *max_iterations;
                   }
                   TrialEventKind::Testing => trial.status = TrialStatus::Testing,
                   TrialEventKind::Complete { result } => {
                       trial.status = TrialStatus::Complete;
                       trial.pass_rate = Some(result.eval_result.pass_rate);
                       trial.elapsed_secs = result.eval_result.elapsed_secs;
                   }
                   TrialEventKind::Failed { error } => {
                       trial.status = TrialStatus::Failed;
                       trial.error = Some(error.clone());
                   }
               }
           }

           // Check if all complete
           self.all_complete = self.trials.values()
               .all(|t| matches!(t.status, TrialStatus::Complete | TrialStatus::Failed));
       }
   }
   ```

3. Export from src/tui/mod.rs:
   ```rust
   pub mod dashboard;
   pub use dashboard::{DashboardState, TrialProgress, TrialStatus};
   ```
  </action>
  <verify>
`cargo build` succeeds.
`cargo test -p rslph` passes.
  </verify>
  <done>
DashboardState tracks all trials with status, progress, elapsed time.
update() method processes TrialEvent to update trial state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement dashboard rendering with multi-pane grid</name>
  <files>src/tui/dashboard.rs</files>
  <action>
Add rendering functions to src/tui/dashboard.rs:

1. Create render_dashboard function for grid layout:
   ```rust
   use ratatui::{
       layout::{Constraint, Direction, Layout, Rect},
       style::{Color, Modifier, Style},
       text::{Line, Span},
       widgets::{Block, Borders, Gauge, Paragraph},
       Frame,
   };

   pub fn render_dashboard(frame: &mut Frame, area: Rect, state: &DashboardState) {
       // Group trials by mode for column layout
       let mut modes: Vec<PromptMode> = state.trials.keys()
           .map(|(m, _)| *m)
           .collect::<std::collections::HashSet<_>>()
           .into_iter()
           .collect();
       modes.sort_by_key(|m| format!("{:?}", m)); // Consistent ordering

       let mode_count = modes.len();
       if mode_count == 0 {
           return;
       }

       // Create columns for each mode
       let col_constraints: Vec<Constraint> = (0..mode_count)
           .map(|_| Constraint::Percentage(100 / mode_count as u16))
           .collect();

       let columns = Layout::horizontal(col_constraints).split(area);

       for (col_idx, mode) in modes.iter().enumerate() {
           render_mode_column(frame, columns[col_idx], *mode, state);
       }
   }

   fn render_mode_column(frame: &mut Frame, area: Rect, mode: PromptMode, state: &DashboardState) {
       // Get trials for this mode
       let mut trials: Vec<&TrialProgress> = state.trials.values()
           .filter(|t| t.mode == mode)
           .collect();
       trials.sort_by_key(|t| t.trial_num);

       // Header + trial rows
       let row_constraints: Vec<Constraint> = std::iter::once(Constraint::Length(2))
           .chain(trials.iter().map(|_| Constraint::Length(4)))
           .chain(std::iter::once(Constraint::Min(0))) // Filler
           .collect();

       let rows = Layout::vertical(row_constraints).split(area);

       // Render mode header
       let header = Paragraph::new(format!("{:?}", mode))
           .style(Style::default().add_modifier(Modifier::BOLD))
           .block(Block::default().borders(Borders::BOTTOM));
       frame.render_widget(header, rows[0]);

       // Render each trial
       for (idx, trial) in trials.iter().enumerate() {
           render_trial_cell(frame, rows[idx + 1], trial);
       }
   }

   fn render_trial_cell(frame: &mut Frame, area: Rect, trial: &TrialProgress) {
       let status_color = match trial.status {
           TrialStatus::Pending => Color::DarkGray,
           TrialStatus::Planning => Color::Yellow,
           TrialStatus::Building => Color::Blue,
           TrialStatus::Testing => Color::Cyan,
           TrialStatus::Complete => Color::Green,
           TrialStatus::Failed => Color::Red,
       };

       let block = Block::default()
           .borders(Borders::ALL)
           .border_style(Style::default().fg(status_color))
           .title(format!("Trial {}", trial.trial_num));

       let inner = block.inner(area);
       frame.render_widget(block, area);

       let [status_area, progress_area] = Layout::vertical([
           Constraint::Length(1),
           Constraint::Length(1),
       ]).areas(inner);

       // Status line
       let status_text = match &trial.status {
           TrialStatus::Pending => "Pending...".to_string(),
           TrialStatus::Planning => "Planning...".to_string(),
           TrialStatus::Building => format!("Build {}/{}", trial.current_iteration, trial.max_iterations),
           TrialStatus::Testing => "Testing...".to_string(),
           TrialStatus::Complete => format!("Done: {:.0}%", trial.pass_rate.unwrap_or(0.0) * 100.0),
           TrialStatus::Failed => "FAILED".to_string(),
       };
       let status = Paragraph::new(status_text).style(Style::default().fg(status_color));
       frame.render_widget(status, status_area);

       // Progress bar (only for building status)
       if trial.status == TrialStatus::Building && trial.max_iterations > 0 {
           let progress = trial.current_iteration as f64 / trial.max_iterations as f64;
           let gauge = Gauge::default()
               .ratio(progress.min(1.0))
               .gauge_style(Style::default().fg(Color::Blue));
           frame.render_widget(gauge, progress_area);
       }
   }
   ```

2. Add overall elapsed time header rendering (optional helper).
  </action>
  <verify>
`cargo build` succeeds.
  </verify>
  <done>
render_dashboard creates grid layout with columns per mode.
Each trial cell shows status, progress bar, pass rate.
Color coding indicates trial status.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate dashboard into parallel eval TUI loop</name>
  <files>src/eval/command.rs, src/tui/app.rs, src/tui/run.rs</files>
  <action>
Wire dashboard into the parallel eval execution path:

1. Add DashboardApp variant or extend App in src/tui/app.rs:
   ```rust
   pub enum AppMode {
       Build(App),           // Existing build TUI
       Dashboard(DashboardState),  // New dashboard mode
   }
   ```

2. Create run_dashboard_tui function in src/tui/run.rs or src/tui/dashboard.rs:
   ```rust
   pub async fn run_dashboard_tui(
       modes: Vec<PromptMode>,
       trials_per_mode: u32,
       event_rx: mpsc::UnboundedReceiver<TrialEvent>,
       cancel_token: CancellationToken,
   ) -> Result<(), RslphError> {
       let mut terminal = init_terminal()?;
       let mut state = DashboardState::new(&modes, trials_per_mode);
       let mut event_rx = event_rx;

       loop {
           // Render
           terminal.draw(|frame| {
               render_dashboard(frame, frame.area(), &state);
           })?;

           // Poll for events with timeout for responsive rendering
           tokio::select! {
               biased;

               _ = cancel_token.cancelled() => {
                   break;
               }

               event = event_rx.recv() => {
                   match event {
                       Some(trial_event) => {
                           state.update(&trial_event);
                           if state.all_complete {
                               // Keep displayed for a moment, then exit
                               tokio::time::sleep(Duration::from_secs(2)).await;
                               break;
                           }
                       }
                       None => break, // Channel closed
                   }
               }

               _ = tokio::time::sleep(Duration::from_millis(100)) => {
                   // Refresh elapsed times
                   // (actual elapsed calc would need per-trial start times)
               }
           }
       }

       restore_terminal()?;
       Ok(())
   }
   ```

3. Update run_parallel_eval_mode in src/eval/command.rs to spawn dashboard TUI:
   ```rust
   async fn run_parallel_eval_mode(...) -> Result<EvalResult> {
       let (event_tx, event_rx) = mpsc::unbounded_channel();

       if !no_tui {
           // Spawn dashboard TUI
           let modes_clone = modes.clone();
           let cancel_clone = cancel_token.clone();
           tokio::spawn(async move {
               if let Err(e) = run_dashboard_tui(modes_clone, trials, event_rx, cancel_clone).await {
                   eprintln!("Dashboard error: {}", e);
               }
           });
       }

       // Run parallel evals
       let results = run_parallel_evals(
           modes.clone(), trials, project_name, config, event_tx, cancel_token
       ).await;

       // ... aggregate and return results
   }
   ```

4. Handle keyboard input in dashboard (q to quit, arrow keys to focus trial - optional).
  </action>
  <verify>
`cargo build` succeeds.
`cargo test` passes.
Running `./target/debug/rslph eval calculator --modes basic,gsd --trials 2` shows dashboard (with fake_claude or real Claude).
  </verify>
  <done>
Dashboard TUI displays during parallel eval execution.
Trial events update dashboard in real-time.
Dashboard shows grid of trials with progress and status.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --release` succeeds without warnings
2. `cargo test` passes all tests
3. Dashboard renders correctly with multiple modes and trials
4. Trial status updates in real-time as events flow through channel
5. Dashboard closes gracefully when all trials complete
</verification>

<success_criteria>
1. TUI dashboard shows real-time progress: mode, trial number, current iteration, pass rate, elapsed time
2. Grid layout with columns per mode, rows per trial
3. Color coding for trial status (pending/planning/building/testing/complete/failed)
4. Progress bars for building phase
5. Dashboard closes automatically when all trials complete (with brief delay to show final state)
</success_criteria>

<output>
After completion, create `.planning/phases/13-parallel-eval-tui/13-02-SUMMARY.md`
</output>
