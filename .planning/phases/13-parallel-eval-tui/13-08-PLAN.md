# Phase 13 Plan 08: Wire Iteration Progress to Dashboard TUI

---
phase: 13-parallel-eval-tui
plan: 08
type: execute
wave: 3
depends_on: ["09"]
files_modified:
  - src/eval/command.rs
  - src/eval/parallel.rs
  - src/build/command.rs
  - src/build/iteration.rs
  - src/main.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Dashboard shows real-time iteration progress for each parallel trial"
    - "User sees 'Building 3/10' instead of perpetual 'Planning...'"
  artifacts:
    - path: "src/eval/parallel.rs"
      provides: "TrialEventKind::Building events sent during build"
      contains: "TrialEventKind::Building"
    - path: "src/eval/command.rs"
      provides: "Progress callback wiring from build to trial events"
      contains: "progress_callback"
  key_links:
    - from: "src/build/iteration.rs"
      to: "src/eval/parallel.rs"
      via: "progress callback or channel"
      pattern: "progress_callback|event_tx"
---

<objective>
Wire iteration progress from build execution to the parallel eval dashboard TUI.

Purpose: The dashboard TUI currently shows trials stuck at "Planning..." because TrialEventKind::Building is defined but never sent. This makes parallel eval unusable for monitoring progress.

Output: Dashboard shows real-time iteration progress (e.g., "Building 3/10") for each parallel trial.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v1.2-MILESTONE-AUDIT.md (Gap 0 details)

@src/eval/parallel.rs (TrialEventKind::Building defined but never sent)
@src/eval/command.rs (run_single_trial_with_mode calls run_single_trial)
@src/build/command.rs (run_build_command signature)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add progress callback to run_single_trial</name>
  <files>src/eval/command.rs</files>
  <action>
Modify `run_single_trial` and `run_single_trial_with_mode` to accept an optional progress callback:

1. Add a new type alias at the top of the file:
   ```rust
   pub type ProgressCallback = Arc<dyn Fn(u32, u32) + Send + Sync>;
   ```

2. Add `progress_callback: Option<ProgressCallback>` parameter to `run_single_trial`:
   ```rust
   async fn run_single_trial(
       project: &str,
       trial_num: u32,
       no_tui: bool,
       config: &Config,
       cancel_token: CancellationToken,
       progress_callback: Option<ProgressCallback>,
   ) -> color_eyre::Result<EvalResult>
   ```

3. Pass the callback through to `run_build_command` (Task 2 will add this parameter).

4. Update `run_single_trial_with_mode` to also accept and forward the callback.

5. Update the call in `run_eval_command` to pass `None` for backward compatibility.
  </action>
  <verify>cargo check --lib compiles with no errors</verify>
  <done>run_single_trial accepts optional progress callback parameter</done>
</task>

<task type="auto">
  <name>Task 2: Add progress callback to run_build_command</name>
  <files>src/build/command.rs, src/main.rs</files>
  <action>
Add progress callback support to build command:

1. Add type import at top:
   ```rust
   use std::sync::Arc;
   ```

2. Add callback parameter to `run_build_command` signature:
   ```rust
   pub async fn run_build_command(
       progress_path: PathBuf,
       once: bool,
       dry_run: bool,
       no_tui: bool,
       config: &Config,
       cancel_token: CancellationToken,
       progress_callback: Option<Arc<dyn Fn(u32, u32) + Send + Sync>>,
   ) -> color_eyre::Result<TokenUsage>
   ```

3. In the headless build loop (after `BuildState::Running { iteration }`), invoke the callback:
   ```rust
   if let Some(ref cb) = progress_callback {
       cb(iteration, config.max_iterations as u32);
   }
   ```

4. Update all callers of `run_build_command` to pass `None` for backward compatibility:
   - In `src/main.rs` (build subcommand)
   - In `src/eval/command.rs` (run_single_trial)
  </action>
  <verify>cargo check compiles with no errors</verify>
  <done>run_build_command accepts optional progress callback and invokes it each iteration</done>
</task>

<task type="auto">
  <name>Task 3: Send TrialEventKind::Building in parallel mode</name>
  <files>src/eval/parallel.rs, src/eval/command.rs</files>
  <action>
Wire the progress callback to send Building events:

1. In `run_single_trial_parallel` (parallel.rs), create a progress callback that sends Building events:
   ```rust
   // Create progress callback that sends Building events
   let tx_clone = event_tx.clone();
   let mode_copy = mode;
   let trial_copy = trial_num;
   let progress_callback: Option<Arc<dyn Fn(u32, u32) + Send + Sync>> = Some(Arc::new(move |iteration, max_iterations| {
       let _ = tx_clone.send(TrialEvent {
           mode: mode_copy,
           trial_num: trial_copy,
           event: TrialEventKind::Building { iteration, max_iterations },
       });
   }));
   ```

2. Update the call to `run_single_trial_with_mode` to pass this callback.
  </action>
  <verify>cargo test --lib -- parallel passes</verify>
  <done>Building events are sent during parallel trial execution</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with no errors
2. `cargo test` passes all existing tests
3. Run `rslph eval calculator --modes basic,gsd --trials 2 --no-tui` and observe Building events in output:
   ```
   [basic/1] Building iteration 1/10
   [basic/1] Building iteration 2/10
   ...
   ```
4. With TUI: dashboard shows iteration progress instead of stuck "Planning..."
</verification>

<success_criteria>
1. Dashboard TUI shows real-time iteration progress during parallel eval
2. User sees "Building X/Y" for each trial in progress
3. All existing tests pass
4. Backward compatibility maintained (single-trial eval still works)
</success_criteria>

<output>
After completion, create `.planning/phases/13-parallel-eval-tui/13-08-SUMMARY.md`
</output>
