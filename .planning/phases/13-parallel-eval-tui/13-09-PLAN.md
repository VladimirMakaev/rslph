# Phase 13 Plan 09: Mode Passthrough to Plan/Build Commands

---
phase: 13-parallel-eval-tui
plan: 09
type: execute
wave: 3
depends_on: []
files_modified:
  - src/eval/command.rs
  - src/eval/mod.rs
  - src/planning/command.rs
  - src/build/command.rs
  - src/build/state.rs
  - src/build/iteration.rs
  - src/prompts/mod.rs
  - src/main.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Parallel eval with --modes basic,gsd,gsd_tdd runs each mode with correct prompts"
    - "Results JSON shows actual mode used per trial (not all 'basic')"
    - "Different modes produce measurably different agent behavior"
  artifacts:
    - path: "src/eval/command.rs"
      provides: "Mode passed through run_single_trial_with_mode"
      contains: "run_single_trial_with_mode.*mode.*run_single_trial.*mode"
    - path: "src/planning/command.rs"
      provides: "Mode parameter in run_plan_command"
      contains: "mode: PromptMode"
    - path: "src/build/command.rs"
      provides: "Mode parameter in run_build_command"
      contains: "mode: PromptMode"
  key_links:
    - from: "src/eval/command.rs"
      to: "src/planning/command.rs"
      via: "mode parameter"
      pattern: "run_plan_command.*mode"
    - from: "src/eval/command.rs"
      to: "src/build/command.rs"
      via: "mode parameter"
      pattern: "run_build_command.*mode"
---

<objective>
Pass prompt mode through eval trials to plan and build commands.

Purpose: Currently `run_single_trial_with_mode` ignores the mode parameter (prefixed with `_`), so all parallel eval trials run with the default Basic mode regardless of what `--modes` specifies. This makes mode comparison meaningless.

Output: Each trial runs with its assigned mode, and results reflect actual mode differences.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/milestones/v1.2-MILESTONE-AUDIT.md (Gap 1 details)

@src/eval/command.rs (run_single_trial_with_mode has unused _mode parameter)
@src/planning/command.rs (run_plan_command uses get_plan_prompt(config))
@src/build/command.rs (run_build_command signature)
@src/prompts/mod.rs (get_plan_prompt, get_build_prompt functions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mode parameter to run_plan_command</name>
  <files>src/planning/command.rs, src/prompts/mod.rs, src/main.rs</files>
  <action>
1. Update `run_plan_command` signature to accept mode:
   ```rust
   pub async fn run_plan_command(
       input: &str,
       adaptive: bool,
       tui: bool,
       mode: PromptMode,  // NEW: explicit mode instead of config default
       config: &Config,
       working_dir: &Path,
       cancel_token: CancellationToken,
       timeout: Duration,
   ) -> color_eyre::Result<(PathBuf, TokenUsage)>
   ```

2. Add import for PromptMode at top of file:
   ```rust
   use crate::prompts::PromptMode;
   ```

3. Update `run_basic_planning` and related functions to accept and use mode.

4. Change the call to `get_plan_prompt(config)` to `get_plan_prompt_for_mode(mode)` or pass mode to existing function.

5. In `src/prompts/mod.rs`, add a function that gets prompt for specific mode:
   ```rust
   pub fn get_plan_prompt_for_mode(mode: PromptMode) -> color_eyre::Result<String>
   ```
   This should select the correct planning prompt based on mode (Basic, Gsd, GsdTdd).

6. Update CLI call in `src/main.rs` to pass `config.prompt_mode` for backward compatibility.
  </action>
  <verify>cargo check compiles with no errors</verify>
  <done>run_plan_command accepts explicit mode parameter</done>
</task>

<task type="auto">
  <name>Task 2: Add mode parameter to run_build_command</name>
  <files>src/build/command.rs, src/build/state.rs, src/build/iteration.rs, src/prompts/mod.rs, src/main.rs</files>
  <action>
1. Update `run_build_command` signature to accept mode:
   ```rust
   pub async fn run_build_command(
       progress_path: PathBuf,
       once: bool,
       dry_run: bool,
       no_tui: bool,
       mode: PromptMode,  // NEW: explicit mode
       config: &Config,
       cancel_token: CancellationToken,
   ) -> color_eyre::Result<TokenUsage>
   ```

2. Add import for PromptMode at top of file:
   ```rust
   use crate::prompts::PromptMode;
   ```

3. Store mode in BuildContext so iterations use correct prompts:
   - In `src/build/state.rs`, add `pub mode: PromptMode` to BuildContext
   - Update BuildContext::new to accept mode parameter

4. In `src/build/iteration.rs`, use `ctx.mode` when getting build prompt instead of `config.prompt_mode`.

5. In `src/prompts/mod.rs`, ensure `get_build_prompt_for_mode(mode)` exists or update existing function.

6. Update CLI call in `src/main.rs` to pass `config.prompt_mode` for backward compatibility.
  </action>
  <verify>cargo check compiles with no errors</verify>
  <done>run_build_command accepts explicit mode parameter and uses it for prompts</done>
</task>

<task type="auto">
  <name>Task 3: Wire mode through run_single_trial_with_mode</name>
  <files>src/eval/command.rs</files>
  <action>
1. Remove underscore from mode parameter (change `_mode` to `mode`):
   ```rust
   pub async fn run_single_trial_with_mode(
       project: &str,
       trial_num: u32,
       mode: PromptMode,  // No longer unused
       no_tui: bool,
       config: &Config,
       cancel_token: CancellationToken,
   ) -> color_eyre::Result<EvalResult>
   ```

2. Remove the TODO comment about passing mode.

3. Update `run_single_trial` to accept mode parameter:
   ```rust
   async fn run_single_trial(
       project: &str,
       trial_num: u32,
       mode: PromptMode,  // NEW
       no_tui: bool,
       config: &Config,
       cancel_token: CancellationToken,
   ) -> color_eyre::Result<EvalResult>
   ```

4. Pass mode to `run_plan_command`:
   ```rust
   let (progress_path, plan_tokens) = run_plan_command(
       &prompt,
       false, // not adaptive
       false, // not tui
       mode,  // Pass the mode
       config,
       &working_dir,
       cancel_token.clone(),
       timeout,
   )
   .await?;
   ```

5. Pass mode to `run_build_command`:
   ```rust
   let build_tokens = run_build_command(
       progress_path.clone(),
       false,          // not once
       false,          // not dry-run
       no_tui || true, // force no-tui for eval
       mode,           // Pass the mode
       config,
       cancel_token.clone(),
   )
   .await?;
   ```

6. Update `run_eval_command` to pass the resolved mode (for single-mode case):
   ```rust
   let result = run_single_trial(&project, trial_num, resolved_modes[0], no_tui, config, cancel_token.clone()).await?;
   ```
  </action>
  <verify>cargo check compiles with no errors</verify>
  <done>Mode is passed through entire eval pipeline to plan and build commands</done>
</task>

<task type="auto">
  <name>Task 4: Add mode field to EvalResult JSON</name>
  <files>src/eval/command.rs, src/eval/mod.rs</files>
  <action>
1. Add `mode` field to `EvalResult` struct in `src/eval/mod.rs`:
   ```rust
   pub struct EvalResult {
       pub project: String,
       pub trial_num: u32,
       pub mode: PromptMode,  // NEW: which mode was used
       pub elapsed_secs: f64,
       pub total_tokens: TokenUsage,
       pub iterations: u32,
       pub workspace_path: Option<PathBuf>,
       pub test_results: Option<TestResults>,
   }
   ```

2. Update `run_single_trial` to populate the mode field:
   ```rust
   let result = EvalResult {
       project: project.to_string(),
       trial_num,
       mode,  // Add this
       elapsed_secs,
       ...
   };
   ```

3. Update `SerializableResult` to include mode as string:
   ```rust
   struct SerializableResult {
       project: String,
       mode: String,  // NEW
       elapsed_secs: f64,
       ...
   }
   ```

4. Update `save_result_json` to serialize mode:
   ```rust
   let serializable = SerializableResult {
       project: result.project.clone(),
       mode: result.mode.to_string(),  // Add this
       ...
   };
   ```

5. Update `SerializableTrialSummary` and `convert_trial_to_serializable` similarly.
  </action>
  <verify>cargo test --lib passes</verify>
  <done>EvalResult includes mode field, JSON output shows which mode was used</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds with no errors
2. `cargo test` passes all existing tests
3. Run `rslph eval calculator --modes basic,gsd --trials 1` and verify:
   - Different prompts are used for basic vs gsd trials
   - Result JSON shows correct mode for each trial
4. Single-mode eval still works: `rslph eval calculator --trials 1`
5. Build and plan commands still work standalone with default config mode
</verification>

<success_criteria>
1. Parallel eval with `--modes basic,gsd,gsd_tdd` runs each trial with correct mode
2. Result JSON includes mode field showing which mode was used
3. Different modes produce different agent behavior (visible in prompts/output)
4. All existing tests pass
5. Backward compatibility maintained for non-parallel usage
</success_criteria>

<output>
After completion, create `.planning/phases/13-parallel-eval-tui/13-09-SUMMARY.md`
</output>
