---
phase: 14-tui-visual-parity
plan: 06
type: execute
wave: 3
depends_on: ["14-02", "14-03", "14-04", "14-05"]
files_modified:
  - src/tui/ui.rs
  - src/tui/app.rs
  - src/tui/event.rs
autonomous: true

must_haves:
  truths:
    - "Spinner displays in status bar during streaming"
    - "Spinner stops when streaming completes"
    - "Key binding exists to toggle thinking block collapse"
    - "UI correctly renders all themed components together"
  artifacts:
    - path: "src/tui/ui.rs"
      provides: "Spinner rendering integrated into main UI"
      contains: "render_spinner|spinner"
    - path: "src/tui/app.rs"
      provides: "ToggleThinkingCollapse event variant and handler"
      contains: "ToggleThinkingCollapse"
  key_links:
    - from: "src/tui/ui.rs"
      to: "src/tui/widgets/spinner.rs"
      via: "spinner render call"
      pattern: "render_spinner"
    - from: "src/tui/app.rs"
      to: "toggle_all_thinking_collapsed"
      via: "App::update handles ToggleThinkingCollapse"
      pattern: "ToggleThinkingCollapse.*toggle_all_thinking_collapsed"
    - from: "src/tui/event.rs"
      to: "AppEvent::ToggleThinkingCollapse"
      via: "KeyCode::Char('t') mapping"
      pattern: "KeyCode::Char\\('t'\\)"
---

<objective>
Integrate all visual parity components into the main TUI rendering and event handling.

Purpose: Wire the spinner into the UI, connect streaming state changes to spinner activation, and add key bindings for thinking block toggle. This final plan brings together all the individual components into a cohesive visual experience.

Output: Complete integration of spinner in UI, event-driven streaming state, and key binding for collapse toggle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-RESEARCH.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-01-SUMMARY.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-02-SUMMARY.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-03-SUMMARY.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-04-SUMMARY.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-05-SUMMARY.md
@src/tui/ui.rs
@src/tui/app.rs
@src/tui/event.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate spinner into status bar area</name>
  <files>src/tui/ui.rs</files>
  <action>
Update src/tui/ui.rs to render spinner when streaming:

1. Add import:
   ```rust
   use super::widgets::spinner::render_spinner;
   ```

2. Modify the render function to show spinner in status area when streaming:
   - After render_header call, check if app.is_streaming
   - If streaming, render spinner in a small area (e.g., right side of header or start of body)

   Option A - Spinner in header area:
   ```rust
   // In render function, after header render
   if app.is_streaming {
       // Create a small spinner area at right of header
       let spinner_area = Rect {
           x: header.x + header.width - 15,
           y: header.y,
           width: 15,
           height: 1,
       };
       render_spinner(frame, spinner_area, &mut app.spinner_state, "");
   }
   ```

   Option B - Spinner as status indicator in branding line:
   - Modify render_header to optionally show spinner
   - Pass is_streaming flag to header rendering

   Choose the approach that integrates cleanly with existing layout.
   The spinner should be visible but not disruptive.

3. Make sure spinner_state is passed as mutable reference (may need App to be &mut in render signature or use interior mutability pattern).

Note: If App is immutable in render, the spinner state advancement happens in run.rs tick, and render just displays current state. In that case, render_spinner signature may need ThrobberState clone or adjust to work with immutable state.
  </action>
  <verify>
`cargo check` succeeds.
`grep -n "render_spinner|is_streaming" src/tui/ui.rs` shows integration.
  </verify>
  <done>Spinner renders in UI when app.is_streaming is true</done>
</task>

<task type="auto">
  <name>Task 2: Connect streaming state to events in App::update</name>
  <files>src/tui/app.rs</files>
  <action>
Update src/tui/app.rs to manage streaming state within the App::update method.

StreamEvent processing happens in App::update() within the AppEvent::StreamEvent(stream_event) match arm (around lines 431-441). This is where we detect content start/stop.

1. Add streaming state field to App struct (if not already present from Plan 05):
   ```rust
   /// Whether Claude is currently streaming a response.
   pub is_streaming: bool,
   ```

2. Initialize in Default impl:
   ```rust
   is_streaming: false,
   ```

3. Add helper methods:
   ```rust
   /// Start streaming state (activates spinner).
   pub fn start_streaming(&mut self) {
       self.is_streaming = true;
   }

   /// Stop streaming state (deactivates spinner).
   pub fn stop_streaming(&mut self) {
       self.is_streaming = false;
   }
   ```

4. Modify the AppEvent::StreamEvent handler to detect streaming start/stop:
   ```rust
   AppEvent::StreamEvent(stream_event) => {
       // Extract conversation items from the stream event
       let items = stream_event.extract_conversation_items();

       // Detect streaming state from items
       for item in &items {
           match item {
               // Content means streaming is active
               ConversationItem::Text(_) |
               ConversationItem::Thinking(_) |
               ConversationItem::ToolUse { .. } => {
                   if !self.is_streaming {
                       self.start_streaming();
                   }
               }
               // ToolResult typically means a message block completed
               ConversationItem::ToolResult { .. } => {
                   // Keep streaming - more content may come
               }
           }
       }

       for item in items {
           self.conversation.push(item);
       }

       // Auto-scroll to keep recent items visible
       if self.conversation.len() > 20 {
           self.conversation_scroll = self.conversation.len().saturating_sub(20);
       }
   }
   ```

5. Stop streaming on iteration complete:
   ```rust
   AppEvent::IterationComplete { tasks_done } => {
       // ... existing code ...
       self.stop_streaming();
   }
   ```

Note: The key insight is that StreamEvent processing happens in app.rs, not event.rs. The event.rs file only converts SubprocessEvent to AppEvent and forwards it.
  </action>
  <verify>
`cargo check` succeeds.
`grep -n "start_streaming\|stop_streaming\|is_streaming" src/tui/app.rs` shows state changes.
  </verify>
  <done>Streaming state updated based on LLM events (start on content, stop on iteration end)</done>
</task>

<task type="auto">
  <name>Task 3: Add key binding and event for thinking toggle</name>
  <files>src/tui/app.rs, src/tui/event.rs</files>
  <action>
Add a key binding to toggle thinking block collapse. Key bindings are mapped in event.rs in `convert_crossterm_event()`, and events are handled in app.rs in `App::update()`.

1. Add new AppEvent variant in src/tui/app.rs:
   ```rust
   pub enum AppEvent {
       // ... existing variants ...

       /// Toggle all thinking blocks collapsed/expanded.
       ToggleThinkingCollapse,
   }
   ```

2. Handle the new event in App::update() in src/tui/app.rs:
   ```rust
   AppEvent::ToggleThinkingCollapse => {
       self.toggle_all_thinking_collapsed();
   }
   ```

3. Map the key in src/tui/event.rs in `convert_crossterm_event()`:
   Find the match on key.code (around line 199) and add:
   ```rust
   KeyCode::Char('t') => Some(AppEvent::ToggleThinkingCollapse),
   ```

4. Update the footer help text to include 't:thinking' hint:
   - Find where key hints string is defined (likely in ui.rs render_footer or similar)
   - Add "t:thinking" to the hints

Note: The toggle_all_thinking_collapsed method was added in Plan 04 Task 1. This task just wires up the key binding to call it.
  </action>
  <verify>
`cargo check` succeeds.
`grep -n "ToggleThinkingCollapse" src/tui/app.rs` shows event variant and handler.
`grep -n "KeyCode::Char('t')" src/tui/event.rs` shows new key binding.
  </verify>
  <done>Key 't' toggles thinking block collapse state; footer hints updated</done>
</task>

</tasks>

<verification>
```bash
# Check compilation
cargo check

# Verify spinner integration
grep -n "render_spinner" src/tui/ui.rs
grep -n "is_streaming" src/tui/ui.rs

# Verify streaming state in App
grep -n "start_streaming\|stop_streaming" src/tui/app.rs

# Verify key binding in event.rs
grep -n "'t'" src/tui/event.rs
grep -n "ToggleThinkingCollapse" src/tui/event.rs

# Verify event handling in app.rs
grep -n "ToggleThinkingCollapse" src/tui/app.rs

# Run tests to ensure no regressions
cargo test --lib tui

# Full build
cargo build
```
</verification>

<success_criteria>
1. Spinner appears in UI when is_streaming is true
2. Spinner animates (advances on tick)
3. Spinner disappears when streaming stops
4. App::update handles StreamEvent to detect streaming start
5. App::update sets is_streaming false on iteration complete
6. AppEvent::ToggleThinkingCollapse variant exists
7. App::update handles ToggleThinkingCollapse by calling toggle_all_thinking_collapsed
8. Key 't' is mapped to ToggleThinkingCollapse in event.rs convert_crossterm_event
9. Footer help text includes thinking toggle hint
10. All TUI tests pass
11. `cargo build` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/14-tui-visual-parity-with-claude-code/14-06-SUMMARY.md`
</output>
