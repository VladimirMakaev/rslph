---
phase: 14-tui-visual-parity
plan: 06
type: execute
wave: 3
depends_on: ["14-02", "14-03", "14-04", "14-05"]
files_modified:
  - src/tui/ui.rs
  - src/tui/event.rs
  - src/tui/keybindings.rs
autonomous: true

must_haves:
  truths:
    - "Spinner displays in status bar during streaming"
    - "Spinner stops when streaming completes"
    - "Key binding exists to toggle thinking block collapse"
    - "UI correctly renders all themed components together"
  artifacts:
    - path: "src/tui/ui.rs"
      provides: "Spinner rendering integrated into main UI"
      contains: "render_spinner|spinner"
  key_links:
    - from: "src/tui/ui.rs"
      to: "src/tui/widgets/spinner.rs"
      via: "spinner render call"
      pattern: "render_spinner"
    - from: "src/tui/event.rs"
      to: "src/tui/app.rs"
      via: "start_streaming/stop_streaming calls"
      pattern: "start_streaming|stop_streaming"
---

<objective>
Integrate all visual parity components into the main TUI rendering and event handling.

Purpose: Wire the spinner into the UI, connect streaming state changes to spinner activation, and add key bindings for thinking block toggle. This final plan brings together all the individual components into a cohesive visual experience.

Output: Complete integration of spinner in UI, event-driven streaming state, and key binding for collapse toggle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-RESEARCH.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-01-SUMMARY.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-02-SUMMARY.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-03-SUMMARY.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-04-SUMMARY.md
@.planning/phases/14-tui-visual-parity-with-claude-code/14-05-SUMMARY.md
@src/tui/ui.rs
@src/tui/event.rs
@src/tui/keybindings.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate spinner into status bar area</name>
  <files>src/tui/ui.rs</files>
  <action>
Update src/tui/ui.rs to render spinner when streaming:

1. Add import:
   ```rust
   use super::widgets::spinner::render_spinner;
   ```

2. Modify the render function to show spinner in status area when streaming:
   - After render_header call, check if app.is_streaming
   - If streaming, render spinner in a small area (e.g., right side of header or start of body)

   Option A - Spinner in header area:
   ```rust
   // In render function, after header render
   if app.is_streaming {
       // Create a small spinner area at right of header
       let spinner_area = Rect {
           x: header.x + header.width - 15,
           y: header.y,
           width: 15,
           height: 1,
       };
       render_spinner(frame, spinner_area, &mut app.spinner_state, "");
   }
   ```

   Option B - Spinner as status indicator in branding line:
   - Modify render_header to optionally show spinner
   - Pass is_streaming flag to header rendering

   Choose the approach that integrates cleanly with existing layout.
   The spinner should be visible but not disruptive.

3. Make sure spinner_state is passed as mutable reference (may need App to be &mut in render signature or use interior mutability pattern).

Note: If App is immutable in render, the spinner state advancement happens in run.rs tick, and render just displays current state. In that case, render_spinner signature may need ThrobberState clone or adjust to work with immutable state.
  </action>
  <verify>
`cargo check` succeeds.
`grep -n "render_spinner|is_streaming" src/tui/ui.rs` shows integration.
  </verify>
  <done>Spinner renders in UI when app.is_streaming is true</done>
</task>

<task type="auto">
  <name>Task 2: Connect streaming state to events</name>
  <files>src/tui/event.rs</files>
  <action>
Update src/tui/event.rs to manage streaming state:

1. Find where SubprocessEvent or StreamEvent is processed
2. Set is_streaming = true when LLM streaming starts:
   - On ContentBlockStart, ContentBlockDelta events
   - On any event indicating active streaming

3. Set is_streaming = false when streaming ends:
   - On MessageStop, Error, or result completion events
   - On iteration completion

Look for the event handling code that processes Claude output events. The streaming starts when we receive the first content event and stops when the message is complete.

Example pattern:
```rust
// When content starts streaming
StreamEvent::ContentBlockStart { .. } => {
    app.start_streaming();
    // ... existing handling
}

// When message completes
StreamEvent::MessageStop { .. } | StreamEvent::Result { .. } => {
    app.stop_streaming();
    // ... existing handling
}
```
  </action>
  <verify>
`cargo check` succeeds.
`grep -n "start_streaming|stop_streaming" src/tui/event.rs` shows state changes.
  </verify>
  <done>Streaming state updated based on LLM events (start on content, stop on message end)</done>
</task>

<task type="auto">
  <name>Task 3: Add key binding for thinking toggle</name>
  <files>src/tui/keybindings.rs</files>
  <action>
Add a key binding to toggle thinking block collapse:

1. Find the key handling code (likely a match on KeyCode)

2. Add a new key binding (e.g., 't' for thinking toggle):
   ```rust
   KeyCode::Char('t') => {
       // Toggle thinking blocks collapse state
       // If there's a selected thinking block, toggle it
       // Or toggle all thinking blocks globally
       app.toggle_all_thinking_collapsed();
   }
   ```

3. Add helper method to App if needed:
   ```rust
   /// Toggle all thinking blocks collapsed state.
   pub fn toggle_all_thinking_collapsed(&mut self) {
       // Simple toggle - could be more sophisticated
       // For now, just toggle the first one as a demo
       if !self.thinking_collapsed.is_empty() {
           let global_state = !self.thinking_collapsed.values().next().unwrap_or(&false);
           for (_, v) in self.thinking_collapsed.iter_mut() {
               *v = global_state;
           }
       }
   }
   ```

4. Update the footer help text to include 't:thinking' hint:
   - Find where key hints string is defined
   - Add "t:thinking" to the hints

Note: The existing keybindings may use Tab for expand/collapse groups. The 't' key can specifically target thinking blocks in conversation view.
  </action>
  <verify>
`cargo check` succeeds.
`grep -n "KeyCode::Char('t')" src/tui/keybindings.rs` shows new binding.
`grep -n "t:thinking|thinking" src/tui/ui.rs` shows hint in footer (if added there).
  </verify>
  <done>Key 't' toggles thinking block collapse state; footer hints updated</done>
</task>

</tasks>

<verification>
```bash
# Check compilation
cargo check

# Verify spinner integration
grep -n "render_spinner" src/tui/ui.rs
grep -n "is_streaming" src/tui/ui.rs

# Verify event handling
grep -n "start_streaming|stop_streaming" src/tui/event.rs

# Verify key binding
grep -n "'t'" src/tui/keybindings.rs

# Run tests to ensure no regressions
cargo test --lib tui

# Full build
cargo build
```
</verification>

<success_criteria>
1. Spinner appears in UI when is_streaming is true
2. Spinner animates (advances on tick)
3. Spinner disappears when streaming stops
4. Event handler sets is_streaming true on content events
5. Event handler sets is_streaming false on message end
6. Key 't' toggles thinking block collapse
7. Footer help text includes thinking toggle hint
8. All TUI tests pass
9. `cargo build` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/14-tui-visual-parity-with-claude-code/14-06-SUMMARY.md`
</output>
