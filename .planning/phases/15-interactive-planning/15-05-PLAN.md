---
phase: 15-interactive-planning
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/fake_claude_lib/stream_json.rs
  - tests/fake_claude_lib/scenario.rs
  - tests/fake_claude_lib/prebuilt.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "fake_claude can emit system init events with session_id"
    - "fake_claude can emit AskUserQuestion tool_use events"
    - "ScenarioBuilder can configure interactive Q&A scenarios"
    - "Prebuilt interactive_planning scenario exists and works"
  artifacts:
    - path: "tests/fake_claude_lib/stream_json.rs"
      provides: "system_init_with_session and ask_user_question constructors"
      contains: "session_id"
    - path: "tests/fake_claude_lib/scenario.rs"
      provides: "with_session_id and asks_questions methods"
      contains: "asks_questions"
    - path: "tests/fake_claude_lib/prebuilt.rs"
      provides: "interactive_planning prebuilt scenario"
      contains: "interactive_planning"
  key_links:
    - from: "tests/fake_claude_lib/scenario.rs"
      to: "tests/fake_claude_lib/stream_json.rs"
      via: "ScenarioBuilder uses StreamEventOutput constructors"
      pattern: "StreamEventOutput::(system_init_with_session|ask_user_question)"
---

<objective>
Extend fake_claude test infrastructure to simulate AskUserQuestion tool_use events

Purpose: Enable E2E testing of the interactive Q&A flow without requiring real Claude CLI. The existing fake_claude can simulate tool use and text responses, but lacks session_id and AskUserQuestion simulation needed to test Phase 15 features.

Output: Updated fake_claude_lib with session_id support, AskUserQuestion helpers, and prebuilt interactive scenarios.
</objective>

<execution_context>
@/Users/vmakaev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vmakaev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-interactive-planning/15-GAP-RESEARCH.md

# Existing fake_claude implementation (reference for extension patterns)
@tests/fake_claude_lib/stream_json.rs
@tests/fake_claude_lib/scenario.rs
@tests/fake_claude_lib/prebuilt.rs

# Real stream_json types (target format to match)
@src/subprocess/stream_json.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add session_id and subtype to StreamEventOutput</name>
  <files>tests/fake_claude_lib/stream_json.rs</files>
  <action>
Add two new fields to StreamEventOutput struct:
1. `subtype: Option<String>` with `#[serde(skip_serializing_if = "Option::is_none")]`
2. `session_id: Option<String>` with `#[serde(skip_serializing_if = "Option::is_none")]`

Add new constructor method:
```rust
/// Create a system init event with session_id for testing session resume.
pub fn system_init_with_session(session_id: &str) -> Self {
    Self {
        event_type: "system".to_string(),
        subtype: Some("init".to_string()),
        session_id: Some(session_id.to_string()),
        message: None,
        uuid: Some(uuid_v4_simple()),
        timestamp: Some(chrono::Utc::now().to_rfc3339()),
    }
}
```

Update existing `system_init()` to set subtype: Some("init") for consistency.

Add helper for AskUserQuestion:
```rust
/// Create an AskUserQuestion tool_use event.
///
/// This simulates Claude asking clarifying questions via the AskUserQuestion tool.
/// The event will have stop_reason="tool_use" to indicate Claude is waiting for input.
pub fn ask_user_question(questions: Vec<&str>) -> Self {
    let questions_json: Vec<serde_json::Value> = questions
        .into_iter()
        .map(|q| serde_json::Value::String(q.to_string()))
        .collect();

    let input = serde_json::json!({
        "questions": questions_json
    });

    let id = next_tool_id();
    Self::assistant_with_blocks(
        vec![ContentBlockOutput::tool_use(&id, "AskUserQuestion", input)],
        Some("tool_use"),
    )
}
```
  </action>
  <verify>cargo test --package rslph --test fake_claude -- --nocapture 2>&1 | head -20</verify>
  <done>StreamEventOutput has session_id and subtype fields, system_init_with_session() and ask_user_question() methods compile and produce valid JSON</done>
</task>

<task type="auto">
  <name>Task 2: Add ScenarioBuilder methods for interactive scenarios</name>
  <files>tests/fake_claude_lib/scenario.rs</files>
  <action>
Add two new methods to ScenarioBuilder impl block:

```rust
/// Start this invocation with a system init event containing a session ID.
///
/// Use this for scenarios that need session resume testing.
/// The init event is added at the beginning of the current invocation's events.
pub fn with_session_id(mut self, session_id: &str) -> Self {
    // Insert init event at the beginning
    self.current_invocation.events.insert(
        0,
        StreamEventOutput::system_init_with_session(session_id)
    );
    self
}

/// Add an AskUserQuestion tool_use event to current invocation.
///
/// The event will have stop_reason="tool_use" to indicate
/// Claude is waiting for user input before continuing.
pub fn asks_questions(mut self, questions: Vec<&str>) -> Self {
    self.current_invocation.events.push(
        StreamEventOutput::ask_user_question(questions)
    );
    // Add a result event to properly terminate the invocation
    self.current_invocation.events.push(
        StreamEventOutput::result(0.001)
    );
    self
}
```

Note: `with_session_id` inserts at beginning so it can be called after `respond_with_text` or used standalone. The `asks_questions` method adds a result event so the invocation terminates properly.
  </action>
  <verify>cargo build --tests 2>&1 | tail -10</verify>
  <done>ScenarioBuilder has with_session_id() and asks_questions() methods that work with the invocation flow</done>
</task>

<task type="auto">
  <name>Task 3: Add prebuilt interactive scenarios and unit tests</name>
  <files>tests/fake_claude_lib/prebuilt.rs</files>
  <action>
Add two new prebuilt scenarios:

```rust
/// Create a fake Claude scenario with AskUserQuestion flow.
///
/// This scenario simulates:
/// 1. Initial call: Emits system init + AskUserQuestion
/// 2. Resume call: Receives answers, produces progress file
pub fn interactive_planning() -> ScenarioBuilder {
    let progress = r#"# Progress: Interactive Test

## Status

RALPH_DONE - All tasks complete

## Tasks

### Phase 1: Setup

- [x] Configure project based on user answers

## Testing Strategy

Basic tests.
"#;

    ScenarioBuilder::new()
        // Invocation 0: Ask questions
        .with_session_id("test-session-123")
        .asks_questions(vec![
            "What programming language do you want to use?",
            "What database backend should we use?"
        ])
        .next_invocation()
        // Invocation 1: Resume with answers, produce progress file
        .with_session_id("test-session-123")
        .respond_with_text(progress)
}

/// Create a multi-round Q&A scenario.
///
/// Simulates two rounds of questions before producing final output.
pub fn multi_round_qa() -> ScenarioBuilder {
    let progress = r#"# Progress: Multi-Round Test

## Status

RALPH_DONE - All tasks complete

## Tasks

### Phase 1: Done

- [x] Task complete based on multi-round Q&A

## Testing Strategy

Verified through multiple question rounds.
"#;

    ScenarioBuilder::new()
        // Round 1: First questions
        .with_session_id("multi-session-456")
        .asks_questions(vec!["Question round 1?"])
        .next_invocation()
        // Round 2: Follow-up questions
        .with_session_id("multi-session-456")
        .asks_questions(vec!["Question round 2?"])
        .next_invocation()
        // Round 3: Final response
        .with_session_id("multi-session-456")
        .respond_with_text(progress)
}
```

Add unit tests in the `tests` module at the bottom:

```rust
#[test]
fn test_interactive_planning_scenario_builds() {
    let handle = interactive_planning().build();
    assert!(handle.executable_path.exists() || true); // May not exist before full build
}

#[test]
fn test_multi_round_qa_scenario_builds() {
    let handle = multi_round_qa().build();
    assert!(handle.executable_path.exists() || true);
}

#[test]
fn test_interactive_planning_invocations() {
    // Verify the scenario has the right number of invocations
    // (indirectly through building)
    let _handle = interactive_planning().build();
}
```
  </action>
  <verify>cargo test --package rslph --test fake_claude prebuilt -- --nocapture 2>&1</verify>
  <done>interactive_planning() and multi_round_qa() prebuilt scenarios exist, unit tests pass, scenarios build without errors</done>
</task>

</tasks>

<verification>
1. `cargo build --tests` compiles without errors
2. `cargo test fake_claude` runs existing and new tests
3. New scenarios can be instantiated: `interactive_planning().build()` works
4. JSON output from system_init_with_session contains session_id field
</verification>

<success_criteria>
- StreamEventOutput has session_id and subtype fields
- system_init_with_session() creates events with session_id
- ask_user_question() creates AskUserQuestion tool_use events
- ScenarioBuilder has with_session_id() and asks_questions() methods
- interactive_planning() and multi_round_qa() prebuilt scenarios exist
- All fake_claude tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-interactive-planning/15-05-SUMMARY.md`
</output>
